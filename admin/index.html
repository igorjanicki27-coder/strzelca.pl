<!doctype html>
<html lang="pl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Favicon -->
    <link
      rel="icon"
      type="image/svg+xml"
      href="https://strzelca.pl/ikona.svg"
    />
    <link rel="apple-touch-icon" href="https://strzelca.pl/ikona.svg" />

    <title>Panel Administracyjny STRZELCA.PL</title>
    <!-- Restored to working version: dzien 20 wsad 25 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700;900&family=Inter:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css"
    />
    <!-- Wspólne poprawki responsywności -->
    <link rel="stylesheet" href="https://strzelca.pl/shared.css?v=2026-02-06-1" />
    <style>
      :root {
        --coyote: #c19a6b;
      }

      /* Ustawienie tła na elemencie html dla Safari */
      html {
        background-color: #0a0a0a;
        background-image:
          linear-gradient(rgba(10, 10, 10, 0.6), #0a0a0a),
          url("/tlo.png");
        background-size: cover;
        background-position: center top;
        background-attachment: fixed;
        background-repeat: no-repeat;
        min-height: 100vh; /* Minimalna wysokość zamiast stałej */
        /* Safari viewport height fix */
        min-height: -webkit-fill-available;
        min-height: 100dvh; /* Dynamic viewport height for modern browsers */
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Inter", sans-serif;
        background: transparent; /* Przejrzyste tło, żeby pokazać tło html */
        color: #e5e5e5;
        margin: 0;
        padding: 0;
        width: 100%;
        min-height: 100vh; /* Minimalna wysokość zamiast stałej */
        /* Safari viewport height fix */
        min-height: -webkit-fill-available;
        min-height: 100dvh; /* Dynamic viewport height for modern browsers */
        overflow-x: hidden; /* Zapobiega "pływaniu" strony na boki w Safari */
      }

      /* Sekcja logowania zajmuje całą wysokość, żeby nie było czarnego paska */
      #login-section {
        min-height: 100vh;
        min-height: 100dvh; /* Dynamic viewport height */
        min-height: -webkit-fill-available; /* Safari */
      }
      .coyote-text {
        color: var(--coyote);
        font-family: "Orbitron";
      }
      .admin-text {
        color: #dc2626;
        font-family: "Orbitron";
      }

      input,
      select,
      textarea {
        background: #111 !important;
        border: 1px solid #222 !important;
        color: white !important;
        padding: 12px 16px !important;
        border-radius: 8px;
        width: 100%;
        outline: none;
        transition: 0.3s;
      }
      input:focus,
      select:focus,
      textarea:focus {
        border-color: var(--coyote) !important;
        background: #161616 !important;
      }

      .btn-admin {
        background: var(--coyote);
        color: black;
        font-weight: 900;
        text-transform: uppercase;
        letter-spacing: 1px;
        padding: 12px 24px;
        border-radius: 8px;
        transition: 0.3s;
        cursor: pointer;
      }
      .btn-admin:hover {
        transform: scale(1.05);
        box-shadow: 0 0 15px rgba(193, 154, 107, 0.3);
      }
      .btn-admin:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      /* Loading states */
      .loading-spinner {
        position: relative;
        overflow: hidden;
      }

      .loading-spinner::before {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(193, 154, 107, 0.4), transparent);
        animation: shimmer 1.5s ease-in-out infinite;
      }

      .loading-spinner i.fa-sync-alt {
        animation: spin 1s linear infinite;
        color: rgba(0, 0, 0, 0.8) !important;
      }

      /* Globalny loading overlay dla dashboardu */
      .dashboard-loading-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(10, 10, 10, 0.7);
        backdrop-filter: blur(2px);
        z-index: 9999;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
      }

      .dashboard-loading-overlay.active {
        opacity: 1;
        pointer-events: auto;
      }

      .loading-content {
        background: #111;
        border: 1px solid var(--coyote);
        border-radius: 12px;
        padding: 24px;
        text-align: center;
        box-shadow: 0 0 30px rgba(193, 154, 107, 0.3);
      }

      .loading-spinner-large {
        font-size: 2em;
        color: var(--coyote);
        margin-bottom: 16px;
        animation: spin 1s linear infinite;
      }

      .loading-text {
        color: white;
        font-family: "Orbitron";
        font-size: 1.1em;
        margin: 0;
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      @keyframes shimmer {
        0% { left: -100%; }
        100% { left: 100%; }
      }

      @keyframes fadeIn {
        0% { opacity: 0; transform: translateY(10px); }
        100% { opacity: 1; transform: translateY(0); }
      }

      .animate-fade-in {
        animation: fadeIn 0.3s ease-out;
      }

      .admin-card {
        background: #111;
        border: 1px solid #222;
        border-radius: 12px;
        padding: 24px;
        transition: 0.3s;
      }
      .admin-card:hover {
        border-color: var(--coyote);
      }

      /* Poprawki dla modali - lepsza widoczność */
      #user-details-modal .admin-card,
      #user-delete-modal .admin-card {
        background: #0f0f0f;
        border: 1px solid #333;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
      }
      
      #user-details-modal .admin-card *,
      #user-delete-modal .admin-card * {
        color: inherit;
      }
      
      #user-details-modal .text-white,
      #user-delete-modal .text-white {
        color: #ffffff !important;
      }
      
      #user-details-modal .text-zinc-400,
      #user-delete-modal .text-zinc-400 {
        color: #a1a1aa !important;
      }

      /* Styl dla górnego paska nawigacji */
      .top-nav {
        background: rgba(0, 0, 0, 0.4);
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      }

      /* Liquid Glass Effect */
      .liquid-glass {
        background: rgba(193, 154, 107, 0.05);
        backdrop-filter: blur(15px);
        -webkit-backdrop-filter: blur(15px);
        border: 1px solid rgba(193, 154, 107, 0.2);
        border-radius: 12px;
        transition: 0.3s;
      }
      .liquid-glass:hover {
        border-color: rgba(193, 154, 107, 0.4);
        background: rgba(193, 154, 107, 0.08);
      }

      /* Glowing Border Effect */
      .glowing-border {
        animation: glow 2s ease-in-out infinite alternate;
      }

      @keyframes glow {
        from {
          box-shadow: 0 0 5px rgba(193, 154, 107, 0.5);
        }
        to {
          box-shadow: 0 0 20px rgba(193, 154, 107, 0.8);
        }
      }

      /* Style dla zakładek w poziomie */
      #tabs-container .nav-item {
        padding: 8px 12px;
        border-radius: 12px;
        margin: 2px 0;
        font-size: 13px;
        white-space: nowrap;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      #tabs-container .nav-pages-toggle {
        padding: 8px 12px;
        border-radius: 12px;
        margin: 2px 0;
        font-size: 13px;
        white-space: nowrap;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
      }

      #tabs-container .nav-section-title {
        margin: 0 8px 0 0;
        padding: 4px 8px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 8px;
        font-size: 10px;
      }

      /* Rozwijane menu stron w poziomie */
      .nav-submenu {
        background: rgba(0, 0, 0, 0.95);
        backdrop-filter: blur(20px);
        border-top: 1px solid rgba(255, 255, 255, 0.08);
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.3s ease;
      }

      .nav-submenu.open {
        max-height: 200px;
      }

      .nav-submenu-item {
        padding: 8px 16px;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        font-weight: 300;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        border-radius: 8px;
        margin: 2px;
        font-size: 12px;
        background: rgba(255, 255, 255, 0.05);
      }

      .nav-submenu-item:hover {
        background: rgba(193, 154, 107, 0.08);
        color: rgba(193, 154, 107, 0.95);
        transform: translateY(-1px);
      }

      .nav-submenu-item.active {
        background: rgba(193, 154, 107, 0.06);
        color: rgba(193, 154, 107, 0.9);
        box-shadow: 0 0 16px rgba(193, 154, 107, 0.2);
        border: 1px solid rgba(193, 154, 107, 0.15);
      }

      /* Scrollbar hide utility */
      .scrollbar-hide {
        -ms-overflow-style: none;
        scrollbar-width: none;
      }
      .scrollbar-hide::-webkit-scrollbar {
        display: none;
      }

      /* Kompaktowy sidebar */
      .compact-sidebar {
        width: 64px;
        background: rgba(0, 0, 0, 0.2);
        backdrop-filter: blur(20px);
        border-right: 1px solid rgba(255, 255, 255, 0.08);
      }

      .nav-item {
        padding: 10px 13px;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        font-weight: 300;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        border-radius: 16px;
        margin: 3px 12px;
        position: relative;
        overflow: hidden;
        backdrop-filter: blur(10px);
      }
      .nav-item:hover {
        background: rgba(193, 154, 107, 0.08);
        color: rgba(193, 154, 107, 0.95);
        transform: translateX(2px) scale(1.01);
        box-shadow:
          0 4px 16px rgba(193, 154, 107, 0.12),
          0 0 0 1px rgba(193, 154, 107, 0.1);
      }
      .nav-item.active {
        background: rgba(193, 154, 107, 0.06);
        color: rgba(193, 154, 107, 0.9);
        box-shadow:
          0 0 24px rgba(193, 154, 107, 0.15),
          0 2px 8px rgba(193, 154, 107, 0.1),
          inset 0 1px 0 rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(193, 154, 107, 0.15);
      }

      .admin-name {
        color: var(--coyote);
        font-family: "Orbitron";
        font-weight: 700;
      }

      .coyote {
        color: var(--coyote);
      }

      .editor-content {
        background: #161616;
        border: 1px solid #222;
        border-radius: 8px;
        padding: 16px;
        min-height: 200px;
        color: white;
      }

      .toolbar {
        background: #111;
        border: 1px solid #222;
        border-radius: 8px;
        padding: 8px;
        margin-bottom: 8px;
      }
      .toolbar button {
        background: #222;
        border: none;
        color: white;
        padding: 8px 12px;
        margin: 0 2px;
        border-radius: 4px;
        cursor: pointer;
        transition: 0.3s;
      }
      .toolbar button:hover {
        background: var(--coyote);
        color: black;
      }

      .status-active {
        border-left: 4px solid #10b981;
        background: rgba(16, 185, 129, 0.1);
      }
      .status-blocked {
        border-left: 4px solid #ef4444;
        background: rgba(239, 68, 68, 0.1);
      }
      .status-suspended {
        border-left: 4px solid #f59e0b;
        background: rgba(245, 158, 11, 0.1);
      }

      .role-admin {
        background: #dc2626;
        color: white;
      }
      .role-user {
        background: white;
        color: black;
      }
      .role-company {
        background: var(--coyote);
        color: black;
      }

      .nav-section-title {
        margin-top: 16px;
        padding: 8px 16px 4px 16px;
        font-weight: 500;
        font-size: 11px;
        opacity: 0.7;
      }
      .nav-section-title:first-child {
        margin-top: 0;
        padding-top: 4px;
      }

      .nav-submenu {
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.3s ease;
        background: rgba(193, 154, 107, 0.05);
        border-radius: 12px;
        margin: 4px 12px;
      }

      .nav-submenu.open {
        max-height: 500px;
      }

      .nav-submenu-item {
        padding: 10px 16px 10px 40px;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        font-weight: 300;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        border-radius: 8px;
        margin: 2px 4px;
        font-size: 13px;
      }

      .nav-submenu-item:hover {
        background: rgba(193, 154, 107, 0.08);
        color: rgba(193, 154, 107, 0.95);
        transform: translateX(2px);
      }

      .nav-submenu-item.active {
        background: rgba(193, 154, 107, 0.06);
        color: rgba(193, 154, 107, 0.9);
        box-shadow:
          0 0 24px rgba(193, 154, 107, 0.15),
          0 2px 8px rgba(193, 154, 107, 0.1),
          inset 0 1px 0 rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(193, 154, 107, 0.15);
      }

      .nav-pages-toggle:hover {
        background: rgba(193, 154, 107, 0.08);
        color: rgba(193, 154, 107, 0.95);
        transform: translateX(2px) scale(1.01);
        box-shadow:
          0 4px 16px rgba(193, 154, 107, 0.12),
          0 0 0 1px rgba(193, 154, 107, 0.1);
      }

      .nav-pages-toggle.active {
        background: rgba(193, 154, 107, 0.06);
        color: rgba(193, 154, 107, 0.9);
        box-shadow:
          0 0 24px rgba(193, 154, 107, 0.15),
          0 2px 8px rgba(193, 154, 107, 0.1),
          inset 0 1px 0 rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(193, 154, 107, 0.15);
      }

      .tab-content {
        display: none;
      }
      .tab-content.active {
        display: block;
      }

      /* Animacja ładowania dla przycisków */
      .loading-spinner {
        position: relative;
        pointer-events: none;
      }

      .loading-spinner::before {
        content: '';
        position: absolute;
        left: 50%;
        top: 50%;
        width: 16px;
        height: 16px;
        margin-left: -8px;
        margin-top: -8px;
        border: 2px solid transparent;
        border-top: 2px solid currentColor;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      .loading-spinner > * {
        opacity: 0.7;
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      /* Style dla elementów konwersacji */
      .conversation-item:hover {
        transform: translateX(2px);
      }
    </style>

    <!-- Cookies/zgody + warunkowe ładowanie analityki -->
    <script src="https://strzelca.pl/consent.js?v=2026-02-06-1"></script>
  </head>
  <body>
    <script>
      // Dynamiczne ustawienie ścieżki do tła
      document.addEventListener('DOMContentLoaded', function() {
        const htmlElement = document.documentElement;
        const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' || window.location.protocol === 'file:';

        if (isLocalhost) {
          // Dla lokalnego środowiska użyj względnej ścieżki
          htmlElement.style.backgroundImage = 'linear-gradient(rgba(10, 10, 10, 0.6), #0a0a0a), url("../tlo.png")';
        } else {
          // Dla domeny użyj zewnętrznego URL-a
          htmlElement.style.backgroundImage = 'linear-gradient(rgba(10, 10, 10, 0.6), #0a0a0a), url("https://strzelca.pl/tlo.png")';
        }
      });
    </script>

    <!-- Sekcja startowa (bez osobnego logowania admina) -->
    <div
      id="login-section"
      class="h-full flex items-start justify-center p-6 pt-16 md:pt-20 lg:pt-24"
    >
      <div class="admin-card max-w-md w-full">
        <h1
          class="text-3xl font-black uppercase italic font-[Orbitron] text-center mb-6"
        >
          <span class="coyote-text">PANEL</span>
          <span class="admin-text">ADMINISTRATORA</span>
        </h1>

        <div class="text-center text-zinc-300">
          <div class="text-sm text-zinc-400">
            Sprawdzanie logowania i uprawnień…
          </div>
          <div class="mt-5">
            <i class="fa-solid fa-spinner fa-spin text-zinc-400 text-2xl"></i>
          </div>

          <div class="mt-7 text-xs text-zinc-500 leading-relaxed">
            Jeśli nie jesteś zalogowany, za chwilę nastąpi przekierowanie do wspólnego logowania.
          </div>

          <div class="mt-6">
            <a
              class="btn-admin inline-flex items-center justify-center w-full"
              href="https://konto.strzelca.pl/logowanie.html?redirect=https%3A%2F%2Fstrzelca.pl%2Fadmin%2Findex.html"
            >
              Przejdź do logowania
            </a>
          </div>
        </div>

        <div
          id="login-status"
          class="mt-6 p-4 rounded-lg text-center text-sm hidden"
        ></div>
      </div>
    </div>

    <!-- Główny panel administracyjny -->
    <div id="admin-panel" class="hidden h-full flex flex-col">
      <!-- Górny pasek nawigacji -->
      <div class="bg-black/40 backdrop-blur-xl border-b border-zinc-700/50 sticky top-0 z-50">
        <div class="flex items-center justify-between px-4 py-3">
          <!-- Strzałka cofająca -->
          <div class="flex items-center space-x-4">
            <button
              onclick="toggleSidebar()"
              class="md:hidden text-zinc-400 hover:text-white transition p-2"
              id="mobile-menu-btn"
            >
              <i class="fa-solid fa-bars text-lg"></i>
            </button>
            <a
              href="https://strzelca.pl"
              aria-label="Powrót do centrum dowodzenia"
              class="hidden md:flex text-zinc-400 hover:text-white transition p-2"
            >
              <i class="fa-solid fa-arrow-left text-lg"></i>
            </a>
          </div>

          <!-- Panel Admina na środku -->
          <div class="flex items-center space-x-3">
              <i class="fa-solid fa-crown text-coyote text-xl"></i>
            <span class="text-white font-bold text-lg">Panel Admina</span>
            </div>

          <!-- Profil administratora (kompaktowy) -->
          <div class="flex items-center space-x-3">
            <div class="hidden sm:flex items-center space-x-2 text-sm">
              <span id="admin-display-name-compact" class="text-white font-medium"></span>
            </div>
            <div class="w-8 h-8 rounded-full bg-gradient-to-br from-coyote/20 to-zinc-600/40 flex items-center justify-center border border-zinc-500/20">
              <i class="fa-solid fa-user-shield text-coyote text-sm"></i>
          </div>
          <button
            onclick="logoutAdmin()"
              class="text-zinc-400 hover:text-red-400 transition p-2"
              title="Wyloguj"
          >
              <i class="fa-solid fa-sign-out-alt text-sm"></i>
          </button>
          </div>
        </div>

        <!-- Pasek zakładek -->
        <nav class="px-4 pb-3">
          <!-- Pierwsza linia: Zarządzanie po lewej, status po prawej -->
          <div class="flex items-center justify-between mb-2">
            <div class="flex items-center space-x-4">
              <div class="nav-item" data-tab="dashboard">
                <i class="fa-solid fa-tachometer-alt mr-2"></i>
                Dashboard
              </div>
              <div class="nav-item" data-tab="users">
                <i class="fa-solid fa-users mr-2"></i>
                Użytkownicy
              </div>
              <div class="nav-item" data-tab="newsletter">
                <i class="fa-solid fa-envelope-open mr-2"></i>
                Newsletter
              </div>
            </div>
            <div class="nav-item" data-tab="status">
              <i class="fa-solid fa-server mr-2"></i>
              <span id="status-tab-text">Status</span>
            </div>
          </div>

          <!-- Druga linia: Zakładki stron -->
          <div class="flex items-center justify-start space-x-8 overflow-x-auto scrollbar-hide" id="tabs-container">
            <div class="nav-item" data-tab="products">
              <i class="fa-solid fa-shopping-cart mr-2"></i>
              Sklep
            </div>
            <div class="nav-item" data-tab="bazar">
              <i class="fa-solid fa-store mr-2"></i>
              Bazar
            </div>
            <div class="nav-item" data-tab="szkolenia">
              <i class="fa-solid fa-graduation-cap mr-2"></i>
              Szkolenia
            </div>
            <div class="nav-item" data-tab="events">
              <i class="fa-solid fa-calendar-alt mr-2"></i>
              Wydarzenia
            </div>
            <div class="nav-item" data-tab="blog">
              <i class="fa-solid fa-blog mr-2"></i>
              Blog
            </div>
            <div class="nav-item" data-tab="charity">
              <i class="fa-solid fa-heart mr-2"></i>
              Pomoc
            </div>
            <div class="nav-item" data-tab="dokumenty">
              <i class="fa-solid fa-file-pdf mr-2"></i>
              Dokumenty
            </div>
            <div class="nav-item" data-tab="kontakt">
              <i class="fa-solid fa-address-book mr-2"></i>
              Kontakt
            </div>
          </div>
        </nav>
      </div>

      <!-- Główna zawartość -->
      <div class="flex flex-1 min-h-0">
        <!-- Zawartość główna -->
        <div class="flex-1 p-4 md:p-8 overflow-y-auto" id="main-content">
          <!-- Status -->
          <div id="tab-status" class="tab-content">

            <!-- Sekcja System Serwera -->
          <div class="admin-card mb-8 mt-6">
              <div class="flex justify-between items-center mb-6">
                <h2 class="text-2xl font-bold coyote-text">Monitoring usług</h2>
                <button
                  onclick="checkMainServicesStatus()"
                  class="btn-admin text-sm px-3 py-1"
                >
                  <i class="fa-solid fa-sync-alt mr-1"></i>
                  Odśwież
                </button>
                </div>

              <!-- Główny status serwera - kompaktowy design -->
              <div class="bg-zinc-800/50 rounded-xl p-6 mb-8">

                <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                  <!-- Status bazy danych -->
                  <div class="text-center">
                    <div class="flex items-center justify-center space-x-3 mb-2">
                      <i class="fa-solid fa-database text-lg text-zinc-400"></i>
                      <span class="text-sm font-medium text-zinc-300"
                        >Baza danych</span
                      >
                    </div>
                    <div
                      class="flex items-center justify-center space-x-2 animate-fade-in"
                      id="firestore-status"
                    >
                <span class="text-green-400"
                        ><i class="fa-solid fa-check-circle text-lg"></i
                      ></span>
                      <span class="text-green-400 font-semibold text-sm"
                        >Online</span
                      >
                    </div>
                  </div>

                  <!-- Status logowania -->
                  <div class="text-center">
                    <div class="flex items-center justify-center space-x-3 mb-2">
                      <i class="fa-solid fa-user-shield text-lg text-zinc-400"></i>
                      <span class="text-sm font-medium text-zinc-300"
                        >Logowanie</span
                      >
                    </div>
                    <div
                      class="flex items-center justify-center space-x-2 animate-fade-in"
                      id="auth-status"
                    >
                      <span class="text-green-400"
                        ><i class="fa-solid fa-check-circle text-lg"></i
                      ></span>
                      <span class="text-green-400 font-semibold text-sm"
                        >Połączony</span
                      >
                    </div>
                  </div>

                  <!-- Status domeny -->
                  <div class="text-center">
                    <div class="flex items-center justify-center space-x-3 mb-2">
                      <i class="fa-solid fa-globe text-lg text-zinc-400"></i>
                      <span class="text-sm font-medium text-zinc-300"
                        >Domena</span
                      >
                    </div>
                    <div
                      class="flex items-center justify-center space-x-2 animate-fade-in"
                      id="domain-status"
                    >
                      <span class="text-green-400"
                        ><i class="fa-solid fa-check-circle text-lg"></i
                      ></span>
                      <span class="text-green-400 font-semibold text-sm"
                        >Online</span
                      >
                    </div>
                  </div>
              </div>
            </div>

            <div
                class="grid grid-cols-1 lg:grid-cols-2 gap-3"
              id="sites-status"
            >
              <!-- Status stron będzie ładowany dynamicznie -->
            </div>

            <div class="mt-4 text-sm text-zinc-400 text-center">
              <span
                >Ostatnie sprawdzenie:
                <span id="last-status-check">Teraz</span></span
              >
              </div>
            </div>

            <!-- Sekcja Zdarzenia -->
            <div class="admin-card mb-8">
              <div class="flex justify-between items-center mb-6">
                <h2 class="text-2xl font-bold coyote-text">Zdarzenia</h2>
                <div class="flex space-x-2">
                <button
                  onclick="loadEventsLog()"
                  class="text-zinc-400 hover:text-coyote transition-colors p-2"
                  id="refresh-events-btn"
                >
                  <i class="fa-solid fa-sync-alt text-lg" id="refresh-events-icon"></i>
                </button>
                  <button
                    onclick="clearAllEvents()"
                    class="btn-danger text-sm px-3 py-1"
                  >
                    <i class="fa-solid fa-trash mr-1"></i>
                    Usuń wszystkie
                </button>
                </div>
              </div>

              <div id="events-log-container">
                <!-- Tabela zdarzeń będzie ładowana dynamicznie -->
                <div class="text-center text-zinc-400 py-4">
                  <i class="fa-solid fa-spinner fa-spin mr-2"></i>Ładowanie logów...
                </div>
              </div>
            </div>
          </div>

        <!-- Dashboard -->
          <div id="tab-dashboard" class="tab-content active">

            <!-- Sekcja 1: Aktywność -->
            <div class="admin-card mb-8">

              <!-- Główny kontener z podziałem na sekcje -->
              <div
                class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-2 gap-6 mb-6 min-h-[280px]"
              >
                <!-- Lewa część: Aktywność użytkowników (50% szer, 70% wys) -->
                <div
                  class="bg-zinc-800/50 rounded-lg p-4 flex flex-col justify-center"
                >
                  <h3 class="text-lg font-semibold text-white mb-4 text-center">
                    Aktywność
                  </h3>
                  <div class="space-y-4 flex-1 flex flex-col justify-center">
              <div class="text-center">
                <div
                        class="text-2xl font-bold coyote-text mb-1"
                        id="active-logged-users"
                >
                  0
                </div>
                      <div class="text-sm text-zinc-400">Zalogowani</div>
              </div>
              <div class="text-center">
                <div
                        class="text-2xl font-bold coyote-text mb-1"
                        id="active-guests"
                >
                  0
                </div>
                      <div class="text-sm text-zinc-400">Goście</div>
              </div>
              <div class="text-center">
                <div
                        class="text-2xl font-bold text-green-400 mb-1"
                        id="active-total"
                >
                  0
                </div>
                      <div class="text-sm text-zinc-400">Razem</div>
                </div>
              </div>
                </div>

                <!-- Prawa część: Sprawy (50% szer, 70% wys) -->
                <div
                  class="bg-zinc-800/50 rounded-lg p-4 flex flex-col justify-center"
                >
                  <h3 class="text-lg font-semibold text-white mb-4 text-center">
                    Sprawy
                  </h3>
                  <div class="space-y-4 flex-1 flex flex-col justify-center">
              <div class="text-center">
                <div
                        class="text-2xl font-bold text-red-400 mb-1"
                        id="pending-issues"
                >
                  0
                </div>
                      <div class="text-sm text-zinc-400">Niezakończone</div>
                    </div>
                    <div class="text-center">
                      <div
                        class="text-2xl font-bold text-green-400 mb-1"
                        id="new-forms-today"
                      >
                        0
                      </div>
                      <div class="text-sm text-zinc-400">Nowe formularze</div>
                    </div>
                    <div class="text-center">
                      <div
                        class="text-2xl font-bold text-blue-400 mb-1"
                        id="total-issues"
                      >
                        0
                      </div>
                      <div class="text-sm text-zinc-400">Razem</div>
                    </div>
                  </div>
              </div>
            </div>

              <!-- Dolna część: Odwiedziny (100% szer, 30% wys) -->
              <div class="bg-zinc-800/50 rounded-lg p-4 min-h-[120px]">
                <h3 class="text-lg font-semibold text-white mb-4 text-center">
                  Odwiedziny
                </h3>
                <div
                  class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4 h-full"
                >
              <div class="text-center">
                <div
                  class="text-xl font-bold text-blue-400 mb-1"
                      id="visits-today"
                >
                  0
                </div>
                    <div class="text-xs text-zinc-400">Dziś</div>
              </div>
              <div class="text-center">
                <div
                  class="text-xl font-bold text-blue-400 mb-1"
                      id="visits-week"
                >
                  0
                </div>
                    <div class="text-xs text-zinc-400">Tydzień</div>
              </div>
              <div class="text-center">
                <div
                  class="text-xl font-bold text-blue-400 mb-1"
                      id="visits-month"
                >
                  0
                </div>
                    <div class="text-xs text-zinc-400">Miesiąc</div>
              </div>
                  <div class="text-center">
                    <div
                      class="text-xl font-bold text-blue-400 mb-1"
                      id="visits-year"
                    >
                      0
                    </div>
                    <div class="text-xs text-zinc-400">Rok</div>
                  </div>
                  <div class="text-center">
                    <div
                      class="text-xl font-bold text-blue-400 mb-1"
                      id="visits-total"
                    >
                      0
                    </div>
                    <div class="text-xs text-zinc-400">Ogółem</div>
                  </div>
            </div>
          </div>

            <!-- Dziennik Aktywności -->
            <div class="admin-card mt-8" style="background: linear-gradient(135deg, rgba(193, 154, 107, 0.1), rgba(193, 154, 107, 0.05)); backdrop-filter: blur(20px); border: 1px solid rgba(193, 154, 107, 0.2);">
              <div class="flex justify-between items-center mb-6">
                <h3 class="text-xl font-bold">Dziennik Aktywności</h3>
                <div class="flex space-x-2">
                  <button onclick="openAllActivityLogsModal()" class="bg-coyote hover:bg-opacity-80 text-white px-4 py-2 rounded-lg font-semibold transition text-sm">
                    <i class="fa-solid fa-list mr-2"></i>
                    Wszystkie logi
                  </button>
                <button onclick="refreshActivityLogs()" class="text-zinc-400 hover:text-coyote transition-colors p-2" id="refresh-activity-btn">
                  <i class="fa-solid fa-sync-alt text-lg" id="refresh-activity-icon"></i>
                </button>
                  <button onclick="clearAllActivityLogs()" class="text-red-400 hover:text-red-300 transition-colors p-2 border border-red-400 rounded" title="Usuń wszystkie logi aktywności">
                    <i class="fa-solid fa-trash text-lg"></i>
                </button>
                </div>
              </div>

              <div id="admin-activity-log" class="space-y-4">
                <!-- Logi aktywności będą ładowane dynamicznie -->
                <div class="text-center text-zinc-500 py-8">
                  <i class="fa-solid fa-spinner fa-spin text-2xl mb-4 text-zinc-600"></i>
                  <h4 class="text-lg font-semibold mb-2">Ładowanie dziennika...</h4>
                  <p class="text-sm">Proszę czekać</p>
                </div>
              </div>
            </div>

            </div>
        </div>

        <!-- Zarządzanie użytkownikami -->
        <div id="tab-users" class="tab-content">
          <div class="flex justify-between items-center mb-8">
            <h1 class="text-3xl font-bold coyote-text">
              Zarządzanie Użytkownikami
            </h1>
              <button
                onclick="refreshUsers()"
                class="btn-admin text-sm px-3 py-2"
              >
              <i class="fa-solid fa-sync-alt mr-1"></i>
              Odśwież
            </button>
          </div>

          <!-- Sekcja najnowszych użytkowników -->
          <div class="admin-card mb-8">
            <h3 class="text-xl font-bold mb-4">Najnowsi użytkownicy</h3>
            <div id="recent-users" class="space-y-3">
              <!-- Najnowsi użytkownicy będą ładowani dynamicznie -->
            </div>
          </div>

          <div class="admin-card mb-6">
            <div class="flex flex-wrap gap-4 mb-4">
              <button
                onclick="filterUsers('all')"
                class="user-filter-btn px-4 py-2 border border-zinc-700 rounded text-sm uppercase active border-coyote text-coyote"
                data-filter="all"
              >
                Wszyscy
              </button>
              <button
                onclick="filterUsers('active')"
                class="user-filter-btn px-4 py-2 border border-zinc-700 rounded text-sm uppercase"
                data-filter="active"
              >
                Aktywni
              </button>
              <button
                  onclick="filterUsers('inactive')"
                class="user-filter-btn px-4 py-2 border border-zinc-700 rounded text-sm uppercase"
                  data-filter="inactive"
              >
                  Nieaktywni
              </button>
              <button
                  onclick="filterUsers('blocked')"
                class="user-filter-btn px-4 py-2 border border-zinc-700 rounded text-sm uppercase"
                  data-filter="blocked"
              >
                  Zablokowani
              </button>
              <button
                onclick="filterUsers('company')"
                class="user-filter-btn px-4 py-2 border border-zinc-700 rounded text-sm uppercase"
                data-filter="company"
              >
                Firmy
              </button>
            </div>

              <div class="mb-4">
                <input
                  type="text"
                  id="user-search"
                  placeholder="Szukaj użytkowników..."
                  class="w-full"
                />
              </div>

              <div id="users-list" class="space-y-3">
                <!-- Lista użytkowników będzie ładowana dynamicznie -->
              </div>

              <div id="users-loading" class="text-center py-8 text-zinc-400">
                <i class="fa-solid fa-spinner fa-spin text-2xl mb-2"></i>
                <p>Ładowanie użytkowników...</p>
              </div>

              <div
                id="users-empty"
                class="text-center py-8 text-zinc-400 hidden"
              >
                <i class="fa-solid fa-users text-4xl mb-4 text-zinc-600"></i>
                <p>Brak użytkowników do wyświetlenia</p>
            </div>
          </div>
        </div>

        <!-- Zarządzanie produktami -->
        <div id="tab-products" class="tab-content">
          <div class="flex justify-between items-center mb-8">
            <h1 class="text-3xl font-bold coyote-text">
              Zarządzanie Produktami
            </h1>
            <button onclick="refreshProducts()" class="text-zinc-400 hover:text-coyote transition-colors p-2" id="refresh-products-btn">
              <i class="fa-solid fa-sync-alt text-lg" id="refresh-products-icon"></i>
            </button>
          </div>

          <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
            <div class="admin-card">
              <h3 class="text-xl font-bold mb-4">Dodaj/Edytuj Produkt</h3>
              <form id="product-form" class="space-y-4">
                <input type="hidden" id="product-id" />
                <input
                  type="text"
                  id="product-title"
                  placeholder="Nazwa produktu"
                  required
                />
                <input
                  type="text"
                  id="product-price"
                  placeholder="Cena (np. 299.99)"
                  required
                />

                <div class="toolbar">
                  <button type="button" onclick="formatText('bold')">
                    <i class="fa-solid fa-bold"></i>
                  </button>
                  <button
                    type="button"
                    onclick="formatText('insertUnorderedList')"
                  >
                    <i class="fa-solid fa-list-ul"></i>
                  </button>
                  <button type="button" onclick="formatText('justifyCenter')">
                    <i class="fa-solid fa-align-center"></i>
                  </button>
                  <button type="button" onclick="insertImage()">
                    <i class="fa-solid fa-image"></i>
                  </button>
                </div>

                <div
                  id="product-description"
                  class="editor-content"
                  contenteditable="true"
                  placeholder="Opis produktu..."
                ></div>

                  <div class="flex space-x-4">
                    <button type="submit" class="btn-admin flex-1">
                  <i class="fa-solid fa-save mr-2"></i>
                  Zapisz produkt
                </button>
                    <button
                      type="button"
                      onclick="clearProductForm()"
                      class="btn-admin flex-1"
                    >
                      <i class="fa-solid fa-plus mr-2"></i>
                      Nowy produkt
                    </button>
                  </div>
              </form>
            </div>

            <div class="admin-card">
              <h3 class="text-xl font-bold mb-4">Lista Produktów</h3>
                <div id="products-list" class="space-y-4">
                  <!-- Produkty będą ładowane dynamicznie -->
                </div>

                <div id="products-loading" class="text-center py-8 text-zinc-400">
                  <i class="fa-solid fa-spinner fa-spin text-2xl mb-2"></i>
                  <p>Ładowanie produktów...</p>
                </div>

                <div
                  id="products-empty"
                  class="text-center py-8 text-zinc-400 hidden"
                >
                  <i class="fa-solid fa-shopping-cart text-4xl mb-4 text-zinc-600"></i>
                  <p>Brak produktów do wyświetlenia</p>
              </div>
            </div>
          </div>
        </div>

        <!-- Wydarzenia -->
        <div id="tab-events" class="tab-content">
          <h1 class="text-3xl font-bold coyote-text mb-8">
            Zarządzanie Wydarzeniami
          </h1>

            <div class="flex justify-between items-center mb-8">
              <p class="text-zinc-400">
                Zarządzaj wydarzeniami na stronie. Dodawaj nowe wydarzenia z datą
                i godziną, pozycjonuj je i przypinaj ważne.
              </p>
              <button onclick="addNewEvent()" class="btn-admin">
                <i class="fa-solid fa-plus mr-2"></i>
                Dodaj wydarzenie
              </button>
            </div>

            <!-- Filtry wydarzeń -->
            <div class="admin-card mb-8">
              <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
                <div>
                  <label class="block text-sm font-medium mb-2">Status</label>
                  <select id="events-status-filter" class="w-full">
                    <option value="all">Wszystkie</option>
                    <option value="upcoming">Nadchodzące</option>
                    <option value="past">Przeszłe</option>
                    <option value="pinned">Przypięte</option>
                  </select>
                </div>
                <div>
                  <label class="block text-sm font-medium mb-2">Kategoria</label>
                  <select id="events-category-filter" class="w-full">
                    <option value="all">Wszystkie kategorie</option>
                    <option value="training">Szkolenia</option>
                    <option value="meeting">Spotkania</option>
                    <option value="competition">Zawody</option>
                    <option value="other">Inne</option>
                  </select>
                </div>
                <div>
                  <label class="block text-sm font-medium mb-2">Sortowanie</label>
                  <select id="events-sort-filter" class="w-full">
                    <option value="date-asc">Data ↑</option>
                    <option value="date-desc">Data ↓</option>
                    <option value="title">Tytuł</option>
                    <option value="pinned">Przypięte pierwsze</option>
                  </select>
                </div>
                <div class="flex items-end">
                  <button onclick="applyEventsFilters()" class="btn-admin w-full">
                    <i class="fa-solid fa-filter mr-2"></i>
                    Filtruj
                  </button>
                </div>
              </div>
            </div>

            <!-- Lista wydarzeń -->
          <div class="admin-card">
            <div id="events-list" class="space-y-4">
                <!-- Wydarzenia będą ładowane dynamicznie -->
            </div>

              <div id="events-loading" class="text-center py-8 text-zinc-400">
                <i class="fa-solid fa-spinner fa-spin text-2xl mb-2"></i>
                <p>Ładowanie wydarzeń...</p>
              </div>

              <div
                id="events-empty"
                class="text-center py-8 text-zinc-400 hidden"
              >
                <i
                  class="fa-solid fa-calendar-alt text-4xl mb-4 text-zinc-600"
                ></i>
                <p>Brak wydarzeń do wyświetlenia</p>
              </div>
            </div>

            <!-- Statystyki wydarzeń -->
            <div class="admin-card mt-6">
              <h3 class="text-xl font-bold mb-6">Statystyki Wydarzeń</h3>

              <div class="grid grid-cols-1 md:grid-cols-4 gap-6">
                <div class="text-center">
                  <div class="text-2xl font-bold coyote-text" id="total-events">
                    0
                  </div>
                  <div class="text-sm text-zinc-400">Razem wydarzeń</div>
                </div>
                <div class="text-center">
                  <div
                    class="text-2xl font-bold text-green-400"
                    id="upcoming-events"
                  >
                    0
                  </div>
                  <div class="text-sm text-zinc-400">Nadchodzących</div>
                </div>
                <div class="text-center">
                  <div class="text-2xl font-bold text-blue-400" id="past-events">
                    0
                  </div>
                  <div class="text-sm text-zinc-400">Przeszłych</div>
                </div>
                <div class="text-center">
                  <div
                    class="text-2xl font-bold text-yellow-400"
                    id="pinned-events"
                  >
                    0
                  </div>
                  <div class="text-sm text-zinc-400">Przypiętych</div>
                </div>
              </div>
          </div>
        </div>

        <!-- Pomoc Charytatywna -->
        <div id="tab-charity" class="tab-content">
          <h1 class="text-3xl font-bold coyote-text mb-8">
              Zarządzanie Pomocą Charytatywną
          </h1>

            <div class="flex justify-between items-center mb-8">
              <p class="text-zinc-400">
                Zarządzaj akcjami charytatywnymi. Dodawaj zdjęcia, linki,
                przyciski i treści w dowolny sposób.
              </p>
              <button onclick="addNewCharityAction()" class="btn-admin">
                <i class="fa-solid fa-plus mr-2"></i>
                Dodaj akcję
              </button>
            </div>

            <!-- Lista akcji charytatywnych -->
          <div class="admin-card">
              <div id="charity-actions-list" class="space-y-4">
                <!-- Akcje będą ładowane dynamicznie -->
            </div>

              <div id="charity-loading" class="text-center py-8 text-zinc-400">
                <i class="fa-solid fa-spinner fa-spin text-2xl mb-2"></i>
                <p>Ładowanie akcji...</p>
              </div>

              <div
                id="charity-empty"
                class="text-center py-8 text-zinc-400 hidden"
              >
                <i class="fa-solid fa-heart text-4xl mb-4 text-zinc-600"></i>
                <p>Brak akcji charytatywnych</p>
          </div>
        </div>

            <!-- Statystyki pomocy -->
            <div class="admin-card mt-6">
              <h3 class="text-xl font-bold mb-6">Statystyki Pomocy</h3>

              <div class="grid grid-cols-1 md:grid-cols-4 gap-6">
                <div class="text-center">
                  <div
                    class="text-2xl font-bold coyote-text"
                    id="total-charity-actions"
                  >
                    0
                  </div>
                  <div class="text-sm text-zinc-400">Razem akcji</div>
                </div>
                <div class="text-center">
                  <div
                    class="text-2xl font-bold text-green-400"
                    id="active-charity-actions"
                  >
                    0
                  </div>
                  <div class="text-sm text-zinc-400">Aktywnych</div>
                </div>
                <div class="text-center">
                  <div
                    class="text-2xl font-bold text-blue-400"
                    id="total-donations"
                  >
                    0
                  </div>
                  <div class="text-sm text-zinc-400">Zebranych środków</div>
                </div>
                <div class="text-center">
                  <div
                    class="text-2xl font-bold text-yellow-400"
                    id="charity-views"
                  >
                    0
                  </div>
                  <div class="text-sm text-zinc-400">Wyświetleń</div>
                </div>
              </div>
            </div>
          </div>

          <!-- Newsletter -->
          <div id="tab-newsletter" class="tab-content">
          <h1 class="text-3xl font-bold coyote-text mb-8">
              Zarządzanie Newsletter'em
          </h1>

            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
              <!-- Edytor newsletter'a -->
          <div class="admin-card">
                <h3 class="text-xl font-bold mb-6">Edytor Newsletter'a</h3>

                <div class="space-y-4">
                  <div>
                    <label class="block text-sm font-medium mb-2"
                      >Temat wiadomości</label
                    >
                    <input
                      type="text"
                      id="newsletter-subject"
                      placeholder="Wprowadź temat newsletter'a..."
                      class="w-full"
                    />
                  </div>

                  <div>
                    <label class="block text-sm font-medium mb-2"
                      >Treść wiadomości</label
                    >
                    <div class="toolbar mb-2">
                      <button onclick="formatText('bold')" title="Pogrubienie">
                        <i class="fa-solid fa-bold"></i>
                      </button>
                      <button onclick="formatText('italic')" title="Kursywa">
                        <i class="fa-solid fa-italic"></i>
                      </button>
                      <button onclick="formatText('underline')" title="Podkreślenie">
                        <i class="fa-solid fa-underline"></i>
                      </button>
                      <button onclick="insertLink()" title="Wstaw link">
                        <i class="fa-solid fa-link"></i>
                      </button>
                      <button onclick="insertImage()" title="Wstaw obraz">
                        <i class="fa-solid fa-image"></i>
                      </button>
                    </div>
                    <div
                      id="newsletter-editor"
                      class="editor-content min-h-[300px]"
                      contenteditable="true"
                      placeholder="Wpisz treść newsletter'a..."
                    ></div>
                  </div>

                  <div class="flex space-x-4">
                    <button
                      onclick="previewNewsletter()"
                      class="btn-admin flex-1"
                    >
                      <i class="fa-solid fa-eye mr-2"></i>
                      Podgląd
                    </button>
                    <button
                      onclick="saveNewsletterDraft()"
                      class="btn-admin flex-1"
                    >
                      <i class="fa-solid fa-save mr-2"></i>
                      Zapisz wersję roboczą
                    </button>
                    <button
                      onclick="loadNewsletterDraft()"
                      class="btn-admin flex-1"
                      title="Załaduj zapisaną wersję roboczą"
                    >
                      <i class="fa-solid fa-folder-open mr-2"></i>
                      Załaduj wersję roboczą
                    </button>
                    <button
                      onclick="sendNewsletter()"
                      class="btn-admin flex-1"
                    >
                      <i class="fa-solid fa-paper-plane mr-2"></i>
                      Wyślij Newsletter
                    </button>
                  </div>
                </div>
              </div>

              <!-- Lista subskrybentów -->
              <div class="admin-card">
                <h3 class="text-xl font-bold mb-6">Subskrybenci Newsletter'a</h3>

                <div class="mb-4">
                  <input
                    type="text"
                    id="newsletter-search"
                    placeholder="Szukaj subskrybentów..."
                    class="w-full mb-4"
                  />
                </div>

                <div
                  id="newsletter-subscribers"
                  class="space-y-3 max-h-[400px] overflow-y-auto"
                >
                  <!-- Lista subskrybentów będzie ładowana dynamicznie -->
                </div>

                <div class="mt-6 pt-4 border-t border-zinc-700">
                  <div
                    class="flex justify-between items-center text-sm text-zinc-400 mb-4"
                  >
                    <span>Łącznie subskrybentów:</span>
                    <span id="subscribers-count">0</span>
                  </div>
                  <button onclick="exportNewsletter()" class="btn-admin w-full">
                    <i class="fa-solid fa-download mr-2"></i>
                    Eksportuj listę subskrybentów
                  </button>
                </div>
              </div>
            </div>
          </div>

          <!-- Bazar -->
          <div id="tab-bazar" class="tab-content">
            <h1 class="text-3xl font-bold coyote-text mb-8">
              Zarządzanie Bazarem
            </h1>

            <div class="flex justify-between items-center mb-8">
              <p class="text-zinc-400">
                Zarządzaj ofertami na bazarze. Zatwierdzaj nowe oferty i moderuj
                istniejące.
              </p>
              <button onclick="refreshBazar()" class="text-zinc-400 hover:text-coyote transition-colors p-2" id="refresh-bazar-btn">
                <i class="fa-solid fa-sync-alt text-lg" id="refresh-bazar-icon"></i>
              </button>
            </div>

            <!-- Filtry i wyszukiwanie -->
            <div class="admin-card mb-8">
              <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
                <div>
                  <label class="block text-sm font-medium mb-2"
                    >Status oferty</label
                  >
                  <select id="bazar-status-filter" class="w-full">
                  <option value="all">Wszystkie</option>
                  <option value="pending">Oczekujące</option>
                  <option value="approved">Zatwierdzone</option>
                  <option value="rejected">Odrzucone</option>
                </select>
                </div>
                <div>
                  <label class="block text-sm font-medium mb-2">Kategoria</label>
                  <select id="bazar-category-filter" class="w-full">
                    <option value="all">Wszystkie kategorie</option>
                    <option value="elektronika">Elektronika</option>
                    <option value="odziez">Odzież</option>
                    <option value="motoryzacja">Motoryzacja</option>
                    <option value="dom">Dom i ogród</option>
                    <option value="inne">Inne</option>
                  </select>
                </div>
                <div>
                  <label class="block text-sm font-medium mb-2">Szukaj</label>
                  <input
                    type="text"
                    id="bazar-search"
                    placeholder="Tytuł oferty..."
                    class="w-full"
                  />
                </div>
                <div class="flex items-end">
                  <button onclick="applyBazarFilters()" class="btn-admin w-full">
                    <i class="fa-solid fa-filter mr-2"></i>
                    Filtruj
                  </button>
                </div>
              </div>
            </div>

            <!-- Lista ofert -->
            <div class="admin-card">
              <div id="bazar-offers-list" class="space-y-4">
                <!-- Oferty będą ładowane dynamicznie -->
            </div>

              <div id="bazar-loading" class="text-center py-8 text-zinc-400">
              <i class="fa-solid fa-spinner fa-spin text-2xl mb-2"></i>
                <p>Ładowanie ofert...</p>
              </div>

              <div id="bazar-empty" class="text-center py-8 text-zinc-400 hidden">
                <i class="fa-solid fa-store text-4xl mb-4 text-zinc-600"></i>
                <p>Brak ofert do wyświetlenia</p>
              </div>
            </div>
          </div>

          <!-- Szkolenia -->
          <div id="tab-szkolenia" class="tab-content">
            <div class="flex justify-between items-center mb-8">
              <h1 class="text-3xl font-bold coyote-text">
                Zarządzanie Szkoleniami
              </h1>
              <button onclick="refreshTrainings()" class="text-zinc-400 hover:text-coyote transition-colors p-2" id="refresh-trainings-btn">
                <i class="fa-solid fa-sync-alt text-lg" id="refresh-trainings-icon"></i>
              </button>
            </div>

            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
              <div class="admin-card">
                <h3 class="text-xl font-bold mb-4">Dodaj/Edytuj Szkolenie</h3>
                <form id="training-form" class="space-y-4">
                  <input type="hidden" id="training-id" />
                  <input
                    type="text"
                    id="training-title"
                    placeholder="Nazwa szkolenia"
                    required
                  />
                  <input
                    type="text"
                    id="training-price"
                    placeholder="Cena (np. 299.99)"
                    required
                  />
                  <input
                    type="text"
                    id="training-img"
                    placeholder="URL zdjęcia"
                    required
                  />
                  
                  <div class="flex items-center gap-4">
                    <label class="flex items-center gap-2 cursor-pointer">
                      <input
                        type="checkbox"
                        id="training-available-all"
                        class="w-4 h-4"
                      />
                      <span class="text-sm">Dostępne dla wszystkich</span>
                    </label>
                  </div>

                  <div class="toolbar">
                    <button type="button" onclick="formatText('bold')">
                      <i class="fa-solid fa-bold"></i>
                    </button>
                    <button
                      type="button"
                      onclick="formatText('insertUnorderedList')"
                    >
                      <i class="fa-solid fa-list-ul"></i>
                    </button>
                    <button type="button" onclick="formatText('justifyCenter')">
                      <i class="fa-solid fa-align-center"></i>
                    </button>
                    <button type="button" onclick="insertImage()">
                      <i class="fa-solid fa-image"></i>
                    </button>
                  </div>

                  <div
                    id="training-description"
                    class="editor-content"
                    contenteditable="true"
                    placeholder="Opis szkolenia..."
                  ></div>

                  <div class="flex space-x-4">
                    <button type="submit" class="btn-admin flex-1">
                      <i class="fa-solid fa-save mr-2"></i>
                      Zapisz szkolenie
                    </button>
                    <button
                      type="button"
                      onclick="clearTrainingForm()"
                      class="btn-admin flex-1"
                    >
                      <i class="fa-solid fa-plus mr-2"></i>
                      Nowe szkolenie
                    </button>
                  </div>
                </form>

                <!-- Zarządzanie dostępem użytkowników -->
                <div id="training-access-section" class="mt-8 pt-8 border-t border-zinc-700 hidden">
                  <h4 class="text-lg font-bold mb-4">Zarządzanie dostępem</h4>
                  <div class="space-y-4">
                    <div>
                      <label class="block text-sm font-medium mb-2">Dodaj dostęp dla użytkownika</label>
                      <div class="flex gap-2">
                        <select id="training-user-select" class="flex-1">
                          <option value="">Wybierz użytkownika...</option>
                        </select>
                        <button
                          type="button"
                          onclick="addTrainingAccess()"
                          class="btn-admin"
                        >
                          <i class="fa-solid fa-plus mr-2"></i>
                          Dodaj
                        </button>
                      </div>
                    </div>
                    <div>
                      <label class="block text-sm font-medium mb-2">Użytkownicy z dostępem</label>
                      <div id="training-access-list" class="space-y-2">
                        <!-- Lista użytkowników z dostępem -->
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              <div class="admin-card">
                <h3 class="text-xl font-bold mb-4">Lista Szkoleń</h3>
                <div id="trainings-list" class="space-y-4">
                  <!-- Szkolenia będą ładowane dynamicznie -->
                </div>

                <div id="trainings-loading" class="text-center py-8 text-zinc-400">
                  <i class="fa-solid fa-spinner fa-spin text-2xl mb-2"></i>
                  <p>Ładowanie szkoleń...</p>
                </div>

                <div
                  id="trainings-empty"
                  class="text-center py-8 text-zinc-400 hidden"
                >
                  <i
                    class="fa-solid fa-graduation-cap text-4xl mb-4 text-zinc-600"
                  ></i>
                  <p>Brak szkoleń do wyświetlenia</p>
                </div>
              </div>
            </div>
          </div>
        </div>

          <!-- Blog -->
          <div id="tab-blog" class="tab-content">
          <h1 class="text-3xl font-bold coyote-text mb-8">
              Zarządzanie Blogiem
            </h1>

            <div class="flex justify-between items-center mb-8">
              <p class="text-zinc-400">
                Zarządzaj wpisami na blogu. Dodawaj nowe artykuły, moderuj
                komentarze i pozycjonuj treści.
              </p>
              <button onclick="addNewBlogPost()" class="btn-admin">
                <i class="fa-solid fa-plus mr-2"></i>
                Dodaj wpis
              </button>
            </div>

            <!-- Filtry -->
            <div class="admin-card mb-8">
              <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                <div>
                  <label class="block text-sm font-medium mb-2">Status</label>
                  <select id="blog-status-filter" class="w-full">
                    <option value="all">Wszystkie</option>
                    <option value="published">Opublikowane</option>
                    <option value="draft">Szkice</option>
                    <option value="archived">Zarchiwizowane</option>
                  </select>
                </div>
                <div>
                  <label class="block text-sm font-medium mb-2">Kategoria</label>
                  <select id="blog-category-filter" class="w-full">
                    <option value="all">Wszystkie kategorie</option>
                    <option value="news">Aktualności</option>
                    <option value="tips">Porady</option>
                    <option value="tutorials">Poradniki</option>
                    <option value="reviews">Recenzje</option>
                  </select>
                </div>
                <div class="flex items-end">
                  <button onclick="applyBlogFilters()" class="btn-admin w-full">
                    <i class="fa-solid fa-filter mr-2"></i>
                    Filtruj
                  </button>
                </div>
              </div>
            </div>

            <!-- Lista wpisów -->
            <div class="admin-card">
              <div id="blog-posts-list" class="space-y-4">
                <!-- Wpisy będą ładowane dynamicznie -->
              </div>

              <div id="blog-loading" class="text-center py-8 text-zinc-400">
                <i class="fa-solid fa-spinner fa-spin text-2xl mb-2"></i>
                <p>Ładowanie wpisów...</p>
              </div>

              <div id="blog-empty" class="text-center py-8 text-zinc-400 hidden">
                <i class="fa-solid fa-blog text-4xl mb-4 text-zinc-600"></i>
                <p>Brak wpisów do wyświetlenia</p>
              </div>
            </div>
          </div>

          <!-- Dokumenty -->
          <div id="tab-dokumenty" class="tab-content">
            <h1 class="text-3xl font-bold coyote-text mb-8">
              Zarządzanie Dokumentami
            </h1>

            <div class="flex justify-between items-center mb-8">
              <p class="text-zinc-400">
                Zarządzaj dokumentami PDF. Dodawaj nowe pliki, organizuj kategorie
                i kontroluj dostępność.
              </p>
              <button onclick="addNewDocument()" class="btn-admin">
                <i class="fa-solid fa-plus mr-2"></i>
                Dodaj dokument
              </button>
            </div>

            <!-- Lista dokumentów -->
            <div class="admin-card">
              <div id="documents-list" class="space-y-4">
                <!-- Dokumenty będą ładowane dynamicznie -->
              </div>

              <div id="documents-loading" class="text-center py-8 text-zinc-400">
                <i class="fa-solid fa-spinner fa-spin text-2xl mb-2"></i>
                <p>Ładowanie dokumentów...</p>
              </div>

              <div
                id="documents-empty"
                class="text-center py-8 text-zinc-400 hidden"
              >
                <i class="fa-solid fa-file-pdf text-4xl mb-4 text-zinc-600"></i>
                <p>Brak dokumentów do wyświetlenia</p>
              </div>
            </div>
          </div>

          <!-- Kontakt -->
          <div id="tab-kontakt" class="tab-content">
            <h1 class="text-3xl font-bold coyote-text mb-8">
              Zarządzanie Formularzem Kontaktowym
          </h1>

          <div class="grid grid-cols-1 gap-8">
              <!-- Ustawienia formularza -->
            <div class="admin-card">
                <h3 class="text-xl font-bold mb-6">Ustawienia Formularza</h3>

                <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                  <div>
                    <label class="flex items-center space-x-3 cursor-pointer">
                <input
                        type="checkbox"
                        id="contact-form-enabled"
                        checked
                        class="w-4 h-4"
                      />
                      <span class="text-sm font-medium">Formularz włączony</span>
                    </label>
                    <p class="text-xs text-zinc-500 mt-1">
                      Wyłącz, aby ukryć formularz kontaktowy na stronie
                    </p>
                  </div>

                  <div>
                    <label class="block text-sm font-medium mb-2"
                      >Email odbiorcy</label
                    >
                    <input
                      type="email"
                      id="contact-recipient-email"
                      placeholder="admin@strzelca.pl"
                      class="w-full"
                    />
                  </div>

                  <div>
                    <label class="block text-sm font-medium mb-2"
                      >Temat powiadomień</label
                    >
                <input
                  type="text"
                      id="contact-notification-subject"
                      placeholder="Nowa wiadomość z formularza kontaktowego"
                      class="w-full"
                    />
                  </div>
                </div>
            </div>

              <!-- Zarządzanie kategoriami i tematami -->
            <div class="admin-card" style="background: linear-gradient(135deg, rgba(193, 154, 107, 0.1), rgba(193, 154, 107, 0.05)); backdrop-filter: blur(20px); border: 1px solid rgba(193, 154, 107, 0.2);">
                <div class="flex justify-between items-center mb-6">
                    <h3 class="text-xl font-bold coyote-text">Zarządzanie Kategoriami i Tematami</h3>
                    <button onclick="openCategoryModal()" class="btn-admin px-4 py-2">
                        <i class="fa-solid fa-plus mr-2"></i>
                        Dodaj kategorię
                    </button>
                </div>

                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4" id="categories-list">
                    <!-- Kategorie będą ładowane dynamicznie -->
                    <div class="text-center text-zinc-500 py-8 col-span-full">
                        <i class="fa-solid fa-spinner fa-spin text-2xl mb-4 text-zinc-600"></i>
                        <h4 class="text-lg font-semibold mb-2">Ładowanie kategorii...</h4>
                        <p class="text-sm">Proszę czekać</p>
                    </div>
                </div>
            </div>
          </div>
        </div>

          </div>
        </div>
      </div>

    <!-- Modal wszystkich logów aktywności -->
    <div
      id="all-activity-logs-modal"
      class="fixed inset-0 z-50 hidden flex items-center justify-center p-4 bg-black/95 backdrop-blur-xl"
      onclick="if(event.target.id === 'all-activity-logs-modal') closeAllActivityLogsModal()"
      style="overflow-y: auto;"
    >
      <div class="admin-card max-w-6xl w-full my-8 max-h-[90vh] overflow-y-auto" onclick="event.stopPropagation()">
        <div class="flex justify-between items-center mb-6">
          <h2 class="text-2xl font-bold coyote-text">Wszystkie logi aktywności</h2>
          <button
            onclick="closeAllActivityLogsModal()"
            class="text-zinc-400 hover:text-white transition-colors p-2"
          >
            <i class="fa-solid fa-times text-xl"></i>
          </button>
        </div>

        <!-- Filtry -->
        <div class="bg-zinc-800/50 rounded-lg p-4 mb-6 border border-zinc-700">
          <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
            <div>
              <label class="text-xs text-zinc-400 block mb-2 uppercase tracking-wider">Typ akcji</label>
              <select id="activity-filter-action" class="w-full" onchange="filterActivityLogs()">
                <option value="all">Wszystkie</option>
                <option value="ADMIN_LOGIN_SUCCESS">Logowanie admina</option>
                <option value="ADMIN_LOGIN_FAILED">Nieudane logowanie</option>
                <option value="USER_CREATED">Utworzenie użytkownika</option>
                <option value="USER_DELETED">Usunięcie użytkownika</option>
                <option value="MESSAGE_SENT">Wysłanie wiadomości</option>
                <option value="PRODUCT_CREATED">Utworzenie produktu</option>
                <option value="REVIEW_CREATED">Utworzenie opinii</option>
                <option value="USER_BLOCKED">Zablokowanie użytkownika</option>
                <option value="USER_UNBLOCKED">Odblokowanie użytkownika</option>
              </select>
            </div>
            <div>
              <label class="text-xs text-zinc-400 block mb-2 uppercase tracking-wider">Data od</label>
              <input type="date" id="activity-filter-date-from" class="w-full" onchange="filterActivityLogs()" />
            </div>
            <div>
              <label class="text-xs text-zinc-400 block mb-2 uppercase tracking-wider">Data do</label>
              <input type="date" id="activity-filter-date-to" class="w-full" onchange="filterActivityLogs()" />
            </div>
          </div>
          <div class="mt-4 flex justify-between items-center">
            <div class="text-sm text-zinc-400">
              Znaleziono: <span id="activity-logs-count" class="text-white font-semibold">0</span> logów
            </div>
            <button onclick="resetActivityFilters()" class="text-zinc-400 hover:text-coyote transition text-sm">
              <i class="fa-solid fa-rotate-left mr-1"></i>
              Resetuj filtry
            </button>
          </div>
        </div>

        <!-- Lista logów -->
        <div id="all-activity-logs-container" class="space-y-4">
          <div class="text-center text-zinc-500 py-8">
            <i class="fa-solid fa-spinner fa-spin text-2xl mb-4 text-zinc-600"></i>
            <h4 class="text-lg font-semibold mb-2">Ładowanie logów...</h4>
          </div>
          </div>
        </div>
      </div>

    <div
      id="user-details-modal"
      class="fixed inset-0 z-50 hidden flex items-center justify-center p-4 bg-black/95 backdrop-blur-xl"
      onclick="if(event.target.id === 'user-details-modal') closeUserDetails()"
      style="overflow-y: auto;"
    >
      <div class="admin-card max-w-4xl w-full my-8 max-h-[90vh] overflow-y-auto" onclick="event.stopPropagation()">
        <div class="flex justify-between items-center mb-6">
          <h2 class="text-2xl font-bold coyote-text">Szczegóły Użytkownika</h2>
          <div class="flex space-x-2">
            <button
              onclick="editUserDetails()"
              class="btn-admin text-sm px-3 py-1"
            >
              <i class="fa-solid fa-edit mr-1"></i>
              Edytuj
            </button>
            <button
              onclick="openChatFromUserDetails()"
              class="btn-admin text-sm px-3 py-1"
            >
              <i class="fa-solid fa-comments mr-1"></i>
              PRZEJDŹ DO CZATU
            </button>
          <button
            onclick="closeUserDetails()"
            class="text-zinc-400 hover:text-white"
          >
            <i class="fa-solid fa-times text-xl"></i>
          </button>
        </div>
        </div>

        <!-- Tabs -->
        <div class="mb-6">
          <div class="flex space-x-1 bg-zinc-800 p-1 rounded-lg">
            <button
              onclick="switchUserTab('details')"
              class="user-tab-btn active px-4 py-2 text-sm rounded"
              data-tab="details"
            >
              Szczegóły
            </button>
            <button
              onclick="switchUserTab('activity')"
              class="user-tab-btn px-4 py-2 text-sm rounded"
              data-tab="activity"
            >
              Aktywność
            </button>
          </div>
        </div>

        <div id="user-details-content">
          <!-- Szczegóły użytkownika będą ładowane dynamicznie -->
        </div>
      </div>
    </div>

    <!-- Modal edycji użytkownika -->
    <div
      id="user-edit-modal"
      class="fixed inset-0 z-50 hidden flex items-center justify-center p-4 bg-black/95 backdrop-blur-xl"
    >
      <div class="admin-card max-w-4xl w-full max-h-[90vh] overflow-y-auto">
        <div class="flex justify-between items-center mb-6">
          <h2 class="text-2xl font-bold coyote-text">Edycja Użytkownika</h2>
          <button
            onclick="closeUserEdit()"
            class="text-zinc-400 hover:text-white"
          >
            <i class="fa-solid fa-times text-xl"></i>
          </button>
        </div>

        <form id="user-edit-form" class="space-y-8">
          <input type="hidden" id="edit-user-id" />
          
          <!-- Dane podstawowe -->
          <div class="space-y-6">
            <h3 class="text-xl font-bold coyote-text pb-2 border-b border-zinc-700">Dane podstawowe</h3>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div class="space-y-4">
                <div>
                  <label class="text-sm text-zinc-400 block mb-2"
                    >Nazwa wyświetlana</label
                  >
                  <input
                    type="text"
                    id="edit-display-name"
                    placeholder="Nazwa wyświetlana"
                    required
                  />
                </div>
                <div>
                  <label class="text-sm text-zinc-400 block mb-2">Email</label>
                  <input
                    type="email"
                    id="edit-email"
                    placeholder="Email"
                    required
                    disabled
                  />
                </div>
                <div>
                  <label class="text-sm text-zinc-400 block mb-2">Imię</label>
                  <input type="text" id="edit-first-name" placeholder="Imię" />
                </div>
              </div>

              <div class="space-y-4">
                <div>
                  <label class="text-sm text-zinc-400 block mb-2"
                    >Nazwisko</label
                  >
                  <input
                    type="text"
                    id="edit-last-name"
                    placeholder="Nazwisko"
                  />
                </div>
                <div>
                  <label class="text-sm text-zinc-400 block mb-2"
                    >Telefon</label
                  >
                  <input type="tel" id="edit-phone" placeholder="Telefon" />
                </div>
              </div>
            </div>
          </div>

          <!-- Adres dostawy -->
          <div class="space-y-6 pt-6 border-t border-zinc-700">
            <h3 class="text-xl font-bold coyote-text pb-2 border-b border-zinc-700">Adres dostawy</h3>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div class="space-y-4">
                <div>
                  <label class="text-sm text-zinc-400 block mb-2">Ulica</label>
                  <input type="text" id="edit-street" placeholder="Ulica" />
                </div>
                <div>
                  <label class="text-sm text-zinc-400 block mb-2"
                    >Numer budynku</label
                  >
                  <input
                    type="text"
                    id="edit-building-number"
                    placeholder="Numer budynku"
                  />
                </div>
                <div>
                  <label class="text-sm text-zinc-400 block mb-2"
                    >Kod pocztowy</label
                  >
                  <input
                    type="text"
                    id="edit-postal-code"
                    placeholder="Kod pocztowy"
                  />
                </div>
              </div>

              <div class="space-y-4">
                <div>
                  <label class="text-sm text-zinc-400 block mb-2">Miasto</label>
                  <input type="text" id="edit-city" placeholder="Miasto" />
                </div>
                <div>
                  <label class="text-sm text-zinc-400 block mb-2"
                    >Paczkomat</label
                  >
                  <input
                    type="text"
                    id="edit-parcel-locker"
                    placeholder="Paczkomat"
                  />
                </div>
              </div>
            </div>
          </div>

          <!-- Preferencje i status -->
          <div class="space-y-6 pt-6 border-t border-zinc-700">
            <h3 class="text-xl font-bold coyote-text pb-2 border-b border-zinc-700">Preferencje i status</h3>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div class="space-y-4">
                <h4 class="text-base font-semibold text-zinc-300 mb-3">Preferencje</h4>
                <div class="flex items-center space-x-3 p-4 bg-zinc-800/50 rounded-lg">
                  <input type="checkbox" id="edit-newsletter" class="w-5 h-5" />
                  <label for="edit-newsletter" class="text-sm cursor-pointer"
                    >Newsletter</label
                  >
                </div>
              </div>

              <div class="space-y-4">
                <h4 class="text-base font-semibold text-zinc-300 mb-3">Status konta</h4>
                <div class="space-y-4">
                  <div>
                    <label class="text-sm text-zinc-400 block mb-2">Rola</label>
                    <select id="edit-role" class="w-full">
                      <option value="user">Użytkownik</option>
                      <option value="company">Firma</option>
                      <option value="admin">Administrator</option>
                    </select>
                  </div>
                  <div>
                    <label class="text-sm text-zinc-400 block mb-2">Status</label>
                    <select id="edit-status" class="w-full">
                      <option value="active">Aktywny</option>
                      <option value="blocked">Zablokowany</option>
                      <option value="suspended">Zawieszony</option>
                    </select>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <!-- Przyciski -->
          <div class="flex justify-end space-x-4 pt-6 border-t border-zinc-700">
            <button
              type="button"
              onclick="closeUserEdit()"
              class="px-6 py-2 border border-zinc-600 rounded-lg hover:bg-zinc-700 transition"
            >
              Anuluj
            </button>
            <button type="submit" class="btn-admin">
              <i class="fa-solid fa-save mr-2"></i>
              Zapisz zmiany
            </button>
          </div>
        </form>
      </div>
    </div>

    <!-- Modal blokowania użytkownika -->
    <div
      id="user-block-modal"
      class="fixed inset-0 z-50 hidden flex items-center justify-center p-2 sm:p-3 md:p-4 bg-black/95 backdrop-blur-xl overflow-y-auto"
      onclick="if(event.target.id === 'user-block-modal') closeUserBlock()"
    >
      <div class="admin-card max-w-2xl w-full my-4 sm:my-6 md:my-8 max-h-[95vh] overflow-y-auto" onclick="event.stopPropagation()">
        <div class="flex justify-between items-center mb-4 sm:mb-6">
          <h2 class="text-lg sm:text-xl md:text-2xl font-bold text-red-400">
            Blokowanie Użytkownika
          </h2>
          <button
            onclick="closeUserBlock()"
            class="text-zinc-400 hover:text-white p-1 sm:p-2"
          >
            <i class="fa-solid fa-times text-lg sm:text-xl"></i>
          </button>
        </div>

        <div id="block-user-info" class="mb-4 sm:mb-6 p-3 sm:p-4 bg-zinc-800/80 rounded-lg border border-zinc-700">
          <!-- Informacje o użytkowniku będą ładowane dynamicznie -->
        </div>

        <form id="user-block-form" class="space-y-4 sm:space-y-6">
          <input type="hidden" id="block-user-id" />

          <div class="bg-zinc-800/50 rounded-lg p-3 sm:p-4 border border-zinc-700">
            <label class="text-xs sm:text-sm font-semibold text-zinc-300 block mb-2 sm:mb-3">
              <i class="fa-solid fa-clock mr-2 text-coyote"></i>
              Czas blokady
            </label>
            <select id="block-duration" class="w-full text-sm sm:text-base p-2 sm:p-3" required>
              <option value="15min">15 minut</option>
              <option value="1hour">1 godzina</option>
              <option value="6hours">6 godzin</option>
              <option value="24hours">24 godziny</option>
              <option value="7days">7 dni</option>
              <option value="30days">30 dni</option>
              <option value="permanent">Na zawsze (blokada permanentna)</option>
            </select>
          </div>

          <div class="bg-zinc-800/50 rounded-lg p-3 sm:p-4 border border-zinc-700">
            <label class="text-sm sm:text-base font-bold text-red-400 block mb-2 sm:mb-3">
              <i class="fa-solid fa-exclamation-triangle mr-2 text-red-500"></i>
              Powód blokady <span class="text-red-500">*</span>
            </label>
            <p class="text-xs text-zinc-400 mb-2">
              Ten powód zostanie wyświetlony użytkownikowi, aby wiedział za co został zablokowany.
            </p>
            <textarea
              id="block-reason"
              class="w-full bg-zinc-900 text-white border-2 border-red-700/50 rounded-lg p-3 sm:p-4 text-sm sm:text-base focus:outline-none focus:border-red-500 focus:ring-2 focus:ring-red-500/20 transition-all resize-y"
              rows="4"
              placeholder="Wprowadź szczegółowy powód blokady użytkownika. Ten komunikat zobaczy użytkownik..."
              required
              minlength="10"
            ></textarea>
            <p class="text-xs text-zinc-500 mt-2">
              Minimum 10 znaków. Powód jest wymagany i będzie widoczny dla użytkownika.
            </p>
          </div>

          <div class="p-3 sm:p-4 bg-red-900/20 border border-red-700 rounded-lg">
            <h4 class="text-sm sm:text-base text-red-400 font-bold mb-2 flex items-center">
              <i class="fa-solid fa-triangle-exclamation mr-2"></i>
              Ostrzeżenie
            </h4>
            <p class="text-xs sm:text-sm text-zinc-300 leading-relaxed">
              Blokada konta oznacza całkowite "uśmiercenie" konta - brak
              możliwości korzystania ze strony, pisania na czatach, odczytywania
              czatów, dodawania/edycji produktów na bazarze itp. Bez możliwości
              odblokowania przez email.
            </p>
          </div>

          <div class="flex flex-col sm:flex-row justify-end gap-2 sm:gap-4 pt-4 sm:pt-6 border-t border-zinc-700">
            <button
              type="button"
              onclick="closeUserBlock()"
              class="w-full sm:w-auto px-4 sm:px-6 py-2 sm:py-2 text-sm sm:text-base border border-zinc-600 rounded-lg hover:bg-zinc-700 transition"
            >
              Anuluj
            </button>
            <button type="submit" class="w-full sm:w-auto btn-admin bg-red-600 hover:bg-red-500 text-sm sm:text-base px-4 sm:px-6 py-2">
              <i class="fa-solid fa-ban mr-2"></i>
              <span class="hidden sm:inline">Zablokuj użytkownika</span>
              <span class="sm:hidden">Zablokuj</span>
            </button>
          </div>
        </form>
      </div>
    </div>

    <!-- Modal usuwania użytkownika -->
    <div
      id="user-delete-modal"
      class="fixed inset-0 z-50 hidden flex items-center justify-center p-4 bg-black/95 backdrop-blur-xl"
      onclick="if(event.target.id === 'user-delete-modal') closeUserDelete()"
      style="overflow-y: auto;"
    >
      <div class="admin-card max-w-2xl w-full my-8 max-h-[90vh] overflow-y-auto" onclick="event.stopPropagation()">
        <div class="flex justify-between items-center mb-6">
          <h2 class="text-2xl font-bold text-red-400">Usuwanie Użytkownika</h2>
          <button
            onclick="closeUserDelete()"
            class="text-zinc-400 hover:text-white"
          >
            <i class="fa-solid fa-times text-xl"></i>
          </button>
        </div>

        <div id="delete-user-info" class="mb-6 p-4 bg-zinc-800/80 rounded-lg border border-zinc-700">
          <!-- Informacje o użytkowniku będą ładowane dynamicznie -->
        </div>

        <form id="user-delete-form" class="space-y-6">
          <input type="hidden" id="delete-user-id" />

          <div>
            <label class="text-sm font-semibold text-zinc-300 block mb-4"
              >Opcje zawartości konta</label
            >
            <div class="space-y-3">
              <div class="flex items-start space-x-3 p-3 bg-zinc-800/50 rounded-lg border border-zinc-700 hover:border-zinc-600 transition">
                <input
                  type="radio"
                  id="delete-keep-content"
                  name="delete-content-action"
                  value="keep"
                  checked
                  class="mt-1"
                />
                <label for="delete-keep-content" class="text-sm text-zinc-200 flex-1 cursor-pointer"
                  >Zachowaj zawartość konta (produkty, czaty, komentarze)</label
                >
              </div>
              <div class="flex items-start space-x-3 p-3 bg-zinc-800/50 rounded-lg border border-zinc-700 hover:border-zinc-600 transition">
                <input
                  type="radio"
                  id="delete-remove-content"
                  name="delete-content-action"
                  value="remove"
                  class="mt-1"
                />
                <label for="delete-remove-content" class="text-sm text-zinc-200 flex-1 cursor-pointer"
                  >Całkowicie usuń zawartość konta</label
                >
              </div>
            </div>
          </div>

          <div class="p-4 bg-red-900/20 border border-red-700 rounded-lg">
            <h4 class="text-red-400 font-bold mb-2">⚠️ Ostrzeżenie</h4>
            <p class="text-sm text-zinc-300 mb-2">
              Usunięcie konta jest operacją nieodwracalną. Użytkownik zostanie
              całkowicie usunięty z systemu.
            </p>
            <p class="text-sm text-zinc-300">
              Jeśli wybierzesz "Zachowaj zawartość", produkty, wiadomości i inne
              dane użytkownika pozostaną w systemie, ale będą oznaczone jako "od
              usuniętego użytkownika".
            </p>
          </div>

          <div
            class="flex items-start space-x-3 p-4 bg-yellow-900/20 border border-yellow-700 rounded-lg"
          >
            <input type="checkbox" id="delete-confirm" required class="mt-1" />
            <label for="delete-confirm" class="text-sm text-zinc-200 flex-1 cursor-pointer">
              Potwierdzam, że chcę całkowicie usunąć tego użytkownika z systemu
            </label>
          </div>

          <div class="flex justify-end space-x-4 pt-6 border-t border-zinc-700">
            <button
              type="button"
              onclick="closeUserDelete()"
              class="px-6 py-2 border border-zinc-600 rounded-lg hover:bg-zinc-700 transition"
            >
              Anuluj
            </button>
            <button type="submit" class="btn-admin bg-red-600 hover:bg-red-500">
              <i class="fa-solid fa-trash mr-2"></i>
              Usuń użytkownika
            </button>
          </div>
        </form>
      </div>
    </div>

    <!-- Modal szybkich odpowiedzi -->
    <div
      id="quick-reply-modal"
      class="fixed inset-0 z-50 hidden flex items-center justify-center p-4 bg-black/95 backdrop-blur-xl"
    >
      <div class="admin-card max-w-2xl w-full">
        <div class="flex justify-between items-center mb-6">
          <h2 id="quick-reply-modal-title" class="text-2xl font-bold coyote-text">Nowy szablon odpowiedzi</h2>
          <button
            onclick="closeQuickReplyModal()"
            class="text-zinc-400 hover:text-white"
          >
            <i class="fa-solid fa-times text-xl"></i>
          </button>
        </div>

        <form id="quick-reply-form" class="space-y-6">
          <input type="hidden" id="quick-reply-id" />

          <div>
            <label class="block text-sm font-medium mb-2">Tytuł szablonu *</label>
            <input
              type="text"
              id="quick-reply-title"
              placeholder="np. Przywitanie, Pytanie o szczegóły..."
              class="w-full"
              required
            />
          </div>

          <div>
            <label class="block text-sm font-medium mb-2">Treść odpowiedzi *</label>
            <textarea
              id="quick-reply-content"
              placeholder="Wpisz treść odpowiedzi..."
              class="w-full"
              rows="6"
              required
            ></textarea>
            <p class="text-xs text-zinc-500 mt-1">
              Ta treść zostanie użyta jako szablon odpowiedzi w zakładce Wiadomości
            </p>
          </div>

          <div class="flex justify-end space-x-4 pt-6 border-t border-zinc-700">
            <button
              type="button"
              onclick="closeQuickReplyModal()"
              class="px-6 py-2 border border-zinc-600 rounded-lg hover:bg-zinc-700 transition"
            >
              Anuluj
            </button>
            <button type="submit" class="btn-admin">
              <i class="fa-solid fa-save mr-2"></i>
              <span id="quick-reply-submit-text">Zapisz szablon</span>
            </button>
          </div>
        </form>
      </div>
    </div>

    <!-- Dropdown szybkich odpowiedzi -->
    <div
      id="quick-replies-dropdown"
      class="fixed z-[99999] hidden bg-zinc-800 border border-zinc-600 rounded-lg shadow-lg max-w-sm max-h-80 overflow-y-auto"
    >
      <div class="p-2">
        <div class="text-xs text-zinc-400 px-2 py-1 border-b border-zinc-700 mb-2">
          Szybkie odpowiedzi
        </div>
        <div id="quick-replies-dropdown-list" class="space-y-1">
          <!-- Szablony będą ładowane dynamicznie -->
          <div class="text-center text-zinc-500 py-4">
            <i class="fa-solid fa-spinner fa-spin text-sm mb-2"></i>
            <div class="text-xs">Ładowanie...</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Modal zarządzania kategoriami -->
    <div
      id="category-modal"
      class="fixed inset-0 z-50 hidden flex items-center justify-center p-4 bg-black/95 backdrop-blur-xl"
    >
      <div class="admin-card max-w-lg w-full">
        <div class="flex justify-between items-center mb-6">
          <h2 id="category-modal-title" class="text-2xl font-bold coyote-text">Nowa kategoria</h2>
          <button
            onclick="closeCategoryModal()"
            class="text-zinc-400 hover:text-white"
          >
            <i class="fa-solid fa-times text-xl"></i>
          </button>
        </div>

        <form id="category-form" class="space-y-6">
          <input type="hidden" id="category-id" />

          <div>
            <label class="block text-sm font-medium mb-2">Nazwa kategorii *</label>
            <input
              type="text"
              id="category-name"
              placeholder="np. Zamówienia, Oferty, Inne..."
              class="w-full"
              required
            />
          </div>

          <div>
            <label class="block text-sm font-medium mb-2">Kolor</label>
            <div class="flex space-x-2">
              <input
                type="color"
                id="category-color"
                value="#3B82F6"
                class="w-16 h-10 rounded border border-zinc-600"
              />
              <input
                type="text"
                id="category-color-text"
                placeholder="#3B82F6"
                class="flex-1"
                readonly
              />
            </div>
          </div>

          <div>
            <label class="block text-sm font-medium mb-2">Ikona (FontAwesome)</label>
            <div class="grid grid-cols-8 gap-2" id="icon-picker">
              <button type="button" class="icon-option p-2 border border-zinc-600 rounded hover:border-coyote transition" data-icon="fa-shopping-cart">
                <i class="fa-solid fa-shopping-cart"></i>
              </button>
              <button type="button" class="icon-option p-2 border border-zinc-600 rounded hover:border-coyote transition" data-icon="fa-tag">
                <i class="fa-solid fa-tag"></i>
              </button>
              <button type="button" class="icon-option p-2 border border-zinc-600 rounded hover:border-coyote transition" data-icon="fa-circle">
                <i class="fa-solid fa-circle"></i>
              </button>
              <button type="button" class="icon-option p-2 border border-zinc-600 rounded hover:border-coyote transition" data-icon="fa-question">
                <i class="fa-solid fa-question"></i>
              </button>
              <button type="button" class="icon-option p-2 border border-zinc-600 rounded hover:border-coyote transition" data-icon="fa-info">
                <i class="fa-solid fa-info"></i>
              </button>
              <button type="button" class="icon-option p-2 border border-zinc-600 rounded hover:border-coyote transition" data-icon="fa-envelope">
                <i class="fa-solid fa-envelope"></i>
              </button>
              <button type="button" class="icon-option p-2 border border-zinc-600 rounded hover:border-coyote transition" data-icon="fa-phone">
                <i class="fa-solid fa-phone"></i>
              </button>
              <button type="button" class="icon-option p-2 border border-zinc-600 rounded hover:border-coyote transition" data-icon="fa-cog">
                <i class="fa-solid fa-cog"></i>
              </button>
            </div>
            <input type="hidden" id="category-icon" value="fa-circle" />
          </div>

          <div class="flex justify-end space-x-4 pt-6 border-t border-zinc-700">
            <button
              type="button"
              onclick="closeCategoryModal()"
              class="px-6 py-2 border border-zinc-600 rounded-lg hover:bg-zinc-700 transition"
            >
              Anuluj
            </button>
            <button type="submit" class="btn-admin">
              <i class="fa-solid fa-save mr-2"></i>
              Zapisz kategorię
            </button>
          </div>
        </form>
      </div>
    </div>

    <!-- Modal podglądu newslettera -->
    <div
      id="newsletter-preview-modal"
      class="fixed inset-0 z-50 hidden flex items-center justify-center p-4 bg-black/95 backdrop-blur-xl"
      onclick="if(event.target.id === 'newsletter-preview-modal') closeNewsletterPreview()"
      style="overflow-y: auto;"
    >
      <div class="admin-card max-w-4xl w-full my-8 max-h-[90vh] overflow-y-auto" onclick="event.stopPropagation()">
        <div class="flex justify-between items-center mb-6">
          <h2 class="text-2xl font-bold coyote-text">Podgląd Newslettera</h2>
          <button
            onclick="closeNewsletterPreview()"
            class="text-zinc-400 hover:text-white"
          >
            <i class="fa-solid fa-times text-xl"></i>
          </button>
        </div>

        <div class="space-y-4">
          <div>
            <label class="block text-sm font-medium mb-2 text-zinc-400">Temat:</label>
            <div id="preview-subject" class="text-xl font-bold text-white p-3 bg-zinc-800/50 rounded-lg border border-zinc-700">
              <!-- Temat będzie wyświetlony tutaj -->
            </div>
          </div>

          <div>
            <label class="block text-sm font-medium mb-2 text-zinc-400">Treść:</label>
            <div id="preview-content" class="text-white p-4 bg-zinc-800/50 rounded-lg border border-zinc-700 min-h-[300px]">
              <!-- Treść będzie wyświetlona tutaj -->
            </div>
          </div>
        </div>

        <div class="flex justify-end space-x-4 pt-6 mt-6 border-t border-zinc-700">
          <button
            onclick="closeNewsletterPreview()"
            class="px-6 py-2 border border-zinc-600 rounded-lg hover:bg-zinc-700 transition"
          >
            Zamknij
          </button>
        </div>
      </div>
    </div>

    <!-- Error handler dla Firestore CORS - MUSI być przed importami Firebase -->
    <script>
      // Wycisz hałaśliwe błędy CORS z Firestore Listen/channel (nie blokują działania, SDK ma fallbacki)
      (function() {
        // Przechwyć window.onerror PRZED załadowaniem Firebase
        const originalError = window.onerror;
        window.onerror = function(message, source, lineno, colno, error) {
          // Ignoruj błędy CORS z Firestore Listen/channel i Write/channel
          if (typeof message === 'string' && message.includes('firestore.googleapis.com') && 
              (message.includes('Listen/channel') || message.includes('Write/channel'))) {
            return true; // Wycisz błąd
          }
          // Dla innych błędów użyj oryginalnego handlera
          if (originalError) {
            return originalError(message, source, lineno, colno, error);
          }
          return false;
        };

        // Przechwyć XMLHttpRequest PRZED załadowaniem Firebase
        const originalXHROpen = XMLHttpRequest.prototype.open;
        XMLHttpRequest.prototype.open = function(method, url, ...args) {
          this._url = url;
          return originalXHROpen.apply(this, [method, url, ...args]);
        };
        const originalXHRSend = XMLHttpRequest.prototype.send;
        XMLHttpRequest.prototype.send = function(...args) {
          if (this._url && this._url.includes('firestore.googleapis.com') && 
              (this._url.includes('Listen/channel') || this._url.includes('Write/channel'))) {
            // Wycisz błędy dla tego konkretnego endpointu
            this.addEventListener('error', function(e) {
              e.stopPropagation();
            }, true);
          }
          return originalXHRSend.apply(this, args);
        };

        // Przechwyć console.error PRZED załadowaniem Firebase
        const originalConsoleError = console.error;
        console.error = function(...args) {
          const errorMessage = args.join(' ');
          // Ignoruj błędy CORS z Firestore Listen/channel i Write/channel
          if (errorMessage.includes('firestore.googleapis.com') && 
              (errorMessage.includes('Listen/channel') || errorMessage.includes('Write/channel') || errorMessage.includes('access control checks'))) {
            return; // Wycisz błąd
          }
          // Dla innych błędów użyj oryginalnego console.error
          return originalConsoleError.apply(console, args);
        };
      })();
    </script>

    <script type="module">
      import {
        signInWithEmailAndPassword,
        signOut,
        onAuthStateChanged,
      } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
      import {
        doc,
        getDoc,
        getDocs,
        collection,
        query,
        orderBy,
        updateDoc,
        deleteDoc,
        setDoc,
        where,
        limit,
        addDoc,
        writeBatch,
        serverTimestamp,
        Timestamp,
      } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
      import { initAuth } from "https://strzelca.pl/auth-init.mjs?v=2026-02-06-3";

      
      async function getFirebaseApiKey() {
        // Użyj pełnej ścieżki z domeną, aby uniknąć problemów z CORS i ścieżkami
        const urls = [
          "https://strzelca.pl/api/firebase-config",
          "/api/firebase-config" // fallback dla lokalnego developmentu
        ];

        for (const url of urls) {
          try {
            console.log(`[Firebase Config] Próba pobrania z: ${url}`);
            const res = await fetch(url, { 
              cache: "no-store",
              credentials: "include" // Włącz cookies dla CORS
            });
            
            if (!res.ok) {
              console.warn(`[Firebase Config] Błąd HTTP ${res.status} dla ${url}`);
              const errorText = await res.text().catch(() => "");
              console.warn(`[Firebase Config] Treść błędu:`, errorText);
              continue;
            }
            
            const data = await res.json().catch((e) => {
              console.error(`[Firebase Config] Błąd parsowania JSON z ${url}:`, e);
              return null;
            });
            
            if (data && typeof data.apiKey === "string" && data.apiKey.length > 10) {
              console.log(`[Firebase Config] Pobrano API key z ${url} (długość: ${data.apiKey.length})`);
              return data.apiKey;
            } else {
              console.warn(`[Firebase Config] Nieprawidłowe dane z ${url}:`, data);
            }
          } catch (error) {
            console.error(`[Firebase Config] Błąd podczas pobierania z ${url}:`, error);
            // continue to next url
          }
        }

        throw new Error("Nie udało się pobrać FIREBASE_WEB_API_KEY z /api/firebase-config. Sprawdź konsole przeglądarki dla szczegółów.");
      }
      
      // OPTYMALIZACJA: Użyj wspólnego modułu inicjalizacji
      let firebaseConfig;
      let auth, db;
      
      try {
        const apiKey = await getFirebaseApiKey();
        
        if (!apiKey || apiKey.length < 10) {
          throw new Error("Nieprawidłowy API key Firebase");
        }
        
        firebaseConfig = {
          apiKey: apiKey,
          authDomain: "strzelca-pl.firebaseapp.com",
          projectId: "strzelca-pl",
          storageBucket: "strzelca-pl.appspot.com",
          messagingSenderId: "511362047688",
          appId: "1:511362047688:web:9b82c0a4d19c1a3a878ffd",
          measurementId: "G-9EJ2R3JPVD",
        };
        
        console.log("[Firebase] Inicjalizacja Firebase z konfiguracją:", {
          apiKey: apiKey.substring(0, 10) + "...",
          authDomain: firebaseConfig.authDomain,
          projectId: firebaseConfig.projectId
        });

        const initResult = await initAuth(firebaseConfig, {
          logAuthReady: true,
          logSSO: true,
          firestore: {
            // Wymuś long polling zamiast WebSocket, aby uniknąć problemów z CORS
            experimentalForceLongPolling: true,
            experimentalAutoDetectLongPolling: false,
            useFetchStreams: false,
          },
        });
        
        auth = initResult.auth;
        db = initResult.db;
        
        console.log("[Firebase] Firebase zainicjalizowany pomyślnie");
        console.log("[Firebase] Firestore database:", db);
        console.log("[Firebase] Auth:", auth);
        console.log("[Firebase] Current user:", auth.currentUser?.uid || "brak");
        
        // Sprawdź, czy Firestore działa - test połączenia
        try {
          const testDoc = doc(db, "_test", "connection");
          await getDoc(testDoc);
          console.log("[Firebase] Test połączenia z Firestore: OK");
        } catch (testError) {
          console.warn("[Firebase] Test połączenia z Firestore nie powiódł się:", testError);
          console.warn("[Firebase] Szczegóły błędu testu:", {
            code: testError.code,
            message: testError.message,
            name: testError.name
          });
          
          // Jeśli to błąd CORS, pokaż ostrzeżenie
          if (testError.message?.includes('CORS') || testError.message?.includes('access control')) {
            console.error("[Firebase] ⚠️ BŁĄD CORS Z FIRESTORE!");
            console.error("[Firebase] To może blokować dostęp do panelu admina.");
            console.error("[Firebase] Sprawdź konfigurację domeny w Firebase Console.");
          }
        }
      } catch (error) {
        console.error("[Firebase] BŁĄD INICJALIZACJI FIREBASE:", error);
        console.error("[Firebase] Szczegóły błędu:", {
          message: error.message,
          stack: error.stack,
          config: firebaseConfig ? {
            apiKey: firebaseConfig.apiKey ? firebaseConfig.apiKey.substring(0, 10) + "..." : "brak",
            authDomain: firebaseConfig.authDomain,
            projectId: firebaseConfig.projectId
          } : "brak konfiguracji"
        });
        
        // Wyświetl błąd użytkownikowi
        const errorDiv = document.createElement("div");
        errorDiv.style.cssText = "position: fixed; top: 0; left: 0; right: 0; background: #dc2626; color: white; padding: 20px; z-index: 10000; text-align: center;";
        errorDiv.innerHTML = `
          <h2 style="margin: 0 0 10px 0;">❌ Błąd inicjalizacji Firebase</h2>
          <p style="margin: 0;">${error.message}</p>
          <p style="margin: 10px 0 0 0; font-size: 12px;">Sprawdź konsolę przeglądarki (F12) dla szczegółów.</p>
        `;
        document.body.appendChild(errorDiv);
        
        throw error; // Rzuć błąd dalej, aby zatrzymać wykonanie
      }

      let currentUser = null;
      let currentTab = "dashboard";
      let currentUserFilter = "all";
      let usersList = [];
      let productsList = [];
      let trainingsList = [];
      let currentTrainingId = null;
      let currentConversationId = null;
      let pendingTasksListener = null;
      let activityLogsListener = null;
      let userFilterColors = {}; // Kolory filtrów zdefiniowane przez użytkownika
      let activityLogsLimit = 20; // Limit logów do wyświetlenia
      let loadedActivityLogs = []; // Załadowane logi

      // Dźwięk powiadomienia dla nowych wiadomości
      const notificationSound = new Audio('/message.mp3');
      let lastUnreadCount = null;

      // ===== SYSTEM ŚLEDZENIA AKTYWNOŚCI ONLINE =====
      let activityTrackingInterval = null;
      let lastActivitySync = 0;

      // Funkcja aktualizacji lastSeen w Firestore
      async function updateLastSeen() {
        if (!currentUser) return;
        
        try {
          await updateDoc(doc(db, "userProfiles", currentUser.uid), {
            lastSeen: serverTimestamp()
          });
          
          // Zaktualizuj localStorage
          const activityData = {
            lastSeen: Date.now(),
            synced: true
          };
          localStorage.setItem('userActivity', JSON.stringify(activityData));
          lastActivitySync = Date.now();
        } catch (error) {
          console.warn("Could not update lastSeen:", error);
          // Zapisuj lokalnie nawet jeśli Firestore nie działa
          const activityData = {
            lastSeen: Date.now(),
            synced: false
          };
          localStorage.setItem('userActivity', JSON.stringify(activityData));
        }
      }

      // Funkcja śledzenia aktywności lokalnie
      function trackLocalActivity() {
        const activityData = {
          lastSeen: Date.now(),
          synced: false
        };
        localStorage.setItem('userActivity', JSON.stringify(activityData));
      }

      // Funkcja synchronizacji aktywności (co 15 minut)
      async function syncActivity() {
        if (!currentUser) return;
        
        // Pobierz dane z localStorage
        const storedActivity = localStorage.getItem('userActivity');
        if (!storedActivity) {
          trackLocalActivity();
          return;
        }
        
        try {
          const activityData = JSON.parse(storedActivity);
          const timeSinceLastSeen = Date.now() - activityData.lastSeen;
          
          // Synchronizuj tylko jeśli użytkownik był aktywny w ostatnich 30 sekundach
          // lub jeśli nie synchronizowaliśmy od dłuższego czasu
          const timeSinceLastSync = Date.now() - lastActivitySync;
          
          if (timeSinceLastSeen < 30000 || timeSinceLastSync > 900000) { // 30 sekund lub 15 minut
            await updateLastSeen();
          }
        } catch (error) {
          console.warn("Error syncing activity:", error);
        }
      }

      // Rozpocznij śledzenie aktywności
      function startActivityTracking() {
        if (activityTrackingInterval) {
          clearInterval(activityTrackingInterval);
        }
        
        // Aktualizuj od razu przy starcie
        updateLastSeen();
        
        // Synchronizuj co 15 minut (900000 ms)
        activityTrackingInterval = setInterval(() => {
          syncActivity();
        }, 900000);
        
        // Śledź aktywność przy interakcjach użytkownika
        const events = ['mousedown', 'keydown', 'scroll', 'touchstart', 'click'];
        events.forEach(event => {
          document.addEventListener(event, () => {
            trackLocalActivity();
          }, { passive: true });
        });
      }

      // Zatrzymaj śledzenie aktywności
      function stopActivityTracking() {
        if (activityTrackingInterval) {
          clearInterval(activityTrackingInterval);
          activityTrackingInterval = null;
        }
      }
      // ===== KONIEC SYSTEMU ŚLEDZENIA AKTYWNOŚCI =====

      // Funkcja sprawdzająca i wyświetlająca panel dla zalogowanego użytkownika
      async function checkAndShowAdminPanel(user) {
        if (!user) {
          return false;
        }

        // Najpierw sprawdź czy to SuperAdmin (bez sprawdzania Firestore)
        const superAdminUID = 'nCMUz2fc8MM9WhhMVBLZ1pdR7O43';
        if (user.uid === superAdminUID) {
          console.log('SuperAdmin login detected:', user.uid);
          currentUser = user;
          userFilterColors = {}; // SuperAdmin może nie mieć filtrów
          updateAdminDisplay(user);
          document.getElementById("login-section").classList.add("hidden");
          document.getElementById("admin-panel").classList.remove("hidden");
          
          // Rozpocznij śledzenie aktywności
          startActivityTracking();
          
          switchTab("dashboard");
          // Załaduj stats dla SuperAdmin'a
          setTimeout(() => loadDashboardStats(), 100);
          return true;
        }

        // Dla zwykłych użytkowników sprawdź rolę w Firestore
        try {
          console.log('=== [ADMIN CHECK] Starting admin role check ===');
          console.log('[ADMIN CHECK] User UID:', user.uid);
          console.log('[ADMIN CHECK] User email:', user.email);
          console.log('[ADMIN CHECK] Firestore db available:', !!db);
          
          // Sprawdź, czy db jest dostępny
          if (!db) {
            console.error('[ADMIN CHECK] ❌ Firestore database (db) is not available');
            console.error('[ADMIN CHECK] This means Firebase was not initialized correctly');
            throw new Error('Firestore database not initialized');
          }
          
          console.log('[ADMIN CHECK] Attempting to fetch user profile from Firestore...');
          const userDocRef = doc(db, "userProfiles", user.uid);
          console.log('[ADMIN CHECK] Document reference:', userDocRef.path);
          
          const userDoc = await getDoc(userDocRef).catch((error) => {
            console.error("[ADMIN CHECK] ❌ Error fetching user profile from Firestore:", error);
            console.error("[ADMIN CHECK] Error code:", error.code);
            console.error("[ADMIN CHECK] Error message:", error.message);
            console.error("[ADMIN CHECK] Error name:", error.name);
            console.error("[ADMIN CHECK] Full error object:", error);
            
            // Jeśli to błąd CORS lub permission-denied, może to być problem z konfiguracją
            if (error.code === 'permission-denied') {
              console.error('[ADMIN CHECK] ❌ PERMISSION DENIED - Check Firestore Security Rules');
              console.error('[ADMIN CHECK] User may not have read access to userProfiles collection');
            } else if (error.message?.includes('CORS') || error.message?.includes('access control')) {
              console.error('[ADMIN CHECK] ❌ CORS ERROR - Check Firebase Console domain settings');
              console.error('[ADMIN CHECK] Domain may not be added to authorized domains');
            } else if (error.code === 'unavailable' || error.message?.includes('network')) {
              console.error('[ADMIN CHECK] ❌ NETWORK ERROR - Firestore may be unavailable');
            }
            
            throw error;
          });
          
          console.log('[ADMIN CHECK] Document fetch completed');
          console.log('[ADMIN CHECK] Document exists:', userDoc.exists());
          
          if (userDoc.exists()) {
            const userData = userDoc.data();
            console.log('[ADMIN CHECK] ✅ User profile found in Firestore');
            console.log('[ADMIN CHECK] User data:', userData);
            console.log('[ADMIN CHECK] User role:', userData.role);
            console.log('[ADMIN CHECK] Expected role: admin');

            if (userData.role === "admin") {
              console.log('[ADMIN CHECK] ✅ Admin role confirmed for user:', user.uid);
              currentUser = user;

              // Załaduj kolory filtrów z bazy danych użytkownika
              if (userData.filterColors) {
                userFilterColors = userData.filterColors;
              }

              updateAdminDisplay(user);

              document.getElementById("login-section").classList.add("hidden");
              document.getElementById("admin-panel").classList.remove("hidden");

              // Rozpocznij śledzenie aktywności
              startActivityTracking();

              // Załaduj dashboard i stats dopiero po zakończeniu ładowania profilu
              switchTab("dashboard");
              // Opóźnij ładowanie stats, żeby dać czas na zakończenie ładowania profilu
              setTimeout(() => loadDashboardStats(), 100);
              return true;
            } else {
              console.warn('[ADMIN CHECK] ❌ User has role:', userData.role, 'but expected admin');
              console.warn('[ADMIN CHECK] Access denied - user is not an admin');
            }
          } else {
            console.warn('[ADMIN CHECK] ❌ User profile not found in Firestore for UID:', user.uid);
            console.warn('[ADMIN CHECK] Profile may not exist or user may not have read permissions');
          }
          
          console.log('=== [ADMIN CHECK] Check completed - returning false ===');
        } catch (error) {
          console.error("Error checking admin role in Firestore:", error);
          console.error("Error details:", {
            code: error.code,
            message: error.message,
            name: error.name,
            stack: error.stack
          });
          
          // Jeśli to błąd CORS lub problem z dostępem do Firestore, 
          // BLOKUJ dostęp - bezpieczeństwo jest priorytetem
          // Tylko SuperAdmin (hardcoded UID) może mieć dostęp bez sprawdzania Firestore
          if (error.code === 'permission-denied' || 
              error.code === 'unavailable' ||
              error.message?.includes('CORS') || 
              error.message?.includes('access control') ||
              error.message?.includes('Failed to fetch') ||
              error.message?.includes('network') ||
              error.name === 'FirebaseError') {
            console.error('❌ KRYTYCZNY BŁĄD: Nie można zweryfikować uprawnień administratora z powodu problemów z dostępem do Firestore');
            console.error('❌ Dostęp ZABLOKOWANY ze względów bezpieczeństwa');
            console.error('❌ Napraw konfigurację Firebase (CORS, domeny, Security Rules)');
            
            // Pokaż komunikat o błędzie i zablokuj dostęp
            const errorDiv = document.createElement("div");
            errorDiv.id = "firestore-error";
            errorDiv.style.cssText = "position: fixed; top: 0; left: 0; right: 0; background: #dc2626; color: white; padding: 20px; z-index: 10000; text-align: center; box-shadow: 0 2px 10px rgba(0,0,0,0.3);";
            errorDiv.innerHTML = `
              <strong>🚫 BŁĄD DOSTĘPU DO FIRESTORE</strong><br>
              Nie można zweryfikować uprawnień administratora. Dostęp został zablokowany ze względów bezpieczeństwa.<br>
              <small>Sprawdź konfigurację Firebase (CORS, domeny, Security Rules) i konsolę przeglądarki (F12) dla szczegółów.</small>
            `;
            document.body.appendChild(errorDiv);
          }
        }

        return false;
      }



      // Funkcja sprawdzania roli administratora
      async function checkAdminRole(user) {
        try {
          // Sprawdź czy UID użytkownika odpowiada superAdmin UID
          const superAdminUID = 'nCMUz2fc8MM9WhhMVBLZ1pdR7O43';
          if (user.uid === superAdminUID) {
            console.log('SuperAdmin UID match:', user.uid);
            currentUser = user;
            return true;
          }

          // Sprawdź rolę w Firestore
          console.log('Checking Firestore for user profile:', user.uid);
          const userDoc = await getDoc(doc(db, "userProfiles", user.uid));
          if (userDoc.exists()) {
            const userData = userDoc.data();
            console.log('User profile found, role:', userData.role);
            if (userData.role === "admin") {
              currentUser = user;
              return true;
            } else {
              console.warn('User does not have admin role. Current role:', userData.role);
            }
          } else {
            console.warn('User profile not found in Firestore for UID:', user.uid);
          }
          
          return false;
        } catch (error) {
          console.error("Error checking admin role:", error);
          console.error("Error details:", {
            code: error.code,
            message: error.message,
            stack: error.stack
          });
          
          // Jeśli to błąd CORS lub problem z dostępem do Firestore,
          // ZABLOKUJ dostęp - bezpieczeństwo jest priorytetem
          // Tylko SuperAdmin (hardcoded UID) może mieć dostęp bez sprawdzania Firestore
          if (error.code === 'permission-denied' || 
              error.code === 'unavailable' ||
              error.message?.includes('CORS') || 
              error.message?.includes('access control') ||
              error.message?.includes('Failed to fetch') ||
              error.message?.includes('network') ||
              error.name === 'FirebaseError') {
            console.error('❌ KRYTYCZNY BŁĄD: Nie można zweryfikować roli administratora');
            console.error('❌ Dostęp ZABLOKOWANY ze względów bezpieczeństwa');
            console.error('❌ Napraw konfigurację Firebase (CORS, domeny, Security Rules)');
            return false; // Zablokuj dostęp - bezpieczeństwo przede wszystkim
          }
          
          return false;
        }
      }

      function redirectNotAuthorized() {
        try {
          const url = new URL("https://konto.strzelca.pl/profil.html");
          url.searchParams.set("notice", "admin_only");
          window.location.href = url.toString();
        } catch {
          window.location.href = "https://konto.strzelca.pl/profil.html?notice=admin_only";
        }
      }

      // Funkcja logowania aktywności
      async function logActivity(
        userId,
        action,
        details = {},
        targetUserId = null,
      ) {
        try {
          const activityData = {
            userId: userId,
            action: action,
            details: details,
            targetUserId: targetUserId,
            timestamp: new Date(),
            adminId: currentUser ? currentUser.uid : null,
            ipAddress: null, // Można dodać jeśli dostępny
            userAgent: navigator.userAgent,
          };

          await addDoc(collection(db, "activityLogs"), activityData);
        } catch (error) {
          // Dla błędów permission-denied, zapis do userActivity wymaga specyficznych reguł Firestore
          if (error.code === 'permission-denied') {
            console.warn("Permission denied when logging activity to Firestore - check Firestore security rules");
            // Nie przerywamy wykonania innych skryptów
          } else {
            console.error("Error logging activity:", error);
          }
          // Nie pokazujemy błędu użytkownikowi, żeby nie przeszkadzać w normalnej pracy
        }
      }


      // Funkcja sprawdzająca czy użytkownik jest online (ostatnie 30 minut)
      function isUserOnline(user) {
        if (!user || !user.lastSeen) return false;
        
        try {
          const lastSeen = user.lastSeen.toDate ? user.lastSeen.toDate() : new Date(user.lastSeen);
          const now = new Date();
          const diffMinutes = (now - lastSeen) / 1000 / 60;
          
          // Użytkownik jest online jeśli był aktywny w ciągu ostatnich 30 minut
          return diffMinutes < 30;
        } catch (error) {
          return false;
        }
      }

      // Funkcja formatująca czas ostatniej aktywności
      function getLastSeenText(user) {
        if (!user || !user.lastSeen) return "Nigdy";
        
        try {
          const lastSeen = user.lastSeen.toDate ? user.lastSeen.toDate() : new Date(user.lastSeen);
          const now = new Date();
          const diffMinutes = Math.floor((now - lastSeen) / 1000 / 60);
          
          if (diffMinutes < 1) return "Teraz";
          if (diffMinutes < 60) return `${diffMinutes} min temu`;
          const diffHours = Math.floor(diffMinutes / 60);
          if (diffHours < 24) return `${diffHours} godz. temu`;
          const diffDays = Math.floor(diffHours / 24);
          return `${diffDays} dni temu`;
        } catch (error) {
          return "Nieznany";
        }
      }

      // Funkcja formatująca czas pozostały do odblokowania
      function getBlockedUntilText(user) {
        if (!user || user.status !== "blocked") return null;
        
        try {
          if (!user.blockedUntil) {
            return "Blokada permanentna";
          }
          
          const blockedUntil = user.blockedUntil.toDate ? user.blockedUntil.toDate() : new Date(user.blockedUntil);
          const now = new Date();
          
          // Jeśli blokada wygasła
          if (blockedUntil <= now) {
            // Funkcja getBlockedUntilText jest synchroniczna, więc nie możemy tu odblokować
            // Odblokowanie nastąpi automatycznie przy następnym loadUsers()
            return "Blokada wygasła - zostanie automatycznie odblokowana";
          }
          
          // Oblicz pozostały czas
          const diffMs = blockedUntil - now;
          const diffMinutes = Math.floor(diffMs / 1000 / 60);
          const diffHours = Math.floor(diffMinutes / 60);
          const diffDays = Math.floor(diffHours / 24);
          
          if (diffDays > 0) {
            const remainingHours = diffHours % 24;
            if (remainingHours > 0) {
              return `Odblokowanie za ${diffDays} ${diffDays === 1 ? 'dzień' : diffDays < 5 ? 'dni' : 'dni'} i ${remainingHours} ${remainingHours === 1 ? 'godzinę' : remainingHours < 5 ? 'godziny' : 'godzin'}`;
            }
            return `Odblokowanie za ${diffDays} ${diffDays === 1 ? 'dzień' : diffDays < 5 ? 'dni' : 'dni'}`;
          } else if (diffHours > 0) {
            const remainingMinutes = diffMinutes % 60;
            if (remainingMinutes > 0) {
              return `Odblokowanie za ${diffHours} ${diffHours === 1 ? 'godzinę' : diffHours < 5 ? 'godziny' : 'godzin'} i ${remainingMinutes} ${remainingMinutes === 1 ? 'minutę' : remainingMinutes < 5 ? 'minuty' : 'minut'}`;
            }
            return `Odblokowanie za ${diffHours} ${diffHours === 1 ? 'godzinę' : diffHours < 5 ? 'godziny' : 'godzin'}`;
          } else {
            return `Odblokowanie za ${diffMinutes} ${diffMinutes === 1 ? 'minutę' : diffMinutes < 5 ? 'minuty' : 'minut'}`;
          }
        } catch (error) {
          return "Błąd obliczania czasu";
        }
      }

      // Funkcje pomocnicze
      function showStatus(message, isError = false) {
        const statusEl = document.getElementById("login-status");
        statusEl.innerHTML = message;
        statusEl.className = `mt-6 p-4 rounded-lg text-center text-sm ${isError ? "bg-red-900/50 text-red-300 border border-red-700" : "bg-green-900/50 text-green-300 border border-green-700"}`;
        if (isError) {
          statusEl.style.color = "#dc2626"; // Specific red color for errors
          statusEl.style.fontWeight = "bold"; // Make error messages bold
        } else {
          statusEl.style.color = ""; // Reset to default
          statusEl.style.fontWeight = ""; // Reset font weight
        }
        statusEl.style.display = "block";

        setTimeout(() => {
          statusEl.style.display = "none";
        }, 5000);
      }

      function showNotification(message, type = "success") {
        // Prosta implementacja powiadomień - można rozszerzyć
        console.log(`${type}: ${message}`);
      }


      // Aktualizacja wyświetlania nazwy administratora
      function updateAdminDisplay(user) {
        // Aktualizuj kompaktowy widok (to jest jedyny element dostępny w obecnym layout)
        updateCompactAdminDisplay(user);
      }

      // Nawigacja między zakładkami
      function switchTab(tabName) {
        window.scrollTo(0,0);
        document.getElementById("main-content").scrollTop = 0;

        const mainContent = document.getElementById("main-content");
        if (mainContent) mainContent.scrollTo({top: 0, behavior: "instant"});

        document.querySelectorAll(".nav-item").forEach((item) => {
          item.classList.remove("active");
        });
        document.querySelectorAll(".nav-submenu-item").forEach((item) => {
          item.classList.remove("active");
        });

        // Sprawdź czy to zakładka z submenu
        const mainTab = document.querySelector(`[data-tab="${tabName}"]`);
        const submenuItem = document.querySelector(`.nav-submenu-item[data-tab="${tabName}"]`);

        if (submenuItem) {
          submenuItem.classList.add("active");
          // Oznacz główną zakładkę "Strony" jako aktywną jeśli otwieramy podstronę
          document.querySelector(".nav-pages-toggle").classList.add("active");
        } else if (mainTab) {
          mainTab.classList.add("active");
        }

        document.querySelectorAll(".tab-content").forEach((content) => {
          content.classList.remove("active");
        });
        document.getElementById(`tab-${tabName}`).classList.add("active");

        // Dodatkowe akcje dla konkretnych zakładek
        if (tabName === "status") {
          loadEventsLog();
        }

        // Specjalna obsługa dashboard - załaduj dziennik aktywności z opóźnieniem
        if (tabName === "dashboard") {
          setTimeout(() => {
            const activityContainer = document.getElementById('admin-activity-log');
            if (activityContainer) {
              console.log('Dashboard tab switched, loading activity logs...');
              loadDashboardActivityLogs(true);
            } else {
              console.warn('admin-activity-log container still not found after tab switch');
            }
          }, 300);
        }


        // Specjalna obsługa newsletter - dodaj event listener dla wyszukiwania
        if (tabName === "newsletter") {
          setTimeout(() => {
            const newsletterSearch = document.getElementById('newsletter-search');
            
            if (newsletterSearch && !newsletterSearch.hasSearchListener) {
              newsletterSearch.hasSearchListener = true;
              
              newsletterSearch.addEventListener('input', () => {
                loadNewsletterSubscribers();
              });
              
              newsletterSearch.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                  e.preventDefault();
                  loadNewsletterSubscribers();
                }
              });
            }
          }, 100);
        }

        currentTab = tabName;

        // Ładowanie danych dla wybranej zakładki
        switch (tabName) {
          case "status":
            checkMainServicesStatus();
            break;
          case "dashboard":
            // Opóźnij ładowanie dashboard żeby dać czas na renderowanie DOM
            setTimeout(() => loadDashboardStats(), 500);
            break;
          case "users":
            loadUsers();
            break;
          case "products":
            loadProducts();
            break;
          case "events":
            loadEvents();
            break;
          case "reviews":
            loadReviews();
            break;
          case "charity":
            loadCharity();
            break;
          case "bazar":
            // Brak specjalnej funkcji ładowania dla tej zakładki
            break;
          case "szkolenia":
            loadTrainings();
            break;
          case "blog":
            // Brak specjalnej funkcji ładowania dla tej zakładki
            break;
          case "dokumenty":
            // Brak specjalnej funkcji ładowania dla tej zakładki
            break;
          case "kontakt":
            loadQuickReplies();
            loadCategories();
            break;
          case "settings":
            loadSettings();
            break;
          case "newsletter":
            loadNewsletterSubscribers();
            // Załaduj zapisaną wersję roboczą jeśli istnieje (bez powiadomienia)
            setTimeout(() => {
              loadNewsletterDraft(false);
            }, 200);
            break;
        }

        // Zatrzymaj automatyczne odświeżanie wiadomości jeśli nie jesteśmy w zakładce messages
        if (tabName !== "messages") {
          stopAutoRefresh();
        }

        document.getElementById("main-content").scrollTop = 0;
      }


      // Funkcja do przełączania sidebar na mobile
      function toggleSidebar() {
        const sidebar = document.getElementById("mobile-sidebar");
        const overlay = document.getElementById("mobile-overlay");

        if (sidebar && overlay) {
          if (sidebar.classList.contains("open")) {
            sidebar.classList.remove("open");
            overlay.classList.add("hidden");
          } else {
            sidebar.classList.add("open");
            overlay.classList.remove("hidden");
          }
        }
      }

      // Funkcja do aktualizacji kompaktowego wyświetlania nazwy admina
      function updateCompactAdminDisplay(user) {
        const compactName = document.getElementById("admin-display-name-compact");

        if (compactName && user) {
          const displayName = user.displayName || user.email || "Administrator";
          compactName.textContent = displayName;
        }
      }




      // Inicjalizacja nawigacji
      document.querySelectorAll(".nav-item").forEach((item) => {
        item.addEventListener("click", () => {
          const tab = item.getAttribute("data-tab");
          switchTab(tab);
        });
      });

      // Logowanie administratora
      const legacyAdminLoginForm = document.getElementById("admin-login-form");
      legacyAdminLoginForm?.addEventListener?.("submit", async (e) => {
          e.preventDefault();

          const login = document.getElementById("admin-email").value.trim();
          const password = document.getElementById("admin-password").value;

          if (!login || !password) {
            showStatus("Wprowadź login i hasło administratora.", true);
            return;
          }

          // Walidacja formatu email
          const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
          if (!emailRegex.test(login)) {
            showStatus("Wprowadź prawidłowy adres email.", true);
            return;
          }

          try {
            const userCredential = await signInWithEmailAndPassword(
              auth,
              login,
              password,
            );
            const user = userCredential.user;

            // Sprawdź czy użytkownik ma rolę administratora
            console.log('Checking admin role for user:', user.uid, user.email);
            const isAdmin = await checkAdminRole(user);
            if (!isAdmin) {
              console.warn('User does not have admin role, signing out');
              // Nie wylogowujemy globalnie użytkownika — po prostu blokujemy panel admina
              try { await signOut(auth); } catch {}
              // Zaloguj nieudane logowanie - brak uprawnień
              try {
                await logActivity("system", "ADMIN_LOGIN_FAILED", {
                  login: login,
                  reason: "insufficient_permissions",
                  method: "firebase",
                  ip: "unknown",
                  userAgent: navigator.userAgent,
                });
              } catch (logError) {
                console.error("Error logging failed login:", logError);
              }
              showStatus(
                "<strong style='color: #dc2626; font-weight: bold;'>Brak uprawnień administratora. Sprawdź czy Twoje konto ma rolę 'admin' w systemie.</strong>",
                true,
              );
              setTimeout(() => redirectNotAuthorized(), 400);
              return;
            }

            // Zaloguj udane logowanie Firebase
            await logActivity("system", "ADMIN_LOGIN_SUCCESS", {
              login: login,
              method: "firebase",
              userId: user.uid,
              ip: "unknown",
              userAgent: navigator.userAgent,
            });

            showStatus("Logowanie administratora (Firebase) pomyślne.");
          } catch (error) {
            console.error("Login error:", error);

            let errorMessage = "<span style='color: #dc2626; font-weight: bold;'>Błędne dane. Nieupoważnionym wstęp wzbroniony.</span>";
            let errorReason = "unknown_error";

            if (error.code === "auth/user-not-found") {
              errorReason = "user_not_found";
            } else if (error.code === "auth/wrong-password") {
              errorReason = "wrong_password";
            } else if (error.code === "auth/invalid-email") {
              errorReason = "invalid_email_format";
            } else if (error.code === "auth/too-many-requests") {
              errorMessage =
                "Zbyt wiele prób logowania. Spróbuj ponownie później.";
              errorReason = "too_many_attempts";
            }

            // Zaloguj nieudane logowanie
            await logActivity("system", "ADMIN_LOGIN_FAILED", {
              login: login,
              reason: errorReason,
              method: "firebase",
              errorCode: error.code,
              ip: "unknown",
              userAgent: navigator.userAgent,
            });

            showStatus(errorMessage, true);
          }
        });

      // Wylogowanie administratora
      window.logoutAdmin = async () => {
        try {
          // Zatrzymaj wszystkie listenery Firestore przed wylogowaniem (zapobiega błędom CORS)
          try {
            if (pendingTasksListener) {
              clearInterval(pendingTasksListener);
              pendingTasksListener = null;
            }
            if (activityLogsListener) {
              clearInterval(activityLogsListener);
              activityLogsListener = null;
            }
            if (window.sessionInterval) {
              clearInterval(window.sessionInterval);
              window.sessionInterval = null;
            }
          } catch (e) {
            // ignore
          }

          // SSO: wyczyść cookie wspólnej sesji (ważne dla synchronizacji między subdomenami)
          try {
            await fetch("https://strzelca.pl/api/sso-session-logout", {
              method: "POST",
              credentials: "include",
            });
          } catch (e) {
            console.warn("SSO logout failed (ignored):", e?.message || e);
          }

          // Wyczyść cache SSO
          try {
            const { clearSSOCache } = await import("https://strzelca.pl/sso-client.mjs?v=2026-02-06-1");
            clearSSOCache();
          } catch (e) {
            // ignore
          }

          // Wyloguj z Firebase Auth (ignoruj błędy Firestore CORS)
          try {
            await signOut(auth);
          } catch (error) {
            // Ignoruj błędy CORS z Firestore przy wylogowaniu
            if (error?.message && (
              error.message.includes('access control checks') ||
              error.message.includes('CORS') ||
              error.message.includes('firestore.googleapis.com')
            )) {
              console.warn("Ignored Firestore CORS error during logout");
            } else {
              console.error("Logout error:", error);
            }
          }

          // Zatrzymaj śledzenie aktywności
          stopActivityTracking();
          
          // Ostatnia aktualizacja przed wylogowaniem
          if (currentUser) {
            try {
              await updateDoc(doc(db, "userProfiles", currentUser.uid), {
                lastSeen: serverTimestamp()
              });
            } catch (e) {
              // Ignoruj błędy przy wylogowaniu
            }
          }

          currentUser = null;

          // Wyczyść wszystkie dane sesji z localStorage
          localStorage.clear();

          showNotification("Administrator wylogowany.");

          // Przejdź do sekcji logowania
          document.getElementById("login-section").classList.remove("hidden");
          document.getElementById("admin-panel").classList.add("hidden");
        } catch (error) {
          // Ignoruj błędy CORS przy wylogowaniu
          if (error?.message && (
            error.message.includes('access control checks') ||
            error.message.includes('CORS') ||
            error.message.includes('firestore.googleapis.com')
          )) {
            console.warn("Ignored Firestore CORS error during logout");
            // Mimo błędu, kontynuuj wylogowanie
            currentUser = null;
            localStorage.clear();
            document.getElementById("login-section")?.classList.remove("hidden");
            document.getElementById("admin-panel")?.classList.add("hidden");
          } else {
            console.error("Logout error:", error);
          }
        }
      };



      // Sprawdź aktualnego użytkownika od razu po inicjalizacji (przed ustawieniem listenera)
      (async () => {
        const initialUser = auth.currentUser;
        if (initialUser) {
          console.log('Admin: Checking initial user:', initialUser.uid);
          
          // Sprawdź czy to SuperAdmin (szybka weryfikacja bez Firestore)
          const superAdminUID = 'nCMUz2fc8MM9WhhMVBLZ1pdR7O43';
          if (initialUser.uid === superAdminUID) {
            console.log('SuperAdmin detected, granting access immediately');
            const isAdmin = await checkAndShowAdminPanel(initialUser);
            if (isAdmin) return; // SuperAdmin ma dostęp
          }
          
          const isAdmin = await checkAndShowAdminPanel(initialUser);
          if (!isAdmin) {
            // Sprawdź, czy błąd był związany z dostępem do Firestore
            // Jeśli tak, nie blokuj dostępu - może użytkownik jest adminem, ale nie możemy tego zweryfikować
            console.warn('Initial user check failed. This may be due to Firestore access issues.');
            console.warn('If you are an admin, check Firebase Console configuration and CORS settings.');
            
            // Nie wylogowuj automatycznie - pozwól użytkownikowi zobaczyć komunikat błędu
            // showStatus('<strong style="color: #dc2626; font-weight: bold;">Nie można zweryfikować uprawnień. Sprawdź konfigurację Firebase.</strong>', true);
          }
        }
      })();

      // Ustaw listener dla przyszłych zmian stanu autoryzacji
      onAuthStateChanged(auth, async (user) => {
        if (user) {
          console.log('[Auth State Changed] User logged in:', user.uid);
          const isAdmin = await checkAndShowAdminPanel(user);
          console.log('[Auth State Changed] Admin check result:', isAdmin);
          
          if (!isAdmin) {
            // Jeśli użytkownik nie ma roli admin, wyloguj go
            console.warn('User does not have admin role, signing out:', user.uid);
            console.warn('Waiting 5 seconds before signout to allow debugging...');
            
            // Pokaż komunikat z możliwością anulowania
            const errorDiv = document.createElement("div");
            errorDiv.id = "admin-access-denied";
            errorDiv.style.cssText = "position: fixed; top: 0; left: 0; right: 0; background: #dc2626; color: white; padding: 20px; z-index: 10000; text-align: center; box-shadow: 0 2px 10px rgba(0,0,0,0.3);";
            errorDiv.innerHTML = `
              <strong>🚫 Brak dostępu do panelu admina</strong><br>
              <p style="margin: 10px 0;">Użytkownik nie ma uprawnień administratora.</p>
              <p style="margin: 10px 0; font-size: 12px;">Wylogowanie za <span id="countdown">5</span> sekund...</p>
              <p style="margin: 10px 0; font-size: 11px;">Sprawdź konsolę przeglądarki (F12) dla szczegółów.</p>
              <button onclick="document.getElementById('admin-access-denied').remove(); clearTimeout(window.signoutTimeout);" 
                      style="margin-top: 10px; padding: 8px 16px; background: rgba(255,255,255,0.2); border: 1px solid white; color: white; border-radius: 4px; cursor: pointer;">
                Anuluj wylogowanie (debug)
              </button>
            `;
            document.body.appendChild(errorDiv);
            
            // Countdown
            let countdown = 5;
            const countdownEl = document.getElementById('countdown');
            const countdownInterval = setInterval(() => {
              countdown--;
              if (countdownEl) countdownEl.textContent = countdown;
              if (countdown <= 0) {
                clearInterval(countdownInterval);
              }
            }, 1000);
            
            // Opóźnij wylogowanie o 5 sekund, żeby można było zobaczyć błędy
            window.signoutTimeout = setTimeout(async () => {
              clearInterval(countdownInterval);
              try { 
                await signOut(auth); 
                console.log('[Auth State Changed] User signed out');
              } catch (e) {
                console.error('[Auth State Changed] Error signing out:', e);
              }
              showStatus('<strong style="color: #dc2626; font-weight: bold;">Strona dostępna tylko dla uprawnionych użytkowników.</strong>', true);
              setTimeout(() => redirectNotAuthorized(), 400);
            }, 5000);
            if (window.sessionInterval) {
              clearInterval(window.sessionInterval);
              window.sessionInterval = null;
            } // Zatrzymaj UI updater
          }
        } else {
          currentUser = null;
          document.getElementById("login-section").classList.remove("hidden");
          document.getElementById("admin-panel").classList.add("hidden");
          if (window.sessionInterval) {
            clearInterval(window.sessionInterval);
            window.sessionInterval = null;
          } // Zatrzymaj UI updater przy wylogowaniu

          // Brak sesji: przekieruj do wspólnego logowania (bez pokazywania osobnego logowania admina)
          try {
            const target = new URL("https://konto.strzelca.pl/logowanie.html");
            target.searchParams.set("redirect", "https://strzelca.pl/admin/index.html");
            window.location.replace(target.toString());
          } catch {
            window.location.replace("https://konto.strzelca.pl/logowanie.html?redirect=https%3A%2F%2Fstrzelca.pl%2Fadmin%2Findex.html");
          }
        }
      });

      // =============================================================================
      // GLOBAL ACTIVITY EVENT LISTENERS (Sliding Expiration)

      // Funkcja odświeżania dashboardu z animacją ładowania
      async function refreshDashboardWithLoading() {
        const refreshBtn = document.getElementById("dashboard-refresh-btn");

        if (refreshBtn) {
          refreshBtn.disabled = true;
          refreshBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin mr-2"></i><span id="refresh-text">Ładowanie...</span>';
        }

        try {
          // Pokaż loading overlay dla całego dashboardu
          showDashboardLoadingStates();

          // Odśwież dane
          await loadDashboardStats();

          // Aktualizuj timestamp ostatniej aktualizacji
          const lastEventsUpdateEl = document.getElementById("last-events-update");
          if (lastEventsUpdateEl) lastEventsUpdateEl.textContent = new Date().toLocaleString("pl-PL");

          showNotification("Dashboard został odświeżony", "success");
        } catch (error) {
          console.error("Error refreshing dashboard:", error);
          showNotification("Błąd odświeżania dashboardu", "error");
        } finally {
          // Ukryj loading overlay
          hideDashboardLoadingStates();

          if (refreshBtn) {
            refreshBtn.disabled = false;
            refreshBtn.innerHTML = '<i class="fa-solid fa-sync-alt text-lg" id="dashboard-refresh-icon"></i>';
          }
        }
      }

      // Udostępnij funkcję globalnie
      window.refreshDashboardWithLoading = refreshDashboardWithLoading;
      window.loadDashboardActivityLogs = loadDashboardActivityLogs;

      // Funkcja odświeżania dziennika aktywności z animacją przycisku
      window.refreshActivityLogs = async () => {
        const refreshBtn = document.getElementById("refresh-activity-btn");
        if (refreshBtn) {
          refreshBtn.disabled = true;
          refreshBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin mr-2"></i><span id="refresh-text">Ładowanie...</span>';
        }

        try {
          await loadDashboardActivityLogs(true); // Reset i załaduj od nowa
        } finally {
          if (refreshBtn) {
            refreshBtn.disabled = false;
            refreshBtn.innerHTML = '<i class="fa-solid fa-sync-alt text-lg" id="refresh-activity-icon"></i>';
          }
        }
      };

      // Funkcja ładowania więcej logów aktywności
      window.loadMoreActivityLogs = async () => {
        activityLogsLimit += 20; // Zwiększ limit o 20
        await loadDashboardActivityLogs(false); // Nie resetuj, tylko załaduj więcej
      };

      // Funkcja otwierania modala wszystkich logów aktywności
      window.openAllActivityLogsModal = async () => {
        const modal = document.getElementById("all-activity-logs-modal");
        modal.classList.remove("hidden");
        document.body.style.overflow = 'hidden';
        
        // Dodaj listener dla ESC
        const escHandler = (e) => {
          if (e.key === 'Escape') {
            closeAllActivityLogsModal();
            document.removeEventListener('keydown', escHandler);
          }
        };
        document.addEventListener('keydown', escHandler);
        
        await loadAllActivityLogs();
      };

      // Funkcja zamykania modala wszystkich logów aktywności
      window.closeAllActivityLogsModal = () => {
        document.getElementById("all-activity-logs-modal").classList.add("hidden");
        document.body.style.overflow = '';
      };

      // Funkcja ładowania wszystkich logów aktywności do modala
      let allActivityLogs = [];
      async function loadAllActivityLogs() {
        const container = document.getElementById('all-activity-logs-container');
        if (!container) return;

        try {
          container.innerHTML = `
            <div class="text-center text-zinc-500 py-8">
              <i class="fa-solid fa-spinner fa-spin text-2xl mb-4 text-zinc-600"></i>
              <h4 class="text-lg font-semibold mb-2">Ładowanie logów...</h4>
            </div>
          `;

          // Pobierz wszystkie logi aktywności (bez limitu)
          const activityLogsRef = collection(db, 'activityLogs');
          const q = query(activityLogsRef, orderBy('timestamp', 'desc'));
          const querySnapshot = await getDocs(q);

          allActivityLogs = [];
          querySnapshot.forEach((doc) => {
            allActivityLogs.push({
              id: doc.id,
              ...doc.data(),
              timestamp: doc.data().timestamp
            });
          });

          console.log('Loaded all activity logs:', allActivityLogs.length);
          
          // Zastosuj filtry i wyświetl
          filterActivityLogs();
        } catch (error) {
          console.error("Error loading all activity logs:", error);
          container.innerHTML = `
            <div class="text-center text-red-400 py-8">
              <i class="fa-solid fa-exclamation-triangle text-2xl mb-4"></i>
              <h4 class="text-lg font-semibold mb-2">Błąd ładowania logów</h4>
              <p class="text-sm">${error.message}</p>
            </div>
          `;
        }
      }

      // Funkcja filtrowania logów aktywności
      window.filterActivityLogs = async () => {
        const container = document.getElementById('all-activity-logs-container');
        if (!container || allActivityLogs.length === 0) return;

        const actionFilter = document.getElementById('activity-filter-action')?.value || 'all';
        const dateFrom = document.getElementById('activity-filter-date-from')?.value;
        const dateTo = document.getElementById('activity-filter-date-to')?.value;

        let filteredLogs = allActivityLogs;

        // Filtruj po typie akcji
        if (actionFilter !== 'all') {
          filteredLogs = filteredLogs.filter(log => log.action === actionFilter);
        }

        // Filtruj po dacie
        if (dateFrom) {
          const fromDate = new Date(dateFrom);
          fromDate.setHours(0, 0, 0, 0);
          filteredLogs = filteredLogs.filter(log => {
            const logDate = log.timestamp?.toDate ? log.timestamp.toDate() : new Date(log.timestamp);
            return logDate >= fromDate;
          });
        }

        if (dateTo) {
          const toDate = new Date(dateTo);
          toDate.setHours(23, 59, 59, 999);
          filteredLogs = filteredLogs.filter(log => {
            const logDate = log.timestamp?.toDate ? log.timestamp.toDate() : new Date(log.timestamp);
            return logDate <= toDate;
          });
        }

        // Zaktualizuj licznik
        const countEl = document.getElementById('activity-logs-count');
        if (countEl) countEl.textContent = filteredLogs.length;

        // Wyświetl przefiltrowane logi
        if (filteredLogs.length === 0) {
          container.innerHTML = `
            <div class="text-center text-zinc-500 py-8">
              <i class="fa-solid fa-filter text-2xl mb-4 text-zinc-600"></i>
              <h4 class="text-lg font-semibold mb-2">Brak logów</h4>
              <p class="text-sm">Nie znaleziono logów spełniających kryteria filtrowania</p>
            </div>
          `;
          return;
        }

        // Pobierz nazwy użytkowników asynchronicznie dla wszystkich logów
        const logsWithNames = await Promise.all(
          filteredLogs.map(async (log) => {
            const timestamp = log.timestamp?.toDate ? log.timestamp.toDate() : new Date(log.timestamp);
            const timeAgo = getTimeAgo ? getTimeAgo(timestamp) : timestamp.toLocaleString("pl-PL");
            
            // Użyj asynchronicznej wersji do pobrania nazwy użytkownika
            const userDisplayName = await getUserDisplayNameAsync(log);
            
            // Utwórz kopię logu z nazwą użytkownika dla renderActivityLog
            const logWithName = { ...log, userDisplayName };
            // Pobierz nick użytkownika docelowego jeśli to USER_BLOCKED lub USER_UNBLOCKED
            if ((log.action === "USER_BLOCKED" || log.action === "USER_UNBLOCKED") && (log.targetUserId || (log.details && log.details.targetUser))) {
              const targetUserId = log.targetUserId || (log.details && log.details.targetUser);
              if (targetUserId) {
                logWithName.targetUserNickname = await getUserNicknameByIdAsync(targetUserId);
              }
            }
            const activityLog = renderActivityLog ? await renderActivityLog(logWithName) : { description: log.action || 'Aktywność', content: log.details || '' };

            return `
              <div class="p-4 bg-zinc-800 rounded-lg hover:bg-zinc-700 transition cursor-pointer" onclick="showEventDetails ? showEventDetails('${log.id}') : null">
                <div class="flex justify-between items-start mb-2">
                  <div class="font-semibold text-white">${activityLog.description}</div>
                  <div class="text-xs text-zinc-500">${timeAgo}</div>
                </div>
                ${activityLog.content ? `<div class="text-xs text-zinc-400 mt-1">${activityLog.content}</div>` : ''}
                <div class="text-xs text-zinc-500 mt-2">
                  ${timestamp.toLocaleString("pl-PL")}
                </div>
              </div>
            `;
          })
        );
        
        const logsHtml = logsWithNames.join("");

        container.innerHTML = logsHtml;
      }

      // Funkcja resetowania filtrów
      window.resetActivityFilters = () => {
        document.getElementById('activity-filter-action').value = 'all';
        document.getElementById('activity-filter-date-from').value = '';
        document.getElementById('activity-filter-date-to').value = '';
        filterActivityLogs();
      }

      // Funkcja czyszczenia wszystkich logów aktywności
      window.clearAllActivityLogs = async () => {
        if (!confirm("Czy na pewno chcesz usunąć WSZYSTKIE logi aktywności? Ta operacja jest nieodwracalna!")) {
          return;
        }

        if (!confirm("UWAGA: To usunie wszystkie logi aktywności z bazy danych. Czy jesteś pewien?")) {
          return;
        }

        try {
          showNotification("Usuwanie logów aktywności...", "info");
          
          // Pobierz wszystkie logi aktywności
          const activityLogsRef = collection(db, "activityLogs");
          const querySnapshot = await getDocs(activityLogsRef);
          
          // Usuń wszystkie dokumenty w batchach (maksymalnie 500 na batch)
          const batchSize = 500;
          const docs = querySnapshot.docs;
          let deletedCount = 0;
          
          for (let i = 0; i < docs.length; i += batchSize) {
            const batch = writeBatch(db);
            const batchDocs = docs.slice(i, i + batchSize);
            
            batchDocs.forEach((doc) => {
              batch.delete(doc.ref);
            });
            
            await batch.commit();
            deletedCount += batchDocs.length;
            
            // Aktualizuj postęp
            showNotification(`Usunięto ${deletedCount} z ${docs.length} logów...`, "info");
          }
          
          showNotification(`Pomyślnie usunięto wszystkie logi aktywności (${deletedCount} rekordów).`, "success");
          
          // Odśwież listę logów
          await loadDashboardActivityLogs(true);
        } catch (error) {
          console.error("Error clearing activity logs:", error);
          showNotification("Błąd podczas usuwania logów aktywności.", "error");
        }
      };

      // Funkcje ładowania danych
      async function loadDashboardStats() {
        console.log('loadDashboardStats called, currentUser exists:', !!currentUser);
        // Sprawdź czy użytkownik jest uwierzytelniony i ma rolę admin
        if (!currentUser) {
          console.warn("Brak uwierzytelnionego użytkownika - pomijanie ładowania statystyk");
          return;
        }

        try {
          const isAdmin = await checkAdminRole(currentUser);
          if (!isAdmin) {
            console.warn("Użytkownik nie ma roli admin - pomijanie ładowania statystyk");
            return;
          }

          // Ładowanie statusu stron
          await checkSitesStatus();

          // Ładowanie statystyk aktywności
          await loadActivityStats();
          await loadContactFormsCount();

          // Ładowanie dziennika aktywności
          await loadDashboardActivityLogs(true);

          // Ładowanie statystyk Google Analytics
          await fetchGAStatistics();

          // Ustawienie listener dla activityLogs (tylko jeśli jeszcze nie jest ustawiony)
          if (!activityLogsListener) {
            setupActivityLogsListener();
          }

          // Ustawienie listener dla pending tasks (tylko jeśli jeszcze nie jest ustawiony)
          if (!pendingTasksListener) {
            setupPendingTasksListener();
          }
        } catch (error) {
          console.error("Error loading dashboard stats:", error);
          showNotification("Błąd ładowania danych dashboard.", "error");
        }
      }

      // Funkcja ładowania dziennika aktywności dla dashboardu
      async function loadDashboardActivityLogs(reset = false) {
        const container = document.getElementById('admin-activity-log');
        console.log('loadDashboardActivityLogs called, container exists:', !!container);
        if (!container) {
          console.warn('admin-activity-log container not found, skipping activity logs loading');
          return;
        }

        console.log('Loading activity logs...');

        try {
          // Jeśli reset, wyczyść załadowane logi
          if (reset) {
            loadedActivityLogs = [];
            activityLogsLimit = 20;
          }

          // Pobierz activity logs bezpośrednio z Firestore
          const activityLogsRef = collection(db, 'activityLogs');
          const q = query(activityLogsRef, orderBy('timestamp', 'desc'), limit(activityLogsLimit));
          
          console.log('[Activity Logs] Próba pobrania danych z Firestore...');
          const querySnapshot = await getDocs(q).catch((error) => {
            console.error('[Activity Logs] Błąd podczas pobierania danych:', error);
            console.error('[Activity Logs] Szczegóły błędu:', {
              code: error.code,
              message: error.message,
              stack: error.stack
            });
            
            // Sprawdź, czy to błąd CORS
            if (error.message?.includes('CORS') || 
                error.message?.includes('access control') ||
                error.code === 'unavailable' ||
                error.code === 'permission-denied') {
              console.error('[Activity Logs] ⚠️ BŁĄD CORS LUB DOSTĘPU DO FIRESTORE!');
              console.error('[Activity Logs] Sprawdź:');
              console.error('[Activity Logs] 1. Czy domena jest dodana do Firebase Console → Authentication → Settings → Authorized domains');
              console.error('[Activity Logs] 2. Czy API Key ma odpowiednie ograniczenia w Google Cloud Console');
              console.error('[Activity Logs] 3. Czy Firestore Security Rules pozwalają na dostęp');
              
              // Wyświetl komunikat użytkownikowi
              const container = document.getElementById('admin-activity-log');
              if (container) {
                container.innerHTML = `
                  <div class="bg-red-900/20 border border-red-500 rounded-lg p-4 text-center">
                    <h3 class="text-red-400 font-bold mb-2">⚠️ Błąd połączenia z Firestore</h3>
                    <p class="text-zinc-300 text-sm mb-2">Nie można połączyć się z bazą danych Firestore.</p>
                    <p class="text-zinc-400 text-xs">Sprawdź konfigurację domeny w Firebase Console.</p>
                    <p class="text-zinc-500 text-xs mt-2">Kod błędu: ${error.code || 'unknown'}</p>
                  </div>
                `;
              }
            }
            
            throw error;
          });

          const logs = [];
          querySnapshot.forEach((doc) => {
            logs.push({
              id: doc.id,
              ...doc.data(),
              timestamp: doc.data().timestamp?.toDate?.()?.toISOString() || doc.data().timestamp
            });
          });

          console.log('Loaded logs from Firestore:', logs.length);

          // Zaktualizuj załadowane logi
          loadedActivityLogs = logs;

          if (logs.length === 0 && reset) {
              container.innerHTML = `
                <div class="text-center text-zinc-500 py-8">
                  <i class="fa-solid fa-list text-2xl mb-4 text-zinc-600"></i>
                  <h4 class="text-lg font-semibold mb-2">Brak aktywności</h4>
                  <p class="text-sm">Dziennik aktywności jest pusty</p>
                </div>
              `;
              return;
            }

            // Pobierz nazwy użytkowników asynchronicznie dla wszystkich logów
            const logsWithNames = await Promise.all(
              logs.map(async (log) => {
                const timestamp = log.timestamp ? new Date(log.timestamp.toDate ? log.timestamp.toDate() : log.timestamp) : new Date();
                const timeAgo = getTimeAgo ? getTimeAgo(timestamp) : timestamp.toLocaleString("pl-PL");
                
                // Użyj asynchronicznej wersji do pobrania nazwy użytkownika
                const userDisplayName = await getUserDisplayNameAsync(log);
                
                // Utwórz kopię logu z nazwą użytkownika dla renderActivityLog
                const logWithName = { ...log, userDisplayName };
                // Pobierz nick użytkownika docelowego jeśli to USER_BLOCKED lub USER_UNBLOCKED
                if ((log.action === "USER_BLOCKED" || log.action === "USER_UNBLOCKED") && (log.targetUserId || (log.details && log.details.targetUser))) {
                  const targetUserId = log.targetUserId || (log.details && log.details.targetUser);
                  if (targetUserId) {
                    logWithName.targetUserNickname = await getUserNicknameByIdAsync(targetUserId);
                  }
                }
                const activityLog = renderActivityLog ? await renderActivityLog(logWithName) : { description: log.action || 'Aktywność', content: log.details || '' };

                return {
                  html: `
                  <div class="p-4 bg-zinc-800 rounded-lg hover:bg-zinc-700 transition cursor-pointer" onclick="showEventDetails ? showEventDetails('${log.id}') : null">
                    <div class="flex justify-between items-start mb-2">
                        <div class="font-semibold text-white">${activityLog.description}</div>
                      <div class="text-xs text-zinc-500">${timeAgo}</div>
                    </div>
                      ${activityLog.content ? `<div class="text-xs text-zinc-400 mt-1">${activityLog.content}</div>` : ''}
                  </div>
                  `,
                  timestamp
                };
              })
            );
            
            // Sortuj po czasie (najnowsze na górze)
            logsWithNames.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            
            const logsHtml = logsWithNames.map(log => log.html).join("");

          // Sprawdź czy są więcej logów do załadowania
          const hasMore = logs.length >= activityLogsLimit;
          const loadMoreButton = hasMore ? `
            <div class="text-center mt-6">
              <button onclick="loadMoreActivityLogs()" class="bg-coyote hover:bg-opacity-80 text-black px-6 py-3 rounded-lg font-semibold transition">
                <i class="fa-solid fa-arrow-down mr-2"></i>
                Załaduj więcej (${activityLogsLimit} zobaczono)
              </button>
            </div>
          ` : logs.length > 0 ? `
            <div class="text-center mt-6 text-zinc-500 text-sm">
              <i class="fa-solid fa-check-circle mr-2"></i>
              Wyświetlono wszystkie logi (${logs.length})
            </div>
          ` : '';

          container.innerHTML = logsHtml + loadMoreButton;
        } catch (apiError) {
          console.warn('API failed, using mock data for localhost:', apiError.message);

          // Mock data dla localhost gdy API nie działa
          const mockLogs = [
            {
              id: '1',
              type: 'admin_login',
              action: 'Administrator zalogowany',
              details: 'Administrator zalogował się do panelu',
              timestamp: new Date().toISOString(),
              adminId: 'firebase-admin',
              user: 'Administrator'
            },
            {
              id: '2',
              type: 'dashboard_view',
              action: 'Wyświetlono dashboard',
              details: 'Administrator przeglądał dashboard',
              timestamp: new Date(Date.now() - 60000).toISOString(),
              adminId: 'firebase-admin',
              user: 'Administrator'
            },
            {
              id: '3',
              type: 'settings_view',
              action: 'Przeglądnięto ustawienia',
              details: 'Administrator przeglądał ustawienia systemu',
              timestamp: new Date(Date.now() - 120000).toISOString(),
              adminId: 'firebase-admin',
              user: 'Administrator'
            }
          ];

          const logsHtml = mockLogs
            .map((log) => {
              const timestamp = new Date(log.timestamp);
              const timeAgo = getTimeAgo ? getTimeAgo(timestamp) : timestamp.toLocaleString("pl-PL");
              const activityLog = { description: log.action || 'Aktywność', content: log.details || '' };

              return `
                <div class="p-4 bg-zinc-800 rounded-lg hover:bg-zinc-700 transition">
                  <div class="flex justify-between items-start mb-2">
                    <div class="font-semibold text-white">${log.user || "System"}</div>
                    <div class="text-xs text-zinc-500">${timeAgo}</div>
                  </div>
                  <div class="text-sm text-zinc-300">${activityLog.description}</div>
                  <div class="text-xs text-zinc-500 mt-1">${activityLog.content}</div>
                </div>
              `;
            })
            .join("");

          container.innerHTML = logsHtml;
          console.log('Loaded mock activity logs for localhost');
        }
      }

      // Funkcje do zarządzania stanami ładowania dashboardu
      function showDashboardLoadingStates() {
        const overlay = document.getElementById("dashboard-loading-overlay");
        overlay.classList.add("active");
      }

      function hideDashboardLoadingStates() {
        const overlay = document.getElementById("dashboard-loading-overlay");
        overlay.classList.remove("active");
      }

      // Zarządzanie użytkownikami
      async function loadUsers() {
        try {
          // Najpierw automatycznie odblokuj wygasłe blokady
          await autoUnblockExpiredBlocks();
          
          const usersSnapshot = await getDocs(collection(db, "userProfiles"));
          usersList = usersSnapshot.docs.map((doc) => ({
            id: doc.id,
            ...doc.data(),
          }));


          renderUsersList();
        } catch (error) {
          console.error("Error loading users:", error);
          showNotification("Błąd ładowania użytkowników.", "error");
        }
      }

      // Uwaga: ten plik działa jako ES module (<script type="module">),
      // więc funkcje NIE są automatycznie dostępne dla inline onclick.
      // Wystawiamy ją jawnie na window, bo przyciski filtrów używają onclick="filterUsers(...)"
      window.filterUsers = function filterUsers(filter) {
        currentUserFilter = filter;

        document.querySelectorAll(".user-filter-btn").forEach((btn) => {
          // reset do stanu nieaktywnego
          btn.classList.remove(
            "active",
            "border-coyote",
            "text-coyote",
            "bg-coyote/10",
            "shadow-[0_0_0_1px_rgba(193,154,107,0.35)]"
          );
          btn.classList.add("border-zinc-700", "text-zinc-300");
        });

        const activeBtn = document.querySelector(`[data-filter="${filter}"]`);
        if (activeBtn) {
          // usuń "szare" style, żeby nie nadpisywały aktywnego wyglądu
          activeBtn.classList.remove("border-zinc-700", "text-zinc-300");
          activeBtn.classList.add(
            "active",
            "border-coyote",
            "text-coyote",
            "bg-coyote/10",
            "shadow-[0_0_0_1px_rgba(193,154,107,0.35)]"
          );
        }

        renderUsersList();
      };

      function renderUsersList() {
        let filteredUsers = usersList;

        switch (currentUserFilter) {
          case "active":
            // Aktywni = użytkownicy online (lastSeen w ostatnich 30 minutach)
            filteredUsers = usersList.filter((u) => isUserOnline(u));
            break;
          case "inactive":
            // Nieaktywni = użytkownicy offline (nie online) + zablokowani (zawsze nieaktywni)
            filteredUsers = usersList.filter((u) => !isUserOnline(u) || u.status === "blocked");
            break;
          case "blocked":
            filteredUsers = usersList.filter((u) => u.status === "blocked");
            break;
          case "admin":
            filteredUsers = usersList.filter((u) => u.role === "admin");
            break;
          case "company":
            filteredUsers = usersList.filter((u) => u.role === "company");
            break;
        }

        const usersHtml = filteredUsers
          .map((user) => {
            const isCurrentUser = currentUser && user.id === currentUser.uid;
            const status = user.status || "active";
            const role = user.role || "user";
            const roleDisplay = {
              admin: "ADMINISTRATOR",
              company: "FIRMA",
              user: "UŻYTKOWNIK",
            };

            const statusClasses = {
              active: "status-active",
              blocked: "status-blocked",
              suspended: "status-suspended",
            };

            const roleClasses = {
              admin: "role-admin",
              user: "role-user",
              company: "role-company",
            };

            const decryptedUser = {
              ...user,
              phone: user.phone
                ? atob(user.phone)
                : "",
              address: {
                street: user.address?.street
                  ? atob(user.address.street)
                  : "",
                city: user.address?.city
                  ? atob(user.address.city)
                  : "",
              },
            };

            // Sprawdź czy użytkownik jest online
            const isOnline = isUserOnline(user);
            const lastSeenText = getLastSeenText(user);
            const blockedUntilText = getBlockedUntilText(user);

            return `
                    <div class="border-l-4 ${statusClasses[status]} p-4 rounded-r-lg">
                        <div class="flex justify-between items-start mb-2">
                            <div class="flex-1">
                                <div class="flex items-center space-x-2 mb-1">
                                    <h4 class="${status === "blocked" ? "text-amber-700 font-bold" : "text-white font-bold"}">${decryptedUser.displayName}</h4>
                                    <span class="px-2 py-1 text-xs rounded font-bold ${roleClasses[role]}">${roleDisplay[role] || role.toUpperCase()}</span>
                                    <span class="px-2 py-1 text-xs rounded bg-gray-600 text-white">${status.toUpperCase()}</span>
                                    ${isOnline ? '<span class="px-2 py-1 text-xs rounded bg-green-500 text-white" title="Online">🟢 ONLINE</span>' : `<span class="px-2 py-1 text-xs rounded bg-gray-500 text-white" title="Ostatnia aktywność: ${lastSeenText}">⚫ OFFLINE</span>`}
                                    ${isCurrentUser ? '<span class="px-2 py-1 text-xs rounded bg-purple-600 text-white">TY</span>' : ""}
                                </div>
                                <div class="text-sm text-zinc-400 space-y-1">
                                    <div>📧 ${decryptedUser.email}</div>
                                    <div>📱 ${decryptedUser.phone || "Brak"}</div>
                                    <div>🏠 ${decryptedUser.address.city || "Brak adresu"}</div>
                                    <div>📅 ${new Date(user.createdAt?.toDate?.() || user.createdAt).toLocaleDateString("pl-PL")}</div>
                                    <div>🕐 Ostatnia aktywność: ${lastSeenText}</div>
                                    ${status === "blocked" && blockedUntilText ? `<div class="text-red-400 font-semibold">🔒 ${blockedUntilText}</div>` : ""}
                                </div>
                            </div>
                            <div class="flex space-x-2 ml-4">
                                <button onclick="viewUserDetails('${user.id}')" class="text-blue-400 hover:text-blue-300 px-2 py-1 border border-blue-400 rounded text-xs">Szczegóły</button>
                                ${
                                  !isCurrentUser
                                    ? `
                                    <button onclick="toggleUserBlock('${user.id}')" class="text-${status === "blocked" ? "green" : "yellow"}-400 hover:text-${status === "blocked" ? "green" : "yellow"}-300 px-2 py-1 border border-${status === "blocked" ? "green" : "yellow"}-400 rounded text-xs">
                                        ${status === "blocked" ? "Odblokuj" : "Zablokuj"}
                                    </button>
                                    <button onclick="deleteUser('${user.id}')" class="text-red-400 hover:text-red-300 px-2 py-1 border border-red-400 rounded text-xs">Usuń</button>
                                `
                                    : ""
                                }
                            </div>
                        </div>
                    </div>
                `;
          })
          .join("");

        document.getElementById("users-list").innerHTML =
          usersHtml ||
          '<div class="text-center text-zinc-500 py-8">Brak użytkowników</div>';
      }

      // Funkcja ładowania subskrybentów newslettera
      async function loadNewsletterSubscribers() {
        const subscribersContainer = document.getElementById("newsletter-subscribers");
        const subscribersCountEl = document.getElementById("subscribers-count");
        
        if (!subscribersContainer) return;

        // Pokaż loader
        subscribersContainer.innerHTML = `
          <div class="text-center text-zinc-500 py-8">
            <i class="fa-solid fa-spinner fa-spin text-2xl mb-4 text-zinc-600"></i>
            <h4 class="text-lg font-semibold mb-2">Ładowanie subskrybentów...</h4>
            <p class="text-sm">Proszę czekać</p>
          </div>
        `;

        try {
          // Pobierz wszystkich użytkowników
          const usersSnapshot = await getDocs(collection(db, "userProfiles"));
          
          // Filtruj użytkowników z newsletter === true
          const subscribers = [];
          usersSnapshot.forEach((doc) => {
            const userData = doc.data();
            // Sprawdź czy użytkownik ma newsletter === true (również sprawdzamy różne możliwe wartości)
            if (userData.newsletter === true || userData.newsletter === "true" || userData.newsletter === 1) {
              subscribers.push({
                id: doc.id,
                ...userData,
              });
            }
          });

          // Pobierz wartość wyszukiwania
          const searchInput = document.getElementById("newsletter-search");
          const searchTerm = searchInput ? searchInput.value.toLowerCase().trim() : "";

          // Filtruj po wyszukiwaniu
          let filteredSubscribers = subscribers;
          if (searchTerm) {
            filteredSubscribers = subscribers.filter((sub) => {
              const email = sub.email ? sub.email.toLowerCase() : "";
              const displayName = sub.displayName ? sub.displayName.toLowerCase() : "";
              return email.includes(searchTerm) || displayName.includes(searchTerm);
            });
          }

          // Wyświetl subskrybentów
          if (filteredSubscribers.length === 0) {
            subscribersContainer.innerHTML = `
              <div class="text-center text-zinc-500 py-8">
                <i class="fa-solid fa-envelope-open text-4xl mb-4 text-zinc-600"></i>
                <h4 class="text-lg font-semibold mb-2">Brak subskrybentów</h4>
                <p class="text-sm">${searchTerm ? "Nie znaleziono subskrybentów spełniających kryteria wyszukiwania" : "Nie ma jeszcze żadnych subskrybentów newslettera"}</p>
              </div>
            `;
          } else {
            const subscribersHtml = filteredSubscribers
              .map((sub) => {
                const decryptedEmail = sub.email || "Brak email";
                const displayName = sub.displayName || decryptedEmail;
                const createdAt = sub.createdAt?.toDate?.() 
                  ? new Date(sub.createdAt.toDate()).toLocaleDateString("pl-PL")
                  : sub.createdAt 
                    ? new Date(sub.createdAt).toLocaleDateString("pl-PL")
                    : "Nieznana data";

                return `
                  <div class="bg-zinc-800/50 rounded-lg p-4 border border-zinc-700 hover:bg-zinc-800/70 transition-all">
                    <div class="flex justify-between items-start">
                      <div class="flex-1">
                        <h4 class="text-white font-bold mb-1">${displayName}</h4>
                        <div class="text-sm text-zinc-400 space-y-1">
                          <div>📧 ${decryptedEmail}</div>
                          <div>📅 Data rejestracji: ${createdAt}</div>
                        </div>
                      </div>
                      <div class="flex space-x-2 ml-4">
                        <button onclick="viewUserDetails('${sub.id}')" class="text-blue-400 hover:text-blue-300 px-2 py-1 border border-blue-400 rounded text-xs">
                          Szczegóły
                        </button>
                      </div>
                    </div>
                  </div>
                `;
              })
              .join("");

            subscribersContainer.innerHTML = subscribersHtml;
          }

          // Zaktualizuj licznik
          if (subscribersCountEl) {
            subscribersCountEl.textContent = subscribers.length;
          }
        } catch (error) {
          console.error("Error loading newsletter subscribers:", error);
          subscribersContainer.innerHTML = `
            <div class="text-center text-red-400 py-8">
              <i class="fa-solid fa-exclamation-triangle text-4xl mb-4"></i>
              <h4 class="text-lg font-semibold mb-2">Błąd ładowania subskrybentów</h4>
              <p class="text-sm">${error.message}</p>
            </div>
          `;
          if (subscribersCountEl) {
            subscribersCountEl.textContent = "0";
          }
        }
      }

      // Funkcja wyszukiwania subskrybentów newslettera
      window.searchNewsletterSubscribers = function() {
        loadNewsletterSubscribers();
      };

      // Funkcje związane z newsletterem
      window.previewNewsletter = function() {
        const subject = document.getElementById("newsletter-subject")?.value || "";
        const content = document.getElementById("newsletter-editor")?.innerHTML || "";

        if (!subject.trim() && !content.trim()) {
          showNotification("Wprowadź temat i treść newslettera przed podglądem.", "error");
          return;
        }

        // Wyświetl podgląd w modalu
        const previewModal = document.getElementById("newsletter-preview-modal");
        const previewSubject = document.getElementById("preview-subject");
        const previewContent = document.getElementById("preview-content");

        if (previewModal && previewSubject && previewContent) {
          previewSubject.textContent = subject || "(Brak tematu)";
          previewContent.innerHTML = content || "<p class='text-zinc-500'>Brak treści</p>";
          previewModal.classList.remove("hidden");
        }
      };

      window.closeNewsletterPreview = function() {
        const previewModal = document.getElementById("newsletter-preview-modal");
        if (previewModal) {
          previewModal.classList.add("hidden");
        }
      };

      window.saveNewsletterDraft = async function() {
        try {
          const subject = document.getElementById("newsletter-subject")?.value || "";
          const content = document.getElementById("newsletter-editor")?.innerHTML || "";

          if (!subject.trim() && !content.trim()) {
            showNotification("Wprowadź temat i treść newslettera przed zapisaniem.", "error");
            return;
          }

          if (!currentUser) {
            showNotification("Musisz być zalogowany, aby zapisać wersję roboczą.", "error");
            return;
          }

          // Zapisz wersję roboczą w localStorage (nie wymaga uprawnień Firestore)
          const draftData = {
            subject: subject,
            content: content,
            savedAt: new Date().toISOString(),
            savedBy: currentUser.uid,
            savedByEmail: currentUser.email || 'admin@strzelca.pl',
          };

          try {
            localStorage.setItem('newsletterDraft', JSON.stringify(draftData));
            const savedDate = new Date(draftData.savedAt).toLocaleString('pl-PL');
            showNotification(`Wersja robocza zapisana lokalnie w przeglądarce (${savedDate}). Możesz ją pobrać jako plik.`, "success");
          } catch (storageError) {
            // Jeśli localStorage nie jest dostępny (np. tryb prywatny), spróbuj zapisać w Firestore
            console.warn("localStorage not available, trying Firestore:", storageError);
            
            // Pobierz dane administratora z profilu
            let adminName = 'Administrator';
            let adminEmail = currentUser?.email || 'admin@strzelca.pl';
            
            if (currentUser?.uid) {
              try {
                const adminProfile = await getDoc(doc(db, 'userProfiles', currentUser.uid));
                if (adminProfile.exists()) {
                  const adminData = adminProfile.data();
                  adminName = adminData.displayName || adminData.email || 'Administrator';
                  adminEmail = adminData.email || adminEmail;
                }
              } catch (e) {
                console.warn('Could not fetch admin profile:', e);
              }
            }

            const firestoreDraftData = {
              ...draftData,
              senderName: adminName,
              senderEmail: adminEmail,
            };

            // Próbuj zapisać w Firestore (może nie mieć uprawnień)
            try {
              await setDoc(doc(db, "newsletterDrafts", "current"), firestoreDraftData, { merge: true });
              showNotification("Wersja robocza newslettera została zapisana.", "success");
            } catch (firestoreError) {
              if (firestoreError.code === 'permission-denied') {
                showNotification("Nie można zapisać wersji roboczej - brak uprawnień do Firestore. Użyj localStorage (włączony w przeglądarce).", "error");
              } else {
                throw firestoreError;
              }
            }
          }
        } catch (error) {
          console.error("Error saving newsletter draft:", error);
          showNotification("Błąd podczas zapisywania wersji roboczej: " + (error.message || error), "error");
        }
      };

      // Funkcja do ładowania zapisanej wersji roboczej
      window.loadNewsletterDraft = function(showNotificationOnLoad = true) {
        try {
          const savedDraft = localStorage.getItem('newsletterDraft');
          if (savedDraft) {
            const draftData = JSON.parse(savedDraft);
            const subjectInput = document.getElementById("newsletter-subject");
            const contentEditor = document.getElementById("newsletter-editor");
            
            if (subjectInput) {
              subjectInput.value = draftData.subject || "";
            }
            if (contentEditor) {
              contentEditor.innerHTML = draftData.content || "";
            }
            
            if (showNotificationOnLoad) {
              const savedDate = draftData.savedAt ? new Date(draftData.savedAt).toLocaleString('pl-PL') : 'nieznana data';
              showNotification(`Wersja robocza została załadowana (zapisana: ${savedDate}).`, "success");
            }
            return true;
          } else {
            if (showNotificationOnLoad) {
              showNotification("Brak zapisanej wersji roboczej.", "info");
            }
            return false;
          }
        } catch (error) {
          console.error("Error loading newsletter draft:", error);
          if (showNotificationOnLoad) {
            showNotification("Błąd podczas ładowania wersji roboczej.", "error");
          }
          return false;
        }
      };

      // Funkcja do pobierania wersji roboczej jako plik
      window.downloadNewsletterDraft = function() {
        try {
          const savedDraft = localStorage.getItem('newsletterDraft');
          if (!savedDraft) {
            showNotification("Brak zapisanej wersji roboczej do pobrania.", "info");
            return;
          }

          const draftData = JSON.parse(savedDraft);
          const savedDate = draftData.savedAt ? new Date(draftData.savedAt).toISOString().split('T')[0] : 'unknown';
          
          // Utwórz plik JSON z wersją roboczą
          const jsonContent = JSON.stringify(draftData, null, 2);
          const blob = new Blob([jsonContent], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = url;
          link.download = `newsletter_draft_${savedDate}.json`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(url);

          // Opcjonalnie: utwórz też plik HTML z treścią
          const htmlContent = `<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Newsletter - ${draftData.subject || 'Bez tematu'}</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: #1a1a1a;
            color: #e0e0e0;
        }
        h1 {
            color: #c19a6b;
            border-bottom: 2px solid #c19a6b;
            padding-bottom: 10px;
        }
        .meta {
            color: #888;
            font-size: 0.9em;
            margin-bottom: 20px;
        }
        .content {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <h1>${draftData.subject || 'Newsletter - Bez tematu'}</h1>
    <div class="meta">
        <p><strong>Zapisano:</strong> ${draftData.savedAt ? new Date(draftData.savedAt).toLocaleString('pl-PL') : 'Nieznana data'}</p>
        <p><strong>Zapisane przez:</strong> ${draftData.savedByEmail || 'Nieznany użytkownik'}</p>
    </div>
    <div class="content">
        ${draftData.content || '<p>Brak treści</p>'}
    </div>
</body>
</html>`;

          // Pobierz HTML po krótkim opóźnieniu
          setTimeout(() => {
            const htmlBlob = new Blob([htmlContent], { type: 'text/html' });
            const htmlUrl = URL.createObjectURL(htmlBlob);
            const htmlLink = document.createElement('a');
            htmlLink.href = htmlUrl;
            htmlLink.download = `newsletter_draft_${savedDate}.html`;
            document.body.appendChild(htmlLink);
            htmlLink.click();
            document.body.removeChild(htmlLink);
            URL.revokeObjectURL(htmlUrl);
          }, 300);

          showNotification("Wersja robocza została pobrana jako pliki JSON i HTML.", "success");
        } catch (error) {
          console.error("Error downloading newsletter draft:", error);
          showNotification("Błąd podczas pobierania wersji roboczej: " + (error.message || error), "error");
        }
      };

      window.sendNewsletter = async function() {
        try {
          const subject = document.getElementById("newsletter-subject")?.value || "";
          const content = document.getElementById("newsletter-editor")?.innerHTML || "";

          if (!subject.trim()) {
            showNotification("Wprowadź temat newslettera.", "error");
            return;
          }

          if (!content.trim()) {
            showNotification("Wprowadź treść newslettera.", "error");
            return;
          }

          if (!currentUser) {
            showNotification("Musisz być zalogowany, aby wysłać newsletter.", "error");
            return;
          }

          // Potwierdź wysłanie
          const confirmMessage = `Czy na pewno chcesz wysłać newsletter do wszystkich subskrybentów?\n\nTemat: ${subject}\n\nTa operacja nie może być cofnięta.`;
          if (!confirm(confirmMessage)) {
            return;
          }

          // Pobierz listę subskrybentów
          const usersSnapshot = await getDocs(collection(db, "userProfiles"));
          const subscribers = [];
          usersSnapshot.forEach((doc) => {
            const userData = doc.data();
            if (userData.newsletter === true || userData.newsletter === "true" || userData.newsletter === 1) {
              subscribers.push({
                id: doc.id,
                email: userData.email,
                displayName: userData.displayName || userData.email,
              });
            }
          });

          if (subscribers.length === 0) {
            showNotification("Brak subskrybentów newslettera.", "error");
            return;
          }

          // Pobierz dane administratora z profilu
          let adminName = 'Administrator';
          let adminEmail = currentUser?.email || 'admin@strzelca.pl';
          
          if (currentUser?.uid) {
            try {
              const adminProfile = await getDoc(doc(db, 'userProfiles', currentUser.uid));
              if (adminProfile.exists()) {
                const adminData = adminProfile.data();
                adminName = adminData.displayName || adminData.email || 'Administrator';
                adminEmail = adminData.email || adminEmail;
              }
            } catch (e) {
              console.warn('Could not fetch admin profile:', e);
            }
          }

          // Wyślij newsletter przez API endpoint (zamiast bezpośredniego zapisu do Firestore)
          const newsletterPayload = {
            subject: subject,
            content: content,
            subscribers: subscribers.map(s => s.email),
            subscriberCount: subscribers.length,
            senderName: adminName,
            senderEmail: adminEmail,
            sentBy: currentUser.uid,
          };

          try {
            const res = await fetch('/api/newsletter', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              credentials: 'include',
              body: JSON.stringify(newsletterPayload),
            });

            const data = await res.json().catch(() => null);
            if (!res.ok || !data?.success) {
              throw new Error(data?.error || `HTTP ${res.status}`);
            }

            showNotification(`Newsletter został dodany do kolejki wysyłki do ${subscribers.length} subskrybentów.`, "success");
          } catch (apiError) {
            // Fallback: spróbuj zapisać bezpośrednio do Firestore (może nie mieć uprawnień)
            console.warn('API endpoint failed, trying Firestore fallback:', apiError);
            try {
              const newsletterData = {
                subject: subject,
                content: content,
                subscribers: subscribers.map(s => s.email),
                subscriberCount: subscribers.length,
                sentAt: serverTimestamp(),
                sentBy: currentUser.uid,
                sentByEmail: adminEmail,
                senderName: adminName,
                senderEmail: adminEmail,
                status: "pending",
              };

              await addDoc(collection(db, "newsletterQueue"), newsletterData);
              showNotification(`Newsletter został dodany do kolejki wysyłki do ${subscribers.length} subskrybentów.`, "success");
            } catch (firestoreError) {
              if (firestoreError.code === 'permission-denied') {
                throw new Error('Brak uprawnień do zapisu newslettera. Skontaktuj się z administratorem systemu.');
              } else {
                throw new Error(`Błąd podczas wysyłania newslettera: ${apiError.message || firestoreError.message}`);
              }
            }
          }

          // Opcjonalnie: wyczyść edytor
          if (confirm("Czy chcesz wyczyścić edytor newslettera?")) {
            document.getElementById("newsletter-subject").value = "";
            document.getElementById("newsletter-editor").innerHTML = "";
          }
        } catch (error) {
          console.error("Error sending newsletter:", error);
          showNotification("Błąd podczas wysyłania newslettera.", "error");
        }
      };

      window.exportNewsletter = async function() {
        try {
          const subject = document.getElementById("newsletter-subject")?.value || "";
          const content = document.getElementById("newsletter-editor")?.innerHTML || "";

          if (!subject.trim() && !content.trim()) {
            showNotification("Wprowadź temat i treść newslettera przed eksportem.", "error");
            return;
          }

          // Pobierz listę subskrybentów
          const usersSnapshot = await getDocs(collection(db, "userProfiles"));
          const subscribers = [];
          usersSnapshot.forEach((doc) => {
            const userData = doc.data();
            if (userData.newsletter === true || userData.newsletter === "true" || userData.newsletter === 1) {
              subscribers.push(userData.email || "");
            }
          });

          // Utwórz plik CSV z adresami email
          const csvContent = "data:text/csv;charset=utf-8," + subscribers.join("\n");
          const encodedUri = encodeURI(csvContent);
          const link = document.createElement("a");
          link.setAttribute("href", encodedUri);
          link.setAttribute("download", `newsletter_subscribers_${new Date().toISOString().split('T')[0]}.csv`);
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);

          showNotification(`Eksportowano ${subscribers.length} adresów email do pliku CSV.`, "success");
        } catch (error) {
          console.error("Error exporting newsletter:", error);
          showNotification("Błąd podczas eksportu.", "error");
        }
      };

      window.insertLink = function() {
        const url = prompt("Wprowadź URL linku:");
        const text = prompt("Wprowadź tekst linku (lub pozostaw puste, aby użyć URL):");
        if (url) {
          const linkText = text || url;
          document.execCommand("createLink", false, url);
          // Jeśli execCommand nie zadziała, wstaw ręcznie
          const selection = window.getSelection();
          if (selection.rangeCount > 0) {
            const range = selection.getRangeAt(0);
            const a = document.createElement("a");
            a.href = url;
            a.textContent = linkText;
            a.target = "_blank";
            range.deleteContents();
            range.insertNode(a);
          }
        }
      };

      // Szczegóły użytkownika
      window.viewUserDetails = async (userId) => {
        try {
          let user;

          const userDoc = await getDoc(doc(db, "userProfiles", userId));
          if (!userDoc.exists()) return;
          user = { id: userId, ...userDoc.data() };

          currentEditingUser = user;

          // Blokuj przewijanie strony w tle
          document.body.style.overflow = 'hidden';

          // Pokaż modal
          document.getElementById("user-details-modal").classList.remove("hidden");
          
          // Załaduj szczegóły
          loadUserDetails();
        } catch (error) {
          console.error("Error loading user details:", error);
          showNotification("Błąd ładowania szczegółów użytkownika.", "error");
        }
      };

      window.closeUserDetails = () => {
        document.getElementById("user-details-modal").classList.add("hidden");
        currentEditingUser = null; // Czyścimy tylko gdy zamykamy szczegóły użytkownika
        // Odblokuj przewijanie strony
        document.body.style.overflow = '';
      };

      window.openChatFromUserDetails = () => {
        if (!currentEditingUser) return;
        // Wiadomości są teraz dostępne przez floating widget
        closeUserDetails();
        showNotification("Użyj floating widget wiadomości (prawy dolny róg) do komunikacji z użytkownikiem", "info");
      };

      window.switchUserTab = (tabName) => {
        document.querySelectorAll(".user-tab-btn").forEach((btn) => {
          btn.classList.remove("active", "bg-coyote", "text-black");
          btn.classList.add("text-zinc-400");
        });
        document
          .querySelector(`[data-tab="${tabName}"]`)
          .classList.add("active", "bg-coyote", "text-black");

        if (tabName === "activity") {
          loadUserActivity();
        } else if (tabName === "details") {
          loadUserDetails();
        }
      };

      async function loadUserDetails() {
        if (!currentEditingUser) return;

        // Przycisk edycji zawsze widoczny
        const editButton = document.querySelector(
          '[onclick="editUserDetails()"]',
        );
        if (editButton) {
          editButton.style.display = "inline-block";
        }

        // Sprawdź czy można resetować hasło (nie dla aktualnie zalogowanego użytkownika)
        const canResetPassword = currentUser && currentEditingUser.id !== currentUser.uid;

        const decryptedUser = {
          ...currentEditingUser,
          phone: currentEditingUser.phone
            ? atob(currentEditingUser.phone)
            : "",
          parcelLocker: currentEditingUser.parcelLocker
            ? atob(currentEditingUser.parcelLocker)
            : "",
          address: {
            street: currentEditingUser.address?.street
              ? atob(currentEditingUser.address.street)
              : "",
            buildingNumber: currentEditingUser.address?.buildingNumber
              ? atob(currentEditingUser.address.buildingNumber)
              : "",
            postalCode: currentEditingUser.address?.postalCode
              ? atob(currentEditingUser.address.postalCode)
              : "",
            city: currentEditingUser.address?.city
              ? atob(currentEditingUser.address.city)
              : "",
          },
        };

        const detailsHtml = `
                  <div class="space-y-6">
                      <!-- Informacje podstawowe -->
                      <div class="bg-zinc-800/50 rounded-lg p-6 border border-zinc-700">
                          <div class="flex items-center space-x-2 mb-4">
                              <i class="fa-solid fa-user text-coyote"></i>
                              <h3 class="text-lg font-bold text-white">Dane użytkownika</h3>
                          </div>
                          <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                              <div class="bg-zinc-900/50 p-3 rounded border border-zinc-700/50">
                                  <label class="text-xs text-zinc-400 block mb-1 uppercase tracking-wider">Nazwa wyświetlana</label>
                                  <div class="text-white font-semibold text-base">${decryptedUser.displayName || "Brak"}</div>
                              </div>
                              <div class="bg-zinc-900/50 p-3 rounded border border-zinc-700/50">
                                  <label class="text-xs text-zinc-400 block mb-1 uppercase tracking-wider">Email</label>
                                  <div class="text-white font-semibold text-base">${decryptedUser.email || "Brak"}</div>
                              </div>
                              <div class="bg-zinc-900/50 p-3 rounded border border-zinc-700/50">
                                  <label class="text-xs text-zinc-400 block mb-1 uppercase tracking-wider">Telefon</label>
                                  <div class="text-white font-semibold text-base">${decryptedUser.phone || "Brak"}</div>
                              </div>
                              <div class="bg-zinc-900/50 p-3 rounded border border-zinc-700/50">
                                  <label class="text-xs text-zinc-400 block mb-1 uppercase tracking-wider">Data rejestracji</label>
                                  <div class="text-white font-semibold text-base">${new Date(decryptedUser.createdAt?.toDate?.() || decryptedUser.createdAt).toLocaleDateString("pl-PL")}</div>
                              </div>
                          </div>
                      </div>

                      <!-- Rola i status -->
                      <div class="bg-zinc-800/50 rounded-lg p-6 border border-zinc-700">
                          <div class="flex items-center space-x-2 mb-4">
                              <i class="fa-solid fa-shield-halved text-coyote"></i>
                              <h3 class="text-lg font-bold text-white">Uprawnienia i status</h3>
                          </div>
                          <div class="space-y-4">
                          <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                  <div class="bg-zinc-900/50 p-4 rounded border border-zinc-700/50">
                                      <label class="text-xs text-zinc-400 block mb-2 uppercase tracking-wider">Rola użytkownika</label>
                                      <select id="user-role-select" class="w-full" onchange="changeUserRoleFromDetails('${currentEditingUser.id}', this.value)">
                                          <option value="user" ${decryptedUser.role === "user" ? "selected" : ""}>Użytkownik</option>
                                          <option value="company" ${decryptedUser.role === "company" ? "selected" : ""}>Firma</option>
                                          <option value="admin" ${decryptedUser.role === "admin" ? "selected" : ""}>Administrator</option>
                                      </select>
                              </div>
                                  <div class="bg-zinc-900/50 p-4 rounded border border-zinc-700/50">
                                      <label class="text-xs text-zinc-400 block mb-2 uppercase tracking-wider">Status konta</label>
                                      <div class="text-lg font-semibold">
                                          ${decryptedUser.status === "blocked" ? '<span class="inline-flex items-center px-3 py-1 rounded-full bg-red-900/30 text-red-400 border border-red-700"><i class="fa-solid fa-ban mr-2"></i>Zablokowane</span>' : 
                                            decryptedUser.status === "active" ? '<span class="inline-flex items-center px-3 py-1 rounded-full bg-green-900/30 text-green-400 border border-green-700"><i class="fa-solid fa-check-circle mr-2"></i>Aktywne</span>' : 
                                            '<span class="inline-flex items-center px-3 py-1 rounded-full bg-yellow-900/30 text-yellow-400 border border-yellow-700"><i class="fa-solid fa-pause-circle mr-2"></i>Nieaktywne</span>'}
                              </div>
                                      ${decryptedUser.status === "blocked" ? (() => {
                                        const blockedUntilText = getBlockedUntilText(currentEditingUser);
                                        return blockedUntilText ? `<div class="mt-3 text-sm text-red-400 font-semibold"><i class="fa-solid fa-clock mr-2"></i>${blockedUntilText}</div>` : '';
                                      })() : ''}
                              </div>
                              </div>
                              ${canResetPassword ? `
                              <div class="bg-zinc-900/50 p-4 rounded border border-zinc-700/50">
                                  <label class="text-xs text-zinc-400 block mb-2 uppercase tracking-wider">Zarządzanie hasłem</label>
                                  <button onclick="resetUserPassword('${currentEditingUser.id}', '${decryptedUser.email}')" class="text-orange-400 hover:text-orange-300 px-4 py-2 border border-orange-400 rounded text-sm transition-colors">
                                      <i class="fa-solid fa-key mr-2"></i>Reset hasła
                                  </button>
                              </div>
                              ` : ''}
                          </div>
                      </div>

                      <!-- Adres -->
                      <div class="bg-zinc-800/50 rounded-lg p-6 border border-zinc-700">
                          <div class="flex items-center space-x-2 mb-4">
                              <i class="fa-solid fa-location-dot text-coyote"></i>
                              <h3 class="text-lg font-bold text-white">Adres dostawy</h3>
                              </div>
                          <div class="bg-zinc-900/50 p-4 rounded border border-zinc-700/50">
                              ${decryptedUser.address.street || decryptedUser.address.buildingNumber || decryptedUser.address.postalCode || decryptedUser.address.city || decryptedUser.parcelLocker ? 
                                `<div class="space-y-2 text-sm">
                                    ${decryptedUser.address.street || decryptedUser.address.buildingNumber ? 
                                      `<div class="text-white font-medium">
                                          <i class="fa-solid fa-road text-zinc-400 mr-2"></i>
                                          ${decryptedUser.address.street || ""} ${decryptedUser.address.buildingNumber || ""}
                                      </div>` : ''}
                                    ${decryptedUser.address.postalCode || decryptedUser.address.city ? 
                                      `<div class="text-white font-medium">
                                          <i class="fa-solid fa-city text-zinc-400 mr-2"></i>
                                          ${decryptedUser.address.postalCode || ""} ${decryptedUser.address.city || ""}
                                      </div>` : ''}
                                    ${decryptedUser.parcelLocker ? 
                                      `<div class="text-white font-medium">
                                          <i class="fa-solid fa-box text-zinc-400 mr-2"></i>
                                          Paczkomat: ${decryptedUser.parcelLocker}
                                      </div>` : ''}
                                </div>` : 
                                '<div class="text-zinc-400 italic">Brak adresu</div>'}
                          </div>
                      </div>
                  </div>
              `;

        document.getElementById("user-details-content").innerHTML = detailsHtml;
      }

      window.editUserDetails = () => {
        showUserEditModal();
      };

      async function loadUserActivity() {
        if (!currentEditingUser) return;

        try {
          document.getElementById("user-details-content").innerHTML = `
            <div class="text-center text-zinc-500 py-8">
              <i class="fa-solid fa-spinner fa-spin fa-3x mb-4"></i>
              <p>Ładowanie historii aktywności...</p>
            </div>
          `;

          // Pobierz aktywność użytkownika
          const q = query(
            collection(db, "activityLogs"),
            where("userId", "==", currentEditingUser.id),
            orderBy("timestamp", "desc"),
            limit(50),
          );

          const snapshot = await getDocs(q);
          const activities = snapshot.docs.map((doc) => ({
            id: doc.id,
            ...doc.data(),
          }));

          // Pobierz także aktywność gdzie użytkownik jest celem (np. został zablokowany przez admina)
          const targetQuery = query(
            collection(db, "activityLogs"),
            where("targetUserId", "==", currentEditingUser.id),
            orderBy("timestamp", "desc"),
            limit(50),
          );

          const targetSnapshot = await getDocs(targetQuery);
          const targetActivities = targetSnapshot.docs.map((doc) => ({
            id: doc.id,
            ...doc.data(),
          }));

          // Połącz i posortuj wszystkie aktywności
          const allActivities = [...activities, ...targetActivities]
            .sort((a, b) => b.timestamp.toDate() - a.timestamp.toDate())
            .slice(0, 50); // Ogranicz do 50 najnowszych

          renderUserActivity(allActivities);
        } catch (error) {
          console.error("Error loading user activity:", error);
          document.getElementById("user-details-content").innerHTML = `
            <div class="text-center text-red-400 py-8">
              <i class="fa-solid fa-exclamation-triangle fa-3x mb-4"></i>
              <p>Błąd ładowania historii aktywności</p>
              <p class="text-sm">${error.message}</p>
            </div>
          `;
        }
      }

      function renderUserActivity(activities) {
        if (activities.length === 0) {
          document.getElementById("user-details-content").innerHTML = `
            <div class="text-center text-zinc-500 py-8">
              <i class="fa-solid fa-inbox fa-3x mb-4"></i>
              <p>Brak zarejestrowanej aktywności</p>
              <p class="text-sm">Historia aktywności użytkownika pojawi się tutaj po wykonaniu jakichkolwiek działań.</p>
            </div>
          `;
          return;
        }

        const activityHtml = activities
          .map((activity) => {
            const timestamp = activity.timestamp.toDate();
            const timeAgo = getTimeAgo(timestamp);

            // Ikony dla różnych typów aktywności
            const activityIcons = {
              ROLE_CHANGE: "fa-user-tag",
              PASSWORD_RESET_REQUEST: "fa-key",
              USER_BLOCKED: "fa-ban",
              USER_UNBLOCKED: "fa-unlock",
              USER_DELETED: "fa-trash",
              PROFILE_EDITED: "fa-edit",
              LOGIN: "fa-sign-in-alt",
              LOGOUT: "fa-sign-out-alt",
              MESSAGE_SENT: "fa-comment",
              PRODUCT_ADDED: "fa-plus-circle",
              PRODUCT_EDITED: "fa-edit",
              LIKE_ADDED: "fa-heart",
              COMMENT_ADDED: "fa-comment-dots",
            };

            const iconClass = activityIcons[activity.action] || "fa-circle";

            // Kolory dla różnych typów aktywności
            const activityColors = {
              USER_BLOCKED: "text-red-400",
              USER_UNBLOCKED: "text-green-400",
              USER_DELETED: "text-red-600",
              ROLE_CHANGE: "text-blue-400",
              PASSWORD_RESET_REQUEST: "text-orange-400",
              PROFILE_EDITED: "text-purple-400",
            };

            const colorClass =
              activityColors[activity.action] || "text-zinc-400";

            // Sprawdź czy użytkownik jest wykonawcą czy celem zdarzenia
            const isTarget = activity.targetUserId && activity.targetUserId === currentEditingUser.id;
            const isPerformer = activity.userId === currentEditingUser.id;

            // Opis aktywności
            let description = "";
            switch (activity.action) {
              case "ROLE_CHANGE":
                description = `Zmiana roli z ${activity.details.oldRole?.toUpperCase() || "BRAK"} na ${activity.details.newRole?.toUpperCase() || "BRAK"}`;
                break;
              case "PASSWORD_RESET_REQUEST":
                description = "Wysłano link resetowania hasła";
                break;
              case "USER_BLOCKED":
                if (isPerformer) {
                  // Użytkownik jest wykonawcą (admin zablokował kogoś)
                  if (activity.details.isPermanent) {
                    description = "Zablokował konto na zawsze";
                  } else {
                    description = `Zablokował konto na ${activity.details.duration}`;
                  }
                } else if (isTarget) {
                  // Użytkownik jest celem (został zablokowany)
                  if (activity.details.isPermanent) {
                    description = "Konto zostało zablokowane na zawsze";
                  } else {
                    description = `Konto zostało zablokowane na ${activity.details.duration}`;
                  }
                } else {
                  // Fallback dla innych przypadków
                  if (activity.details.isPermanent) {
                    description = "Konto zablokowane na zawsze";
                  } else {
                    description = `Konto zablokowane na ${activity.details.duration}`;
                  }
                }
                if (activity.details.contentAction === "remove") {
                  description += " (zawartość usunięta)";
                }
                break;
              case "USER_UNBLOCKED":
                if (isPerformer) {
                  description = "Odblokował konto";
                } else if (isTarget) {
                  description = "Konto zostało odblokowane";
                } else {
                  description = "Konto odblokowane";
                }
                break;
              case "USER_DELETED":
                if (isPerformer) {
                  description = `Usunął konto${activity.details.contentAction === "keep" ? " (zawartość zachowana)" : " (zawartość usunięta)"}`;
                } else if (isTarget) {
                  description = `Konto zostało usunięte${activity.details.contentAction === "keep" ? " (zawartość zachowana)" : " (zawartość usunięta)"}`;
                } else {
                  description = `Konto usunięte${activity.details.contentAction === "keep" ? " (zawartość zachowana)" : " (zawartość usunięta)"}`;
                }
                break;
              case "PROFILE_EDITED":
                description = `Edycja profilu (${activity.details.changes?.join(", ") || "nieznane zmiany"})`;
                break;
              default:
                description = activity.action.replace(/_/g, " ").toLowerCase();
            }

            // Szczegóły wykonawcy (tylko gdy użytkownik jest celem, a nie wykonawcą)
            let performedBy = "";
            if (isTarget && activity.adminId && activity.adminId !== currentEditingUser.id) {
              performedBy = " przez administratora";
            }

            return `
            <div class="flex items-start space-x-3 p-4 bg-zinc-800 rounded-lg mb-3">
              <div class="${colorClass} mt-1">
                <i class="fa-solid ${iconClass}"></i>
              </div>
              <div class="flex-1">
                <div class="flex justify-between items-start">
                  <div class="font-semibold ${colorClass}">${activity.action.replace(/_/g, " ")}</div>
                  <div class="text-xs text-zinc-500">${timeAgo}</div>
                </div>
                <div class="text-sm text-zinc-300 mt-1">${description}${performedBy}</div>
                <div class="text-xs text-zinc-500 mt-1">
                  ${timestamp.toLocaleString("pl-PL")}
                </div>
              </div>
            </div>
          `;
          })
          .join("");

        document.getElementById("user-details-content").innerHTML = `
          <div class="mb-4">
            <h3 class="text-lg font-bold mb-4">Historia Aktywności</h3>
            <p class="text-sm text-zinc-400 mb-4">Pokaż ostatnie 50 działań użytkownika</p>
          </div>
          <div class="space-y-1 max-h-[500px] overflow-y-auto">
            ${activityHtml}
          </div>
        `;
      }

      // Zmienna globalna do przechowywania aktualnie edytowanego użytkownika
      let currentEditingUser = null;

      function showUserEditModal() {
        if (!currentEditingUser) return;

        const decryptedUser = {
          ...currentEditingUser,
          phone: currentEditingUser.phone
            ? atob(currentEditingUser.phone)
            : "",
          parcelLocker: currentEditingUser.parcelLocker
            ? atob(currentEditingUser.parcelLocker)
            : "",
          address: {
            street: currentEditingUser.address?.street
              ? atob(currentEditingUser.address.street)
              : "",
            buildingNumber: currentEditingUser.address?.buildingNumber
              ? atob(currentEditingUser.address.buildingNumber)
              : "",
            postalCode: currentEditingUser.address?.postalCode
              ? atob(currentEditingUser.address.postalCode)
              : "",
            city: currentEditingUser.address?.city
              ? atob(currentEditingUser.address.city)
              : "",
          },
        };

        // Wypełnij formularz danymi użytkownika
        document.getElementById("edit-user-id").value = decryptedUser.id;
        document.getElementById("edit-display-name").value =
          decryptedUser.displayName || "";
        document.getElementById("edit-email").value = decryptedUser.email || "";
        document.getElementById("edit-first-name").value =
          decryptedUser.firstName || "";
        document.getElementById("edit-last-name").value =
          decryptedUser.lastName || "";
        document.getElementById("edit-phone").value = decryptedUser.phone || "";
        document.getElementById("edit-street").value =
          decryptedUser.address?.street || "";
        document.getElementById("edit-building-number").value =
          decryptedUser.address?.buildingNumber || "";
        document.getElementById("edit-postal-code").value =
          decryptedUser.address?.postalCode || "";
        document.getElementById("edit-city").value =
          decryptedUser.address?.city || "";
        document.getElementById("edit-parcel-locker").value =
          decryptedUser.parcelLocker || "";
        document.getElementById("edit-newsletter").checked =
          decryptedUser.newsletter || false;
        document.getElementById("edit-role").value =
          decryptedUser.role || "user";
        document.getElementById("edit-status").value =
          decryptedUser.status || "active";

        document.getElementById("user-edit-modal").classList.remove("hidden");
      }

      window.closeUserEdit = () => {
        document.getElementById("user-edit-modal").classList.add("hidden");
        // Nie czyścimy currentEditingUser, bo użytkownik może nadal być w szczegółach
      };

      // Zmienna globalna dla blokowanego użytkownika
      let currentBlockingUser = null;

      // ==================== FUNKCJE ZARZĄDZANIA SZYBKIMI ODPOWIEDZIAMI ====================

      // Zmienna globalna dla edytowanego szablonu
      let currentEditingQuickReply = null;

      // Funkcja ładowania listy szablonów odpowiedzi
      async function loadQuickReplies() {
        const container = document.getElementById('quick-replies-list');
        if (!container) return;

        container.innerHTML = `
          <div class="text-center text-zinc-500 py-8">
            <i class="fa-solid fa-spinner fa-spin text-2xl mb-4 text-zinc-600"></i>
            <h4 class="text-lg font-semibold mb-2">Ładowanie szablonów...</h4>
            <p class="text-sm">Proszę czekać</p>
          </div>
        `;

        try {
          // Pobierz quick replies bezpośrednio z Firestore
          const quickRepliesRef = collection(db, 'quickReplies');
          const q = query(quickRepliesRef, orderBy('createdAt', 'desc'));
          const querySnapshot = await getDocs(q);

          const quickReplies = [];
          querySnapshot.forEach((doc) => {
            quickReplies.push({
              id: doc.id,
              ...doc.data(),
              createdAt: doc.data().createdAt?.toDate?.()?.getTime() || doc.data().createdAt
            });
          });

          displayQuickReplies(quickReplies);
        } catch (error) {
          console.error('Error loading quick replies:', error);
          container.innerHTML = `
            <div class="text-center text-red-400 py-8">
              <i class="fa-solid fa-exclamation-triangle text-2xl mb-4"></i>
              <h4 class="text-lg font-semibold mb-2">Błąd ładowania szablonów</h4>
              <p class="text-sm">Spróbuj odświeżyć stronę</p>
            </div>
          `;
        }
      }

      // Funkcja wyświetlania listy szablonów
      function displayQuickReplies(replies) {
        const container = document.getElementById('quick-replies-list');
        if (!container) return;

        if (replies.length === 0) {
          container.innerHTML = `
            <div class="text-center text-zinc-500 py-12">
              <i class="fa-solid fa-inbox text-3xl mb-4 text-zinc-600"></i>
              <h4 class="text-lg font-semibold mb-2">Brak szablonów odpowiedzi</h4>
              <p class="text-sm mb-4">Nie masz jeszcze żadnych szablonów szybkich odpowiedzi</p>
              <button onclick="openQuickReplyModal()" class="btn-admin">
                <i class="fa-solid fa-plus mr-2"></i>
                Utwórz pierwszy szablon
              </button>
            </div>
          `;
          return;
        }

        const repliesHtml = replies.map(reply => `
          <div class="bg-zinc-800 border border-zinc-700 rounded-lg p-4 hover:bg-zinc-750 transition">
            <div class="flex justify-between items-start mb-3">
              <h4 class="font-semibold text-white">${reply.title}</h4>
              <div class="flex space-x-2">
                <button
                  onclick="editQuickReply(${reply.id})"
                  class="text-blue-400 hover:text-blue-300 transition"
                  title="Edytuj"
                >
                  <i class="fa-solid fa-edit"></i>
                </button>
                <button
                  onclick="deleteQuickReply(${reply.id})"
                  class="text-red-400 hover:text-red-300 transition"
                  title="Usuń"
                >
                  <i class="fa-solid fa-trash"></i>
                </button>
              </div>
            </div>
            <div class="text-zinc-300 text-sm leading-relaxed">
              ${reply.content.length > 150 ? reply.content.substring(0, 150) + '...' : reply.content}
            </div>
            <div class="text-xs text-zinc-500 mt-2">
              Zaktualizowano: ${new Date(reply.updated_at).toLocaleDateString('pl-PL')}
            </div>
          </div>
        `).join('');

        container.innerHTML = repliesHtml;
      }

      // Funkcja otwierania modala szybkich odpowiedzi
      window.openQuickReplyModal = (replyId = null) => {
        currentEditingQuickReply = replyId;
        const modal = document.getElementById('quick-reply-modal');
        const title = document.getElementById('quick-reply-modal-title');
        const form = document.getElementById('quick-reply-form');
        const submitText = document.getElementById('quick-reply-submit-text');

        if (replyId) {
          title.textContent = 'Edycja szablonu odpowiedzi';
          submitText.textContent = 'Aktualizuj szablon';
          // Załaduj dane szablonu do edycji
          loadQuickReplyForEdit(replyId);
        } else {
          title.textContent = 'Nowy szablon odpowiedzi';
          submitText.textContent = 'Zapisz szablon';
          form.reset();
          document.getElementById('quick-reply-id').value = '';
        }

        modal.classList.remove('hidden');
      };

      // Funkcja zamykania modala szybkich odpowiedzi
      window.closeQuickReplyModal = () => {
        document.getElementById('quick-reply-modal').classList.add('hidden');
        document.getElementById('quick-reply-form').reset();
        currentEditingQuickReply = null;
      };

      // Funkcja ładowania szablonu do edycji
      async function loadQuickReplyForEdit(replyId) {
        try {
          // Pobierz konkretny quick reply z Firestore
          const replyRef = doc(db, 'quickReplies', replyId);
          const replyDoc = await getDoc(replyRef);

          if (replyDoc.exists()) {
            const reply = { id: replyDoc.id, ...replyDoc.data() };
            document.getElementById('quick-reply-id').value = reply.id;
            document.getElementById('quick-reply-title').value = reply.title;
            document.getElementById('quick-reply-content').value = reply.content;
          }
        } catch (error) {
          console.error('Error loading quick reply for edit:', error);
          showNotification('Błąd podczas ładowania szablonu', 'error');
        }
      }

      // Funkcja edycji szablonu
      window.editQuickReply = (replyId) => {
        openQuickReplyModal(replyId);
      };

      // Funkcja usuwania szablonu
      window.deleteQuickReply = async (replyId) => {
        if (!confirm('Czy na pewno chcesz usunąć ten szablon odpowiedzi?')) {
          return;
        }

        try {
          // Usuń quick reply bezpośrednio z Firestore
          const replyRef = doc(db, 'quickReplies', replyId);
          await deleteDoc(replyRef);
          showNotification('Szablon został usunięty', 'success');
          loadQuickReplies();
        } catch (error) {
          console.error('Error deleting quick reply:', error);
          showNotification('Błąd podczas usuwania szablonu', 'error');
        }
      };

      // Funkcja otwierania dropdown menu szybkich odpowiedzi
      window.openQuickRepliesMenu = async () => {
        const dropdown = document.getElementById('quick-replies-dropdown');
        const boltBtn = document.querySelector('[onclick="openQuickRepliesMenu()"]');

        // Pozycjonowanie dropdown obok przycisku
        const rect = boltBtn.getBoundingClientRect();
        dropdown.style.left = `${rect.left - 200}px`; // Przesuń w lewo o szerokość dropdown
        dropdown.style.top = `${rect.top - 320}px`; // Przesuń w górę

        // Załaduj szablony jeśli dropdown jest ukryty
        if (dropdown.classList.contains('hidden')) {
          await loadQuickRepliesForDropdown();
        }

        // Przełącz widoczność
        dropdown.classList.toggle('hidden');

        // Zamknij dropdown przy kliknięciu poza nim
        setTimeout(() => {
          document.addEventListener('click', closeQuickRepliesMenuOnClickOutside);
        }, 10);
      };

      // Funkcja ładowania szablonów do dropdown
      async function loadQuickRepliesForDropdown() {
        const container = document.getElementById('quick-replies-dropdown-list');

        try {
          // Pobierz quick replies bezpośrednio z Firestore
          const quickRepliesRef = collection(db, 'quickReplies');
          const q = query(quickRepliesRef, orderBy('createdAt', 'desc'));
          const querySnapshot = await getDocs(q);

          const quickReplies = [];
          querySnapshot.forEach((doc) => {
            quickReplies.push({
              id: doc.id,
              ...doc.data()
            });
          });

          displayQuickRepliesInDropdown(quickReplies);
        } catch (error) {
          console.error('Error loading quick replies for dropdown:', error);
          container.innerHTML = `
            <div class="text-center text-red-400 py-4">
              <i class="fa-solid fa-exclamation-triangle text-sm mb-2"></i>
              <div class="text-xs">Błąd ładowania</div>
            </div>
          `;
        }
      }

      // Funkcja wyświetlania szablonów w dropdown
      function displayQuickRepliesInDropdown(replies) {
        const container = document.getElementById('quick-replies-dropdown-list');

        if (replies.length === 0) {
          container.innerHTML = `
            <div class="text-center text-zinc-500 py-4">
              <div class="text-xs">Brak szablonów</div>
              <button onclick="closeQuickRepliesMenuAndOpenModal()" class="text-xs text-blue-400 hover:text-blue-300 mt-1">
                Utwórz szablon
              </button>
            </div>
          `;
          return;
        }

        const repliesHtml = replies.map(reply => `
          <button
            onclick="useQuickReply('${reply.content.replace(/'/g, "\\'").replace(/\n/g, '\\n')}')"
            class="w-full text-left px-3 py-2 text-sm text-zinc-300 hover:bg-zinc-700 rounded transition"
            title="${reply.title}"
          >
            <div class="font-medium text-white truncate">${reply.title}</div>
            <div class="text-xs text-zinc-400 truncate">
              ${reply.content.length > 50 ? reply.content.substring(0, 50) + '...' : reply.content}
            </div>
          </button>
        `).join('');

        container.innerHTML = repliesHtml;
      }

      // Funkcja używania szybkiej odpowiedzi
      window.useQuickReply = (content) => {
        const textarea = document.getElementById('chat-reply-input');
        textarea.value = content.replace(/\\n/g, '\n');
        textarea.focus();

        // Zamknij dropdown
        document.getElementById('quick-replies-dropdown').classList.add('hidden');
        document.removeEventListener('click', closeQuickRepliesMenuOnClickOutside);
      };

      // Funkcja zamykania dropdown przy kliknięciu poza nim
      function closeQuickRepliesMenuOnClickOutside(e) {
        const dropdown = document.getElementById('quick-replies-dropdown');
        const boltBtn = document.querySelector('[onclick="openQuickRepliesMenu()"]');

        if (!dropdown.contains(e.target) && !boltBtn.contains(e.target)) {
          dropdown.classList.add('hidden');
          document.removeEventListener('click', closeQuickRepliesMenuOnClickOutside);
        }
      }

      // Funkcja zamykania dropdown i otwierania modala
      window.closeQuickRepliesMenuAndOpenModal = () => {
        document.getElementById('quick-replies-dropdown').classList.add('hidden');
        document.removeEventListener('click', closeQuickRepliesMenuOnClickOutside);
        openQuickReplyModal();
      };

      // =================== ZARZĄDZANIE KATEGORIAMI ===================

      // Funkcja ładowania kategorii
      async function loadCategories() {
        const container = document.getElementById('categories-list');
        if (!container) return;

        try {
          // Pobierz kategorie bezpośrednio z Firestore
          const categoriesRef = collection(db, 'messageCategories');
          const q = query(categoriesRef, orderBy('name'));
          const querySnapshot = await getDocs(q);

          const categories = [];
          querySnapshot.forEach((doc) => {
            categories.push({
              id: doc.id,
              ...doc.data()
            });
          });

          displayCategories(categories);
        } catch (error) {
          console.error('Error loading categories:', error);
          container.innerHTML = `
            <div class="text-center text-red-400 py-8 col-span-full">
              <i class="fa-solid fa-exclamation-triangle text-2xl mb-4"></i>
              <h4 class="text-lg font-semibold mb-2">Błąd ładowania kategorii</h4>
              <p class="text-sm">Spróbuj odświeżyć stronę</p>
            </div>
          `;
        }
      }

      // Funkcja wyświetlania kategorii
      function displayCategories(categories) {
        const container = document.getElementById('categories-list');
        if (!container) return;

        if (categories.length === 0) {
          container.innerHTML = `
            <div class="text-center text-zinc-500 py-12 col-span-full">
              <i class="fa-solid fa-folder-open text-3xl mb-4 text-zinc-600"></i>
              <h4 class="text-lg font-semibold mb-2">Brak kategorii</h4>
              <p class="text-sm mb-4">Nie masz jeszcze żadnych kategorii wiadomości</p>
              <button onclick="openCategoryModal()" class="btn-admin">
                <i class="fa-solid fa-plus mr-2"></i>
                Utwórz pierwszą kategorię
              </button>
            </div>
          `;
          return;
        }

        const categoriesHtml = categories.map(category => `
          <div class="bg-zinc-800 border border-zinc-700 rounded-lg p-4 hover:bg-zinc-750 transition group">
            <div class="flex items-center justify-between mb-3">
              <div class="flex items-center space-x-3">
                <div class="w-10 h-10 rounded-full flex items-center justify-center" style="background-color: ${category.color}20; border: 2px solid ${category.color};">
                  <i class="fa-solid ${category.icon} text-sm" style="color: ${category.color};"></i>
                </div>
                <div>
                  <h4 class="font-semibold text-white">${category.name}</h4>
                  <div class="text-xs text-zinc-400">ID: ${category.id}</div>
                </div>
              </div>
              <div class="flex space-x-2 opacity-0 group-hover:opacity-100 transition">
                <button
                  onclick="editCategory(${category.id})"
                  class="text-blue-400 hover:text-blue-300 transition"
                  title="Edytuj kategorię"
                >
                  <i class="fa-solid fa-edit"></i>
                </button>
                <button
                  onclick="deleteCategory(${category.id}, '${category.name}')"
                  class="text-red-400 hover:text-red-300 transition"
                  title="Usuń kategorię"
                >
                  <i class="fa-solid fa-trash"></i>
                </button>
              </div>
            </div>
            <div class="text-xs text-zinc-500">
              Kolejność: ${category.sort_order}
            </div>
          </div>
        `).join('');

        container.innerHTML = categoriesHtml;
      }

      // Funkcja otwierania modala kategorii
      window.openCategoryModal = (categoryId = null) => {
        const modal = document.getElementById('category-modal');
        const title = document.getElementById('category-modal-title');
        const form = document.getElementById('category-form');

        if (categoryId) {
          title.textContent = 'Edycja kategorii';
          loadCategoryForEdit(categoryId);
        } else {
          title.textContent = 'Nowa kategoria';
          form.reset();
          document.getElementById('category-id').value = '';
          // Ustaw domyślne wartości
          document.getElementById('category-color').value = '#3B82F6';
          document.getElementById('category-color-text').value = '#3B82F6';
          document.getElementById('category-icon').value = 'fa-circle';
          updateIconSelection('fa-circle');
        }

        modal.classList.remove('hidden');
      };

      // Funkcja zamykania modala kategorii
      window.closeCategoryModal = () => {
        document.getElementById('category-modal').classList.add('hidden');
        document.getElementById('category-form').reset();
      };

      // Funkcja ładowania kategorii do edycji
      async function loadCategoryForEdit(categoryId) {
        try {
          const categoriesRef = collection(db, "messageCategories");
          const querySnapshot = await getDocs(categoriesRef);
          
          const categories = [];
          querySnapshot.forEach((doc) => {
            categories.push({
              id: doc.id,
              ...doc.data()
            });
          });

          const category = categories.find(c => c.id === categoryId);
          if (category) {
            document.getElementById('category-id').value = category.id;
            document.getElementById('category-name').value = category.name;
            document.getElementById('category-color').value = category.color;
            document.getElementById('category-color-text').value = category.color;
            document.getElementById('category-icon').value = category.icon;
            updateIconSelection(category.icon);
          }
        } catch (error) {
          console.error('Error loading category for edit:', error);
          showNotification('Błąd ładowania kategorii do edycji', 'error');
        }
      }

      // Funkcja aktualizacji wyboru ikony
      function updateIconSelection(selectedIcon) {
        document.querySelectorAll('.icon-option').forEach(btn => {
          btn.classList.remove('border-coyote', 'bg-coyote', 'bg-opacity-20');
          btn.classList.add('border-zinc-600');
          if (btn.dataset.icon === selectedIcon) {
            btn.classList.add('border-coyote', 'bg-coyote', 'bg-opacity-20');
          }
        });
      }

      // Funkcja zapisywania kategorii
      window.saveCategory = async (formData) => {
        try {
          const categoryId = document.getElementById('category-id').value;
          const categoryData = {
            name: document.getElementById('category-name').value.trim(),
            color: document.getElementById('category-color').value,
            icon: document.getElementById('category-icon').value
          };

          if (!categoryData.name) {
            showNotification('Nazwa kategorii jest wymagana', 'error');
            return;
          }

          // TODO: Implementacja przez Firebase Firestore
          showNotification('Funkcja zapisywania kategorii wymaga implementacji przez Firebase', 'info');
        } catch (error) {
          console.error('Error saving category:', error);
          showNotification('Błąd zapisywania kategorii', 'error');
        }
      };

      // Funkcja edycji kategorii
      window.editCategory = (categoryId) => {
        openCategoryModal(categoryId);
      };

      // Funkcja usuwania kategorii
      window.deleteCategory = async (categoryId, categoryName) => {
        if (!confirm(`Czy na pewno chcesz usunąć kategorię "${categoryName}"?\n\nWiadomości z tej kategorii zostaną przeniesione do kategorii "Inne".`)) {
          return;
        }

        try {
          // TODO: Implementacja przez Firebase Firestore
          showNotification('Funkcja usuwania kategorii wymaga implementacji przez Firebase', 'info');
        } catch (error) {
          console.error('Error deleting category:', error);
          showNotification('Błąd usuwania kategorii', 'error');
        }
      };

      // Funkcja zapisywania ustawień kontaktu

      // =================== KONIEC ZARZĄDZANIA KATEGORIAMI ===================

      // Funkcje zarządzania użytkownikami
      window.toggleUserBlock = async (userId) => {
        try {
          let user;

          const userDoc = await getDoc(doc(db, "userProfiles", userId));
          if (!userDoc.exists()) return;
          user = { id: userId, ...userDoc.data() };

          currentBlockingUser = user;

          const currentStatus = user.status || "active";

          if (currentStatus === "blocked") {
            // Jeśli użytkownik jest już zablokowany, pokaż opcje odblokowania
            showUserUnblockModal();
          } else {
            // Jeśli użytkownik nie jest zablokowany, pokaż modal blokowania
            showUserBlockModal();
          }
        } catch (error) {
          console.error("Error toggling user block:", error);
          showNotification("Błąd zmiany statusu użytkownika.", "error");
        }
      };

      function showUserBlockModal() {
        if (!currentBlockingUser) return;

        const decryptedUser = {
          ...currentBlockingUser,
          phone: currentBlockingUser.phone
            ? atob(currentBlockingUser.phone)
            : "",
          address: {
            city: currentBlockingUser.address?.city
              ? atob(currentBlockingUser.address.city)
              : "",
          },
        };

        document.getElementById("block-user-info").innerHTML = `
          <div class="space-y-3">
            <div class="flex items-center space-x-3">
              <div class="font-bold text-lg text-white">${decryptedUser.displayName || "Brak nazwy"}</div>
          </div>
            <div class="text-sm text-zinc-200">${decryptedUser.email || "Brak emaila"}</div>
            <div class="text-sm text-zinc-300">
              ${decryptedUser.address?.city ? `Miasto: ${decryptedUser.address.city}` : "Brak adresu"}
            ${decryptedUser.phone ? ` • Tel: ${decryptedUser.phone}` : ""}
            </div>
          </div>
        `;

        document.getElementById("block-user-id").value = decryptedUser.id;
        document.getElementById("user-block-modal").classList.remove("hidden");
      }

      function showUserUnblockModal() {
        if (!currentBlockingUser) return;

        const confirmUnblock = confirm(
          `Czy na pewno chcesz odblokować użytkownika ${currentBlockingUser.displayName}?\n\nUżytkownik odzyska dostęp do wszystkich funkcji strony.`,
        );

        if (confirmUnblock) {
          unblockUser(currentBlockingUser.id);
        }
      }

      async function unblockUser(userId, isAutomatic = false) {
        try {
          const updateData = {
            status: "active",
            unblockedAt: new Date(),
            blockedUntil: null,
            blockDuration: null,
            isPermanentBlock: null,
          };
          
          // Jeśli nie jest automatyczne, dodaj informację o tym kto odblokował
          if (!isAutomatic && currentUser) {
            updateData.unblockedBy = currentUser.uid;
          }

          await updateDoc(doc(db, "userProfiles", userId), updateData);

          // Zaloguj odblokowanie użytkownika
          if (!isAutomatic && currentUser?.uid) {
            // Pobierz email administratora dla logowania
            let adminEmail = currentUser.email || null;
            if (!adminEmail) {
              try {
                const adminDoc = await getDoc(doc(db, "userProfiles", currentUser.uid));
                if (adminDoc.exists()) {
                  const adminData = adminDoc.data();
                  adminEmail = adminData.email || null;
                }
              } catch (e) {
                console.warn("Nie udało się pobrać emaila administratora:", e);
              }
            }
            
            await logActivity(
              currentUser.uid, 
              "USER_UNBLOCKED", 
              {
            unblockedBy: currentUser.uid,
                automatic: false,
                targetUser: userId,
                adminEmail: adminEmail, // Email administratora dla wyświetlania
              },
              userId
            );
          } else if (isAutomatic) {
            // Automatyczne odblokowanie
            await logActivity(
              "system", 
              "USER_UNBLOCKED", 
              {
                unblockedBy: "system",
                automatic: true,
                reason: "Blokada wygasła automatycznie",
                targetUser: userId,
              },
              userId
            );
          }

          if (!isAutomatic) {
          showNotification("Użytkownik został odblokowany.");
          }
          loadUsers();
        } catch (error) {
          console.error("Error unblocking user:", error);
          if (!isAutomatic) {
          showNotification("Błąd podczas odblokowywania użytkownika.", "error");
          }
        }
      }

      // Funkcja automatycznie odblokowująca wygasłe blokady
      async function autoUnblockExpiredBlocks() {
        try {
          const usersSnapshot = await getDocs(collection(db, "userProfiles"));
          const now = new Date();
          let unblockedCount = 0;
          const unblockedUsers = []; // Lista użytkowników do zalogowania (dla ostatniego batcha)

          let batch = writeBatch(db);
          let batchCount = 0;
          const BATCH_LIMIT = 500; // Firestore limit
          let currentBatchUsers = []; // Użytkownicy w aktualnym batchu

          for (const docSnapshot of usersSnapshot.docs) {
            const userData = docSnapshot.data();
            
            // Sprawdź czy użytkownik jest zablokowany i ma czasową blokadę
            if (userData.status === "blocked" && userData.blockedUntil && !userData.isPermanentBlock) {
              const blockedUntil = userData.blockedUntil.toDate ? userData.blockedUntil.toDate() : new Date(userData.blockedUntil);
              
              // Jeśli blokada wygasła, odblokuj
              if (blockedUntil <= now) {
                const userRef = doc(db, "userProfiles", docSnapshot.id);
                batch.update(userRef, {
                  status: "active",
                  unblockedAt: new Date(),
                  blockedUntil: null,
                  blockDuration: null,
                  isPermanentBlock: null,
                });
                batchCount++;
                unblockedCount++;
                
                // Zapisz ID użytkownika do zalogowania
                currentBatchUsers.push(docSnapshot.id);

                // Jeśli osiągnięto limit batcha, wykonaj i zacznij nowy
                if (batchCount >= BATCH_LIMIT) {
                  await batch.commit();
                  
                  // Zaloguj odblokowania z tego batcha natychmiast po commit
                  for (const userId of currentBatchUsers) {
                    try {
                      await logActivity("system", "USER_UNBLOCKED", {
                        unblockedBy: "system",
                        automatic: true,
                        reason: "Blokada wygasła automatycznie",
                        targetUser: userId,
                      }, userId);
                    } catch (logError) {
                      console.error(`Błąd podczas logowania automatycznego odblokowania dla użytkownika ${userId}:`, logError);
                    }
                  }
                  
                  // Rozpocznij nowy batch
                  batch = writeBatch(db);
                  batchCount = 0;
                  currentBatchUsers = [];
                }
              }
            }
          }

          // Wykonaj pozostałe operacje
          if (batchCount > 0) {
            await batch.commit();
            
            // Zaloguj odblokowania z ostatniego batcha natychmiast po commit
            for (const userId of currentBatchUsers) {
              try {
                await logActivity("system", "USER_UNBLOCKED", {
                  unblockedBy: "system",
                  automatic: true,
                  reason: "Blokada wygasła automatycznie",
                  targetUser: userId,
                }, userId);
              } catch (logError) {
                console.error(`Błąd podczas logowania automatycznego odblokowania dla użytkownika ${userId}:`, logError);
              }
            }
          }

          // Podsumowanie
          if (unblockedCount > 0) {
            console.log(`Automatycznie odblokowano ${unblockedCount} wygasłych blokad.`);
          }

          return unblockedCount;
        } catch (error) {
          console.error("Błąd podczas automatycznego odblokowywania wygasłych blokad:", error);
          return 0;
        }
      }

      window.closeUserBlock = () => {
        document.getElementById("user-block-modal").classList.add("hidden");
        const blockReasonEl = document.getElementById("block-reason");
        if (blockReasonEl) blockReasonEl.value = "";
        currentBlockingUser = null;
      };

      function showUserDeleteModal() {
        if (!currentDeletingUser) return;

        const decryptedUser = {
          ...currentDeletingUser,
          phone: currentDeletingUser.phone
            ? atob(currentDeletingUser.phone)
            : "",
          address: {
            city: currentDeletingUser.address?.city
              ? atob(currentDeletingUser.address.city)
              : "",
          },
        };

        document.getElementById("delete-user-info").innerHTML = `
          <div class="space-y-3">
            <div class="flex items-center space-x-3">
              <div class="font-bold text-lg text-white">${decryptedUser.displayName || "Brak nazwy"}</div>
          </div>
            <div class="text-sm text-zinc-200">${decryptedUser.email || "Brak emaila"}</div>
            <div class="text-sm text-zinc-300">
              ${decryptedUser.address?.city ? `Miasto: ${decryptedUser.address.city}` : "Brak adresu"}
            ${decryptedUser.phone ? ` • Tel: ${decryptedUser.phone}` : ""}
          </div>
            <div class="text-sm text-zinc-400 pt-2 border-t border-zinc-700">
            Konto utworzone: ${new Date(decryptedUser.createdAt?.toDate?.() || decryptedUser.createdAt).toLocaleDateString("pl-PL")}
            </div>
          </div>
        `;

        document.getElementById("delete-user-id").value = decryptedUser.id;
        
        // Blokuj przewijanie strony w tle
        document.body.style.overflow = 'hidden';
        
        document.getElementById("user-delete-modal").classList.remove("hidden");
      }

      window.closeUserDelete = () => {
        document.getElementById("user-delete-modal").classList.add("hidden");
        currentDeletingUser = null;
        // Odblokuj przewijanie strony
        document.body.style.overflow = '';
      };

      window.resetUserPassword = async (userId, email) => {
        if (!confirm(`Czy wysłać link resetowania hasła na adres: ${email}?`))
          return;

        try {
          const { sendPasswordResetEmail } =
            await import("https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js");
          await sendPasswordResetEmail(auth, email, {
            url: `${window.location.origin}/konto.strzelca.pl/akcja.html?mode=resetPassword`,
            handleCodeInApp: true,
          });

          // Zaloguj reset hasła
          await logActivity(userId, "PASSWORD_RESET_REQUEST", {
            email: email,
            requestedBy: currentUser.uid,
          });

          showNotification("Link resetowania hasła został wysłany.");
        } catch (error) {
          console.error("Error sending password reset:", error);
          showNotification("Błąd wysyłania linku resetowania.", "error");
        }
      };

      window.changeUserRoleFromDetails = async (userId, newRole) => {
        if (!currentEditingUser) return;
        
        const currentRole = currentEditingUser.role || "user";
        if (currentRole === newRole) return;

        const roleNames = {
          user: "Użytkownik",
          company: "Firma",
          admin: "Administrator"
        };

        if (!confirm(`Czy na pewno chcesz zmienić rolę użytkownika z "${roleNames[currentRole]}" na "${roleNames[newRole]}"?`)) {
          // Przywróć poprzednią wartość w select
          document.getElementById("user-role-select").value = currentRole;
          return;
        }

        try {
          await updateDoc(doc(db, "userProfiles", userId), { role: newRole });
          // Best-effort: zaktualizuj publiczny profil
          try {
            await setDoc(doc(db, "publicProfiles", userId), { role: newRole, updatedAt: new Date() }, { merge: true });
          } catch (e) {
            console.warn("publicProfiles role sync failed (ignored):", e?.message || e);
          }

          // Zaloguj zmianę roli
          await logActivity(userId, "ROLE_CHANGE", {
            oldRole: currentRole,
            newRole: newRole,
            changedBy: currentUser.uid,
          });

          // Zaktualizuj lokalny obiekt użytkownika
          currentEditingUser.role = newRole;

          showNotification(`Rola użytkownika została zmieniona na: ${roleNames[newRole]}.`);
          loadUserDetails(); // Odśwież szczegóły
          loadUsers(); // Odśwież listę
        } catch (error) {
          console.error("Error changing user role:", error);
          showNotification("Błąd zmiany roli użytkownika.", "error");
          // Przywróć poprzednią wartość w select
          document.getElementById("user-role-select").value = currentRole;
        }
      };

      // Zmienna globalna dla usuwanego użytkownika
      let currentDeletingUser = null;

      window.deleteUser = async (userId) => {

        try {
          let user;

          const userDoc = await getDoc(doc(db, "userProfiles", userId));
          if (!userDoc.exists()) return;
          user = { id: userId, ...userDoc.data() };

          currentDeletingUser = user;

          showUserDeleteModal();
        } catch (error) {
          console.error("Error preparing user deletion:", error);
          showNotification(
            "Błąd przygotowania usunięcia użytkownika.",
            "error",
          );
        }
      };

      window.refreshUsers = () => {
        loadUsers();
      };

      // Funkcje zarządzania produktami
      async function loadProducts() {
        try {
          const q = query(collection(db, "products"), orderBy("order", "asc"));
          const snapshot = await getDocs(q);
          productsList = snapshot.docs.map((doc) => ({
            id: doc.id,
            ...doc.data(),
          }));

          renderProductsList();
        } catch (error) {
          console.error("Error loading products:", error);
          showNotification("Błąd ładowania produktów.", "error");
        }
      }

      function renderProductsList() {
        const productsHtml = productsList
          .map(
            (product) => `
                <div class="flex justify-between items-center p-3 bg-zinc-800 rounded-lg">
                    <div class="flex-1">
                        <div class="font-semibold">${product.title}</div>
                        <div class="text-sm text-zinc-400">${product.price} zł</div>
                    </div>
                    <div class="flex space-x-2">
                        <button onclick="editProduct('${product.id}')" class="text-blue-400 hover:text-blue-300 px-2 py-1 border border-blue-400 rounded text-xs">Edytuj</button>
                        <button onclick="deleteProduct('${product.id}')" class="text-red-400 hover:text-red-300 px-2 py-1 border border-red-400 rounded text-xs">Usuń</button>
                    </div>
                </div>
            `,
          )
          .join("");

        document.getElementById("products-list").innerHTML =
          productsHtml ||
          '<div class="text-center text-zinc-500 py-4">Brak produktów</div>';
      }

      // Funkcje formatowania tekstu w edytorze
      window.formatText = (command) => {
        document.execCommand(command, false, null);
      };

      window.insertImage = () => {
        const url = prompt("Wprowadź URL obrazka:");
        if (url) {
          document.execCommand("insertImage", false, url);
        }
      };

      // Wiadomości zostały przeniesione do floating widget

      async function loadMessages() {
        console.log('🔄 loadMessages called - redirecting to new interface');

        // Jeśli jesteśmy w nowej zakładce messages, użyj nowych funkcji
        if (document.getElementById('messages-container')) {
          await loadMessagesWithFilters();
          await loadMessagesStatus();
          await updateCategoryButtonsHighlight(); // Aktualizuj przyciski po załadowaniu
          return;
        }

        // Fallback dla starego interfejsu (jeśli istnieje)
        const refreshBtn = document.getElementById("refresh-messages-btn");
        if (refreshBtn) {
          refreshBtn.disabled = true;
          refreshBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin mr-2"></i><span id="refresh-text">Ładowanie...</span>';
        }

        try {
          const conversationsList = document.getElementById("conversations-list");
          if (!conversationsList) {
            console.error('❌ conversations-list element not found!');
            return;
          }

          conversationsList.innerHTML =
            '<div class="text-center text-zinc-500 py-8"><i class="fa-solid fa-spinner fa-spin text-xl mb-3 text-zinc-600"></i><p class="text-sm">Ładowanie czatów...</p></div>';

          // Sprawdź czy jesteśmy na serwerze
          if (window.location.protocol === 'file:') {
            throw new Error('Strona otwarta lokalnie! Uruchom serwer: node server.js i otwórz http://localhost:3000/admin/index.html');
          }

          // Pobierz wiadomości skierowane do administratora z Firestore
          console.log('🌐 Loading messages from Firestore collection "privateMessages"');
          const messagesRef = collection(db, "privateMessages");
          const messagesQuery = query(messagesRef, where("recipientId", "==", "admin"), orderBy("timestamp", "desc"), limit(100));
          const querySnapshot = await getDocs(messagesQuery);
          
          const messages = [];
          querySnapshot.forEach((doc) => {
            messages.push({
              id: doc.id,
              ...doc.data(),
              timestamp: doc.data().timestamp?.toDate ? doc.data().timestamp.toDate() : (doc.data().timestamp || new Date())
            });
          });
          
          const total = messages.length;

          if (messages.length === 0) {
            document.getElementById("conversations-list").innerHTML =
              '<div class="text-center text-zinc-500 py-8"><i class="fa-solid fa-inbox text-4xl mb-4 text-zinc-600"></i><p class="text-sm">Brak konwersacji</p></div>';
            const convCountEl = document.getElementById("conversations-count");
            if (convCountEl) convCountEl.textContent = '0';
          } else {
            // Grupuj wiadomości w konwersacje
            const conversations = {};

            messages.forEach(msg => {
              // Użyj kombinacji senderId + recipientId jako klucz konwersacji
              const participants = [msg.senderId, msg.recipientId].sort();
              const conversationKey = participants.join('_');

              if (!conversations[conversationKey]) {
                conversations[conversationKey] = {
                  participants: participants,
                  senderName: msg.senderName,
                  senderEmail: msg.senderEmail,
                  senderId: msg.senderId,
                  lastMessage: msg,
                  messages: [],
                  unreadCount: 0,
                  totalMessages: 0
                };
              }

              conversations[conversationKey].messages.push(msg);
              conversations[conversationKey].totalMessages++;

              if (!msg.isRead) {
                conversations[conversationKey].unreadCount++;
              }
            });

            // Konwertuj na tablicę i posortuj
            const conversationsArray = Object.values(conversations).sort((a, b) => {
              // Najpierw nieprzeczytane
              if (a.unreadCount > 0 && b.unreadCount === 0) return -1;
              if (a.unreadCount === 0 && b.unreadCount > 0) return 1;
              // Potem po dacie ostatniej wiadomości
              return b.lastMessage.timestamp - a.lastMessage.timestamp;
            });

            // Wyświetl konwersacje w stylu WhatsApp/Messenger
            const conversationsHtml = conversationsArray.map((conversation) => {
              const lastMsg = conversation.lastMessage;
              const date = new Date(lastMsg.timestamp).toLocaleString("pl-PL", {
                day: '2-digit',
                month: '2-digit',
                hour: '2-digit',
                minute: '2-digit'
              });
              const hasUnread = conversation.unreadCount > 0;

            return `
                <div class="conversation-item p-3 border-b border-zinc-700/50 hover:bg-zinc-800/50 cursor-pointer transition-all duration-200 ${hasUnread ? 'bg-zinc-800/30 border-l-4 border-l-coyote' : 'bg-zinc-800/10'}"
                     data-user-id="${conversation.senderId}"
                     data-user-name="${conversation.senderName}"
                     data-user-email="${conversation.senderEmail}">
                  <div class="flex justify-between items-start">
                    <div class="flex-1 min-w-0">
                      <div class="flex items-center justify-between mb-1">
                        <h4 class="text-sm font-semibold text-white truncate pr-2">
                          ${conversation.senderName}
                        </h4>
                        <span class="text-xs text-zinc-500 flex-shrink-0">${date}</span>
                  </div>
                      <p class="text-xs text-zinc-400 truncate mb-2">
                        ${lastMsg.topic ? lastMsg.topic + ': ' : ''}${lastMsg.content.substring(0, 60)}${lastMsg.content.length > 60 ? '...' : ''}
                      </p>
                      <div class="flex items-center justify-between">
                        <span class="text-xs text-zinc-500">${conversation.totalMessages} wiadomości</span>
                  </div>
                </div>
                </div>
              </div>
            `;
            }).join('');

            document.getElementById("conversations-list").innerHTML = conversationsHtml;
            const convCountEl2 = document.getElementById("conversations-count");
            if (convCountEl2) convCountEl2.textContent = conversationsArray.length;
          }

          // Zaktualizuj liczniki w nagłówku
          const unreadCount = messages.filter(msg => !msg.isRead).length;
          const unreadCountEl = document.getElementById("unread-count");
          if (unreadCountEl) unreadCountEl.textContent = unreadCount;

          const totalCountEl = document.getElementById("total-count");
          if (totalCountEl) totalCountEl.textContent = total;

        } catch (error) {
          console.error("Error loading messages:", error);
            document.getElementById("conversations-list").innerHTML =
            '<div class="text-center text-red-400 py-8"><i class="fa-solid fa-exclamation-triangle text-4xl mb-4"></i><p class="text-sm">Błąd ładowania czatów</p></div>';
        } finally {
          // Usuń animację ładowania
          if (refreshBtn) {
            refreshBtn.disabled = false;
            refreshBtn.innerHTML = '<i class="fa-solid fa-sync-alt mr-2"></i><span id="refresh-text">Odśwież</span>';
          }
        }
      }

      // Funkcja do otwierania konwersacji
      async function openConversation(userId, userName, userEmail) {
        currentConversationUser = { id: userId, name: userName, email: userEmail };

        // Ustaw informacje o użytkowniku w modalu
        const chatNameEl = document.getElementById('chat-user-name');
        if (chatNameEl) chatNameEl.textContent = userName;
        const chatEmailEl = document.getElementById('chat-user-email');
        if (chatEmailEl) chatEmailEl.textContent = userEmail;

        // Pokaż modal
        document.getElementById('chat-modal').classList.remove('hidden');

        // Załaduj wiadomości konwersacji
        await loadConversationMessages(userId);
      }

      // Funkcja do zamykania modalu czatu - przeniesiona niżej w kodzie

      // Funkcja do ładowania wiadomości konwersacji - przeniesiona niżej w kodzie

      // Funkcja do zamykania bieżącego czatu
      function closeCurrentChat() {
        document.getElementById('chat-header').classList.add('hidden');
        document.getElementById('chat-messages-container').classList.add('hidden');
        document.getElementById('chat-input-container').classList.add('hidden');

        // Przywróć widok powitalny
        document.getElementById('chat-messages-container').innerHTML = `
          <div class="text-center text-zinc-500 py-12">
            <i class="fa-solid fa-comments text-4xl mb-4 text-zinc-600"></i>
            <h3 class="text-lg font-semibold mb-2">Wybierz konwersację</h3>
            <p class="text-sm">Kliknij na czat z listy, aby rozpocząć rozmowę</p>
          </div>
        `;

        currentConversationUser = null;
        document.getElementById('chat-reply-input').value = '';
      }

      // Funkcja do rozpoczynania nowego czatu
      function startNewChat() {
        // Utwórz modal do tworzenia nowego czatu
        const modalHtml = `
          <div class="fixed inset-0 bg-black/80 flex items-center justify-center z-50" id="new-chat-modal">
            <div class="bg-zinc-900 rounded-xl shadow-2xl w-full max-w-md mx-4">
              <div class="p-6">
                <div class="flex items-center justify-between mb-6">
                  <h3 class="text-xl font-bold text-white">Nowa wiadomość</h3>
                  <button onclick="closeNewChatModal()" class="text-zinc-400 hover:text-white">
                    <i class="fa-solid fa-times text-xl"></i>
                  </button>
                </div>

                <form id="new-chat-form" onsubmit="createNewChat(event)">
                  <div class="space-y-4">
                  <div class="relative">
                      <label class="block text-sm font-medium text-zinc-300 mb-2">
                        Wyszukaj użytkownika
                      </label>
                      <input
                        type="text"
                        id="new-chat-user-search"
                        autocomplete="off"
                        required
                        placeholder="Wpisz nick lub email użytkownika..."
                        class="w-full bg-zinc-800 border border-zinc-600 rounded-lg px-3 py-2 text-white placeholder-zinc-400 focus:outline-none focus:ring-2 focus:ring-coyote"
                      >
                      <input
                        type="hidden"
                        id="new-chat-user-id"
                      >
                      <input
                        type="hidden"
                        id="new-chat-email"
                      >
                      <div id="user-search-results" class="absolute z-50 w-full mt-1 bg-zinc-800 border border-zinc-600 rounded-lg max-h-60 overflow-y-auto hidden">
                        <!-- Wyniki wyszukiwania będą tutaj -->
                      </div>
                  </div>

                    <div>
                      <label class="block text-sm font-medium text-zinc-300 mb-2">
                        Temat rozmowy
                      </label>
                      <input
                        type="text"
                        id="new-chat-topic"
                        placeholder="Opcjonalny temat..."
                        class="w-full bg-zinc-800 border border-zinc-600 rounded-lg px-3 py-2 text-white placeholder-zinc-400 focus:outline-none focus:ring-2 focus:ring-coyote"
                      >
                  </div>

                    <div>
                      <label class="block text-sm font-medium text-zinc-300 mb-2">
                        Pierwsza wiadomość
                      </label>
                      <textarea
                        id="new-chat-message"
                        required
                        rows="3"
                        placeholder="Wpisz pierwszą wiadomość..."
                        class="w-full bg-zinc-800 border border-zinc-600 rounded-lg px-3 py-2 text-white placeholder-zinc-400 focus:outline-none focus:ring-2 focus:ring-coyote resize-none"
                      ></textarea>
                </div>
                  </div>

                  <div class="flex space-x-3 mt-6">
                    <button
                      type="button"
                      onclick="closeNewChatModal()"
                      class="flex-1 btn-secondary"
                    >
                      Anuluj
                    </button>
                    <button
                      type="submit"
                      class="flex-1 btn-admin"
                      id="create-chat-btn"
                    >
                      <i class="fa-solid fa-paper-plane mr-2"></i>
                      Utwórz czat
                    </button>
                  </div>
                </form>
              </div>
                </div>
              </div>
            `;

        // Dodaj modal do strony
        document.body.insertAdjacentHTML('beforeend', modalHtml);

        // Dodaj event listenery dla wyszukiwania użytkowników
        setTimeout(() => {
          const searchInput = document.getElementById('new-chat-user-search');
          const resultsContainer = document.getElementById('user-search-results');
          const userIdInput = document.getElementById('new-chat-user-id');
          const emailInput = document.getElementById('new-chat-email');

          if (searchInput && resultsContainer) {
            let searchTimeout = null;

            searchInput.addEventListener('input', async (e) => {
              const searchTerm = e.target.value.trim();

              // Wyczyść poprzedni timeout
              if (searchTimeout) {
                clearTimeout(searchTimeout);
              }

              if (searchTerm.length < 2) {
                resultsContainer.classList.add('hidden');
                userIdInput.value = '';
                emailInput.value = '';
                return;
              }

              // Opóźnienie wyszukiwania (debounce)
              searchTimeout = setTimeout(async () => {
                await searchUsers(searchTerm, resultsContainer, userIdInput, emailInput, searchInput);
              }, 300);
            });

            // Ukryj wyniki po kliknięciu poza nimi
            document.addEventListener('click', (e) => {
              if (!searchInput.contains(e.target) && !resultsContainer.contains(e.target)) {
                resultsContainer.classList.add('hidden');
              }
            });
          }
        }, 100);
      }

      // Funkcja wyszukiwania użytkowników
      async function searchUsers(searchTerm, resultsContainer, userIdInput, emailInput, searchInput) {
        try {
          resultsContainer.innerHTML = '<div class="p-3 text-center text-zinc-400"><i class="fa-solid fa-spinner fa-spin"></i> Wyszukiwanie...</div>';
          resultsContainer.classList.remove('hidden');

          const usersRef = collection(db, 'userProfiles');
          const searchLower = searchTerm.toLowerCase();

          // Pobierz wszystkich użytkowników (limit 50 dla wydajności)
          const usersSnapshot = await getDocs(query(usersRef, limit(50)));
          const matchingUsers = [];

          usersSnapshot.forEach((doc) => {
            const userData = doc.data();
            const userId = doc.id;
            const displayName = (userData.displayName || '').toLowerCase();
            const email = (userData.email || '').toLowerCase();

            // Sprawdź czy wyszukiwany tekst pasuje do nicku lub emailu
            if (displayName.includes(searchLower) || email.includes(searchLower)) {
              matchingUsers.push({
                id: userId,
                displayName: userData.displayName || userData.email || 'Brak nazwy',
                email: userData.email || '',
                avatar: userData.avatar || ''
              });
            }
          });

          // Sortuj: najpierw dokładne dopasowania, potem częściowe
          matchingUsers.sort((a, b) => {
            const aName = a.displayName.toLowerCase();
            const bName = b.displayName.toLowerCase();
            const aEmail = a.email.toLowerCase();
            const bEmail = b.email.toLowerCase();

            const aExact = aName === searchLower || aEmail === searchLower;
            const bExact = bName === searchLower || bEmail === searchLower;

            if (aExact && !bExact) return -1;
            if (!aExact && bExact) return 1;
            if (aName.startsWith(searchLower) && !bName.startsWith(searchLower)) return -1;
            if (!aName.startsWith(searchLower) && bName.startsWith(searchLower)) return 1;
            return aName.localeCompare(bName);
          });

          // Wyświetl wyniki
          if (matchingUsers.length === 0) {
            resultsContainer.innerHTML = '<div class="p-3 text-center text-zinc-400">Nie znaleziono użytkowników</div>';
          } else {
            resultsContainer.innerHTML = matchingUsers.slice(0, 10).map(user => `
              <div class="p-3 hover:bg-zinc-700 cursor-pointer border-b border-zinc-700 last:border-b-0 user-search-result"
                   data-user-id="${user.id}"
                   data-user-name="${user.displayName}"
                   data-user-email="${user.email}">
                <div class="flex items-center gap-3">
                  <div class="w-10 h-10 bg-coyote rounded-full flex items-center justify-center flex-shrink-0">
                    <i class="fa-solid fa-user text-black text-sm"></i>
                  </div>
                  <div class="flex-1 min-w-0">
                    <div class="text-white font-medium truncate">${user.displayName}</div>
                    ${user.email ? `<div class="text-zinc-400 text-sm truncate">${user.email}</div>` : ''}
                  </div>
                </div>
              </div>
            `).join('');

            // Dodaj event listenery do wyników
            resultsContainer.querySelectorAll('.user-search-result').forEach(item => {
              item.addEventListener('click', () => {
                const userId = item.dataset.userId;
                const userName = item.dataset.userName;
                const userEmail = item.dataset.userEmail;

                userIdInput.value = userId;
                emailInput.value = userEmail;
                searchInput.value = userName;
                resultsContainer.classList.add('hidden');
              });
            });
          }
        } catch (error) {
          console.error('Error searching users:', error);
          resultsContainer.innerHTML = '<div class="p-3 text-center text-red-400">Błąd wyszukiwania</div>';
        }
      }

      // Funkcja do zamykania modalu nowego czatu
      function closeNewChatModal() {
        const modal = document.getElementById('new-chat-modal');
        if (modal) {
          modal.remove();
        }
      }

      // Funkcja do tworzenia nowego czatu
      async function createNewChat(event) {
        event.preventDefault();

        const userId = document.getElementById('new-chat-user-id').value.trim();
        const email = document.getElementById('new-chat-email').value.trim();
        const userName = document.getElementById('new-chat-user-search').value.trim();
        const topic = document.getElementById('new-chat-topic').value.trim();
        const message = document.getElementById('new-chat-message').value.trim();

        if (!userId || !email || !message) {
          showNotification("Wybierz użytkownika i wpisz wiadomość", "warning");
          return;
        }

        const createBtn = document.getElementById('create-chat-btn');
        createBtn.disabled = true;
        createBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin mr-2"></i>Tworzenie...';

        try {
          // Pobierz nazwę administratora z profilu
          let adminName = 'Administrator';
          let adminEmail = currentUser?.email || 'admin@strzelca.pl';
          
          if (currentUser?.uid) {
            try {
              const adminProfile = await getDoc(doc(db, 'userProfiles', currentUser.uid));
              if (adminProfile.exists()) {
                const adminData = adminProfile.data();
                adminName = adminData.displayName || adminData.email || 'Administrator';
                adminEmail = adminData.email || adminEmail;
              }
            } catch (e) {
              console.warn('Could not fetch admin profile:', e);
            }
          }

          // Utwórz wiadomość przez API
          const payload = {
            recipientId: userId,
            content: message,
            status: 'in_progress',
            senderName: adminName, // Nazwa administratora (nadawcy)
            senderEmail: adminEmail, // Email administratora
          };
          if (topic) payload.topic = topic;

          const res = await fetch('/api/messages', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'include',
            body: JSON.stringify(payload),
          });

          const data = await res.json().catch(() => null);
          if (!res.ok || !data?.success) {
            throw new Error(data?.error || `HTTP ${res.status}`);
          }

          // Zamknij modal
          closeNewChatModal();

          // Odśwież listę konwersacji
          await loadMessagesWithFilters();

          // Otwórz nową konwersację
          openConversation(userId, userName, email);

          showNotification("Wiadomość została wysłana!", "success");

        } catch (error) {
          console.error('Error creating chat:', error);
          showNotification("Błąd podczas tworzenia wiadomości: " + (error.message || 'Nieznany błąd'), "error");
        } finally {
          createBtn.disabled = false;
          createBtn.innerHTML = '<i class="fa-solid fa-paper-plane mr-2"></i>Utwórz czat';
        }
      }


      // Dodaj obsługę zdarzeń po załadowaniu strony
      document.addEventListener('DOMContentLoaded', function() {
        // Sprawdź która zakładka jest aktywna i załaduj odpowiednie dane
        const activeTab = document.querySelector('.tab-content.active');
        if (activeTab && activeTab.id === 'tab-messages') {
          loadMessages();
        }

        // Obsługa kliknięć w konwersacje
        document.addEventListener('click', function(e) {
          if (e.target.closest('.conversation-item')) {
            const item = e.target.closest('.conversation-item');
            const userId = item.dataset.userId;
            const userName = item.dataset.userName;
            const userEmail = item.dataset.userEmail;

            if (userId && userName) {
              openConversation(userId, userName, userEmail);
            }
          }
        });

        // Obsługa wyszukiwania konwersacji
        const chatSearch = document.getElementById('chat-search');
        if (chatSearch) {
          chatSearch.addEventListener('input', function() {
            filterConversations();
          });
        }

        // Obsługa klawisza Enter w polu czatu
        const chatInput = document.getElementById('chat-reply-input');
        if (chatInput) {
          chatInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
              e.preventDefault();
              sendChatReply();
            }
          });
        }
      });

      // Funkcja do wysyłania odpowiedzi - przeniesiona niżej w kodzie

      async function completeMessage(messageId) {
        try {
          // Zaktualizuj status wiadomości bezpośrednio w Firestore
          const messageRef = doc(db, 'messages', messageId);
          await updateDoc(messageRef, { status: 'completed' });

          showNotification("Sprawa została zakończona", "success");
          // Ponownie załaduj wiadomości aby odświeżyć widok
          loadMessages();
        } catch (error) {
          console.error("Error completing message:", error);
          showNotification("Błąd podczas kończenia sprawy", "error");
        }
      }

      // Funkcja oznaczająca wiadomość jako przeczytaną
      async function markMessageAsRead(messageId) {
        try {
          // Oznacz wiadomość jako przeczytaną bezpośrednio w Firestore
          const messageRef = doc(db, 'messages', messageId);
          await updateDoc(messageRef, { isRead: true });
        } catch (error) {
          console.error("Error marking message as read:", error);
        }
      }

      // Funkcja aktualizująca statystyki wiadomości w nagłówku
      async function updateMessageStats() {
        try {
          // Pobierz statystyki bezpośrednio z Firestore
          const messagesRef = collection(db, 'messages');
          const q = query(messagesRef, where('recipientId', '==', 'admin'));
          const querySnapshot = await getDocs(q);

          let total = 0;
          let unread = 0;

          querySnapshot.forEach((doc) => {
            const message = doc.data();
            total++;
            if (!message.isRead) unread++;
          });

          const unreadCountEl = document.getElementById("unread-count");
          if (unreadCountEl) unreadCountEl.textContent = unread;

          const totalCountEl = document.getElementById("total-count");
          if (totalCountEl) totalCountEl.textContent = total;
        } catch (error) {
          console.error("Error updating message stats:", error);
        }
      }




      // Funkcja przełączania zaawansowanych filtrów
      window.toggleAdvancedFilters = () => {
        const advancedFilters = document.getElementById("advanced-filters");
        advancedFilters.classList.toggle("hidden");
      };

      // Funkcja usunięcia konwersacji
      window.deleteConversation = async (conversationKey) => {
        if (!confirm('Czy na pewno chcesz usunąć tę konwersację? Tej operacji nie można cofnąć.')) {
          return;
        }

        try {
          // Rozdziel conversationKey na uczestników
          const participants = conversationKey.split('_');

          // Pobierz wszystkie wiadomości tej konwersacji
          const messagesQuery = query(
            collection(db, "privateMessages"),
            where("senderId", "in", participants),
            where("receiverId", "in", participants)
          );

          const snapshot = await getDocs(messagesQuery);

          // Usuń wszystkie wiadomości tej konwersacji
          const deletePromises = snapshot.docs.map(doc => deleteDoc(doc.ref));
          await Promise.all(deletePromises);

          showNotification("Konwersacja została usunięta", "success");

          // Odśwież listę konwersacji
          await loadConversations();

        } catch (error) {
          console.error("Error deleting conversation:", error);
          showNotification("Błąd podczas usuwania konwersacji", "error");
        }
      };





      async function loadEvents() {
        document.getElementById("events-list").innerHTML =
          '<div class="text-center text-zinc-500 py-8">Ładowanie wydarzeń...</div>';
      }

      async function loadCharity() {
        document.getElementById("charity-content").innerHTML =
          '<div class="text-center text-zinc-500 py-8">Ładowanie zawartości pomocy charytatywnej...</div>';
      }

      async function loadSettings() {
        // Ładowanie ustawień kontaktowych i tematów
        try {
          // Placeholder - będzie zaimplementowane
          document.getElementById("topics-list").innerHTML =
            '<div class="text-center text-zinc-500 py-4">Ładowanie tematów...</div>';
        } catch (error) {
          console.error("Error loading settings:", error);
        }
      }

        window.refreshProducts = async () => {
          const refreshBtn = document.getElementById("refresh-products-btn");
          if (refreshBtn) {
            refreshBtn.disabled = true;
            refreshBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin mr-2"></i><span id="refresh-text">Ładowanie...</span>';
          }

          try {
            await loadProducts();
          } finally {
            if (refreshBtn) {
              refreshBtn.disabled = false;
              refreshBtn.innerHTML = '<i class="fa-solid fa-sync-alt text-lg" id="refresh-products-icon"></i>';
            }
          }
        };

        window.refreshBazar = async () => {
          const refreshBtn = document.getElementById("refresh-bazar-btn");
          if (refreshBtn) {
            refreshBtn.disabled = true;
            refreshBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin mr-2"></i><span id="refresh-text">Ładowanie...</span>';
          }

          try {
            await loadBazar();
          } finally {
            if (refreshBtn) {
              refreshBtn.disabled = false;
              refreshBtn.innerHTML = '<i class="fa-solid fa-sync-alt text-lg" id="refresh-bazar-icon"></i>';
            }
          }
        };

        // Funkcje dashboard
        const SITES_TO_CHECK = [
        "strzelca.pl",
        "sklep.strzelca.pl",
        "bazar.strzelca.pl",
        "szkolenia.strzelca.pl",
        "wydarzenia.strzelca.pl",
        "blog.strzelca.pl",
        "pomoc.strzelca.pl",
        "dokumenty.strzelca.pl",
        "kontakt.strzelca.pl",
        "konto.strzelca.pl",
        ];

        let sitesStatus = {};
        let lastStatusCheck = new Date();

        // Stan usług główych (dla logowania zmian)
        let previousServicesStatus = {
          firestore: true,
          auth: true,
          domain: true
        };

      // Sprawdzanie pojedynczej subdomeny - tylko status dostępności
      async function checkSubdomainStatus(site) {
        const timeout = 10000; // 10 sekund timeout

        try {
          // Próba fetch z timeout
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), timeout);

          const response = await fetch(`https://${site}`, {
              method: "HEAD",
            cache: "no-cache",
            signal: controller.signal,
          });

          clearTimeout(timeoutId);

          // Strona jest dostępna jeśli odpowiedź jest OK
          return {
              online: response.ok,
                lastCheck: new Date(),
              status: response.status,
              };

            } catch (error) {
          clearTimeout(timeoutId);

          // Zapisz awarię do localStorage
          const failureKey = `site_failure_${site}`;
          const failureData = {
            site: site,
            timestamp: new Date().toISOString(),
            error: error.message,
          };

          try {
            localStorage.setItem(failureKey, JSON.stringify(failureData));
          } catch (storageError) {
            console.warn("Nie można zapisać do localStorage:", storageError);
          }

          return {
                online: false,
                lastCheck: new Date(),
            error: error.message,
            lastFailure: failureData,
          };
        }
      }

      // Funkcje zdarzeń i logów (globalne)
      // Funkcja pomocnicza do sprawdzania dostępności Firestore

      // Globalna funkcja powiadomień
      window.showNotification = function(message, type = "success") {
        console.log(`${type}: ${message}`);
        // Można rozszerzyć o wizualne powiadomienia
      }

        // Funkcja pomocnicza do sprawdzenia ostatniego zdarzenia dla usługi
        async function getLastEventForService(service, eventType) {
          try {
            // Pobierz zdarzenia systemowe bezpośrednio z Firestore
            const eventsRef = collection(db, 'system_events');
            const q = query(
              eventsRef,
              where('service', '==', service),
              where('type', '==', eventType),
              orderBy('timestamp', 'desc'),
              limit(1)
            );
            const querySnapshot = await getDocs(q);

            if (!querySnapshot.empty) {
              const doc = querySnapshot.docs[0];
              return {
                id: doc.id,
                ...doc.data(),
                timestamp: doc.data().timestamp?.toDate?.()?.toISOString() || doc.data().timestamp
              };
            }
          } catch (apiError) {
            // Sprawdź w localStorage fallback
            try {
              const localEventsKey = 'admin_system_events_fallback';
              const localEvents = JSON.parse(localStorage.getItem(localEventsKey) || '[]');
              for (let i = localEvents.length - 1; i >= 0; i--) {
                const event = localEvents[i];
                if (event.service === service && event.type === eventType) {
                  return event;
                }
              }
            } catch (localStorageError) {
              console.error('Błąd sprawdzania localStorage fallback:', localStorageError);
            }
          }
          return null; // Nie znaleziono takiego zdarzenia
      }

        async function logSystemEvent(eventType, site, service, details, severity = 'info') {
          const eventData = {
            userId: 'system',
            action: eventType,
            details: typeof details === 'string' ? details : { ...details, site, service, severity },
            timestamp: new Date(),
            adminId: currentUser ? currentUser.uid : null,
            userAgent: navigator.userAgent,
          };

          try {
            // Dodaj zdarzenie systemowe do activityLogs (zgodnie z formatem używanym przez loadEventsLog)
            const eventsRef = collection(db, 'activityLogs');
            await addDoc(eventsRef, eventData);
            console.log('System event logged to Firestore');
          } catch (error) {
            console.warn('Error logging system event, using fallback:', error.message);
            fallbackLogSystemEvent(eventData);
          }
        }

        function fallbackLogSystemEvent(eventData) {
          try {
            const localEventsKey = 'admin_system_events_fallback';
            let localEvents = JSON.parse(localStorage.getItem(localEventsKey) || '[]');

            eventData.id = Date.now().toString() + Math.random().toString(36).substr(2, 9);
            // Konwertuj timestamp na ISO string dla localStorage
            if (eventData.timestamp && eventData.timestamp instanceof Date) {
              eventData.timestamp = eventData.timestamp.toISOString();
            }
            localEvents.push(eventData);

            // Zachowaj tylko ostatnie 50 zdarzeń lokalnie
            if (localEvents.length > 50) {
              localEvents = localEvents.slice(-50);
            }

            localStorage.setItem(localEventsKey, JSON.stringify(localEvents));
            console.log('System event saved to localStorage fallback:', eventData);
          } catch (localStorageError) {
            console.error('Error saving to localStorage fallback:', localStorageError);
          }
        }

        // Backward compatibility - stary logEvent przekierowuje do nowego
        async function logEvent(eventType, site, details) {
          let service = null;
          let severity = 'info';

          // Mapuj stare typy na nowe
          if (eventType.includes('service_')) {
            service = site;
            site = null;
          }

          await logSystemEvent(eventType, site, service, details, severity);
        }

        async function loadEventsLog() {
          const container = document.getElementById('events-log-container');
          const refreshBtn = document.getElementById('refresh-events-btn');

          if (refreshBtn) {
            refreshBtn.disabled = true;
            refreshBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin mr-2"></i><span id="refresh-text">Ładowanie...</span>';
          }

          try {
            // Pobierz activity logs bezpośrednio z Firestore
            const eventsRef = collection(db, 'activityLogs');
            const q = query(eventsRef, orderBy('timestamp', 'desc'), limit(200));
            const querySnapshot = await getDocs(q);

            // Filtruj tylko zdarzenia związane z usługami (service_online, service_offline, site_online, site_offline)
            const serviceActions = ['service_online', 'service_offline', 'site_online', 'site_offline'];
            const eventsLog = [];
            querySnapshot.forEach((doc) => {
              const data = doc.data();
              const action = data.action || data.type;
              // Tylko zdarzenia związane z usługami
              if (serviceActions.includes(action)) {
              eventsLog.push({
                id: doc.id,
                ...data,
                timestamp: data.timestamp?.toDate ? data.timestamp.toDate() : (data.timestamp || new Date())
              });
              }
            });

            if (eventsLog.length === 0) {
              container.innerHTML = '<div class="text-center text-zinc-400 py-4">Brak zdarzeń w logach</div>';
              if (refreshBtn) {
                refreshBtn.disabled = false;
                refreshBtn.innerHTML = '<i class="fa-solid fa-sync-alt text-lg" id="refresh-events-icon"></i>';
              }
              return;
            }

            // Sortuj po czasie (najnowsze na górze)
            if (Array.isArray(eventsLog)) {
              eventsLog.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            }

            const eventsHtmlPromises = eventsLog.map(async event => {
              const eventDate = new Date(event.timestamp);
              const formattedDate = eventDate.toLocaleString('pl-PL');
              const eventAction = event.action || 'Aktywność';
              const eventDetails = event.details || {};
              const eventUser = getUserDisplayName(event);
              // Pobierz nick użytkownika docelowego jeśli to USER_BLOCKED lub USER_UNBLOCKED
              if ((event.action === "USER_BLOCKED" || event.action === "USER_UNBLOCKED") && (event.targetUserId || (eventDetails && eventDetails.targetUser))) {
                const targetUserId = event.targetUserId || (eventDetails && eventDetails.targetUser);
                if (targetUserId) {
                  event.targetUserNickname = await getUserNicknameByIdAsync(targetUserId);
                }
              }
              const activityLog = renderActivityLog ? await renderActivityLog(event) : { description: eventAction, content: '' };

              return `
              <div class="flex items-center justify-between p-3 bg-zinc-800/50 rounded-lg mb-2 animate-fade-in">
                  <div class="flex items-center space-x-3">
                    <span class="text-blue-400"><i class="fa-solid fa-info-circle"></i></span>
                    <div>
                      <div class="text-sm font-medium">${activityLog.description || eventAction}</div>
                      <div class="text-xs text-zinc-500">${formattedDate}</div>
                      ${activityLog.content ? `<div class="text-xs text-zinc-400 mt-1">${activityLog.content}</div>` : ''}
                    </div>
                  </div>
                  <button
                  onclick="deleteEvent('${event.id}', this)"
                  class="text-zinc-400 hover:text-red-400 p-1 transition-colors duration-200"
                    title="Usuń zdarzenie"
                  id="delete-btn-${event.id}"
                  >
                    <i class="fa-solid fa-trash"></i>
                  </button>
                </div>
              `;
            });
            const eventsHtml = (await Promise.all(eventsHtmlPromises)).join('');

            container.innerHTML = eventsHtml;
          showNotification("Logi zdarzeń zostały odświeżone", "success");

          } catch (error) {
            console.error('Błąd podczas ładowania logów:', error);
            container.innerHTML = '<div class="text-center text-red-400 py-4">Błąd ładowania logów</div>';
          showNotification("Błąd ładowania logów zdarzeń", "error");
        } finally {
          if (refreshBtn) {
            refreshBtn.disabled = false;
            refreshBtn.innerHTML = '<i class="fa-solid fa-sync-alt text-lg" id="refresh-events-icon"></i>';
          }
        }
      }

      async function deleteEvent(eventId, buttonElement) {
        // Pokaż stan ładowania na przycisku
        if (buttonElement) {
          buttonElement.disabled = true;
          buttonElement.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i>';
          buttonElement.classList.add('opacity-50');
        }

        try {
          // Usuń zdarzenie bezpośrednio z Firestore
          const eventRef = doc(db, 'activityLogs', eventId);
          await deleteDoc(eventRef);

          // Animacja usunięcia elementu
          const eventElement = buttonElement.closest('.flex.items-center.justify-between');
          if (eventElement) {
            eventElement.style.transition = 'all 0.3s ease';
            eventElement.style.opacity = '0';
            eventElement.style.transform = 'translateX(-20px)';
            setTimeout(() => {
            // Odśwież tabelę
            loadEventsLog();
            }, 300);
          } else {
            // Jeśli nie ma elementu, odśwież od razu
            loadEventsLog();
          }

          showNotification("Zdarzenie zostało usunięte", "success");

          } catch (error) {
            console.error('Błąd podczas usuwania zdarzenia:', error);
          showNotification("Błąd podczas usuwania zdarzenia", "error");
        } finally {
          // Przywróć przycisk do normalnego stanu
          if (buttonElement) {
            setTimeout(() => {
              buttonElement.disabled = false;
              buttonElement.innerHTML = '<i class="fa-solid fa-trash"></i>';
              buttonElement.classList.remove('opacity-50');
            }, 300);
          }
        }
      }

        // Sprawdzanie statusu wszystkich stron
      async function checkSitesStatus() {
        const statusContainer = document.getElementById("sites-status");
        statusContainer.innerHTML =
          '<div class="col-span-full text-center text-zinc-400 py-4"><i class="fa-solid fa-spinner fa-spin mr-2"></i>Sprawdzanie statusów...</div>';

        // Sprawdź wszystkie strony równolegle dla lepszej wydajności
        const promises = SITES_TO_CHECK.map((site) =>
          checkSubdomainStatus(site),
        );
        const results = await Promise.allSettled(promises);

        // Zapisz wyniki i loguj zdarzenia
        SITES_TO_CHECK.forEach((site, index) => {
          const result = results[index];
          const previousStatus = sitesStatus[site];

          if (result.status === "fulfilled") {
            const currentStatus = result.value;
            sitesStatus[site] = currentStatus;

            // Loguj tylko zmiany stanu: offline -> online
            if (previousStatus && !previousStatus.online && currentStatus.online) {
              logSystemEvent('site_online', site, null, 'Strona wróciła do działania', 'success');
            }

          } else {
            const errorStatus = {
              online: false,
              lastCheck: new Date(),
              error: result.reason.message,
            };
            sitesStatus[site] = errorStatus;

            // Loguj tylko zmiany stanu: online -> offline
            if (!previousStatus || previousStatus.online) {
              logSystemEvent('site_offline', site, null, `Strona stała się niedostępna: ${result.reason.message}`, 'error');
            }
          }
        });

          renderSitesStatus();
          loadEventsLog();
          lastStatusCheck = new Date();
        const lastStatusCheckEl = document.getElementById("last-status-check");
        if (lastStatusCheckEl) lastStatusCheckEl.textContent = lastStatusCheck.toLocaleString("pl-PL");
        }

        function renderSitesStatus() {
        const statusContainer = document.getElementById("sites-status");
        const statusHtml = SITES_TO_CHECK.map((site) => {
            const status = sitesStatus[site];
          if (!status) return "";

          let statusClass, statusIcon, statusText;

          if (status.online) {
            statusClass = "text-green-400";
            statusIcon = "fa-circle";
            statusText = "Online";
          } else {
            statusClass = "text-red-400";
            statusIcon = "fa-circle";
            statusText = "Offline";
          }

            return `
              <div class="flex justify-between items-center p-3 bg-zinc-800 rounded-lg animate-fade-in">
                <span class="text-sm font-medium">${site}</span>
                <span class="${statusClass} text-sm font-medium">
                  <i class="fa-solid ${statusIcon} mr-1"></i>${statusText}
                </span>
              </div>
            `;
        }).join("");

          statusContainer.innerHTML = statusHtml;
        }


        // Funkcje aktywności
        async function loadActivityStats() {
          try {
            // Pobierz dane bezpośrednio z Firestore jako fallback gdy API nie działa
            const now = new Date();
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            const tomorrow = new Date(today.getTime() + 24 * 60 * 60 * 1000);
            
            // Oblicz początek tygodnia (poniedziałek)
            const dayOfWeek = now.getDay(); // 0 = niedziela, 1 = poniedziałek, ..., 6 = sobota
            const daysFromMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1; // Jeśli niedziela, to 6 dni wstecz
            const weekStart = new Date(today.getTime() - daysFromMonday * 24 * 60 * 60 * 1000);
            
            const monthAgo = new Date(today.getTime() - 30 * 24 * 60 * 60 * 1000);
            const yearAgo = new Date(today.getTime() - 365 * 24 * 60 * 60 * 1000);
            
            // Konwertuj daty na Firestore Timestamp dla zapytań
            const todayTimestamp = Timestamp.fromDate(today);
            const tomorrowTimestamp = Timestamp.fromDate(tomorrow);
            const weekStartTimestamp = Timestamp.fromDate(weekStart);
            const monthAgoTimestamp = Timestamp.fromDate(monthAgo);
            const yearAgoTimestamp = Timestamp.fromDate(yearAgo);

            // Aktywne zalogowane użytkownicy (ostatnie 30 minut - na podstawie lastSeen)
            let activeUsersCount = 0;
            try {
              const thirtyMinutesAgo = new Date(Date.now() - 30 * 60 * 1000);
              const thirtyMinutesAgoTimestamp = Timestamp.fromDate(thirtyMinutesAgo);
              
              // Zoptymalizowane zapytanie dla zalogowanych użytkowników
              const activeUsersQuery = query(
                collection(db, "userProfiles"),
                where("lastSeen", ">=", thirtyMinutesAgoTimestamp)
              );
              const usersSnapshot = await getDocs(activeUsersQuery);
              
              activeUsersCount = usersSnapshot.size;

              const activeUsersEl = document.getElementById("active-logged-users");
              if (activeUsersEl) activeUsersEl.textContent = activeUsersCount;
            } catch (error) {
              console.warn("Could not fetch active users from Firestore:", error);
              const activeUsersEl = document.getElementById("active-logged-users");
              if (activeUsersEl) activeUsersEl.textContent = "0";
            }

            // Aktywni goście (ostatnie 30 minut - na podstawie activityLogs z userId null lub brak userId)
            let activeGuestsCount = 0;
            try {
              const thirtyMinutesAgo = new Date(Date.now() - 30 * 60 * 1000);
              const thirtyMinutesAgoTimestamp = Timestamp.fromDate(thirtyMinutesAgo);
              
              // Pobierz activityLogs z ostatnich 30 minut
              const activityLogsQuery = query(
                collection(db, "activityLogs"),
                where("timestamp", ">=", thirtyMinutesAgoTimestamp),
                orderBy("timestamp", "desc")
              );
              const activityLogsSnapshot = await getDocs(activityLogsQuery);
              
              // Zlicz unikalnych gości (userId === null, undefined, lub nie istnieje)
              const guestUserIds = new Set();
              activityLogsSnapshot.forEach((doc) => {
                const logData = doc.data();
                // Gość to taki, który nie ma userId lub ma userId === null
                if (!logData.userId || logData.userId === null) {
                  // Użyj kombinacji userAgent + IP (jeśli dostępne) jako identyfikatora gościa
                  // Jeśli nie ma IP, użyj userAgent + timestamp (zaokrąglony do minuty) dla lepszej unikalności
                  const ipAddress = logData.ipAddress || 'no-ip';
                  const userAgent = logData.userAgent || 'no-ua';
                  const timestamp = logData.timestamp?.toDate ? logData.timestamp.toDate() : new Date(logData.timestamp);
                  // Zaokrąglij timestamp do minuty, żeby użytkownicy z tej samej minuty byli traktowani jako jeden gość
                  const minuteTimestamp = new Date(timestamp.getFullYear(), timestamp.getMonth(), timestamp.getDate(), timestamp.getHours(), timestamp.getMinutes());
                  const guestId = `${ipAddress}-${userAgent}-${minuteTimestamp.getTime()}`;
                  guestUserIds.add(guestId);
                }
              });
              
              activeGuestsCount = guestUserIds.size;

              const activeGuestsEl = document.getElementById("active-guests");
              if (activeGuestsEl) activeGuestsEl.textContent = activeGuestsCount;
            } catch (error) {
              console.warn("Could not fetch active guests from Firestore:", error);
              const activeGuestsEl = document.getElementById("active-guests");
              if (activeGuestsEl) activeGuestsEl.textContent = "0";
            }

            // Suma aktywnych użytkowników (zalogowani + goście)
            const activeTotalCount = activeUsersCount + activeGuestsCount;
            const activeTotalEl = document.getElementById("active-total");
            if (activeTotalEl) activeTotalEl.textContent = activeTotalCount;

            // Wizyty dzisiaj - zliczamy unikalne odwiedziny z kolekcji "visits" (zarówno zalogowanych jak i niezalogowanych)
            try {
              const todayVisitsQuery = query(
                collection(db, "visits"),
                where("timestamp", ">=", todayTimestamp),
                where("timestamp", "<", tomorrowTimestamp)
              );
              const todayVisitsSnapshot = await getDocs(todayVisitsQuery);
              
              // Zlicz unikalnych użytkowników (userId dla zalogowanych, visitorId dla niezalogowanych)
              const uniqueVisitors = new Set();
              let loggedInCount = 0;
              let guestCount = 0;
              
              todayVisitsSnapshot.forEach((doc) => {
                const visitData = doc.data();
                // Dla zalogowanych: userId jest ustawiony, visitorId jest null
                // Dla niezalogowanych: userId jest null, visitorId jest ustawiony
                const identifier = visitData.userId ?? visitData.visitorId;
                if (identifier) {
                  uniqueVisitors.add(identifier);
                  if (visitData.userId) {
                    loggedInCount++;
                  } else if (visitData.visitorId) {
                    guestCount++;
                  }
                }
              });
              
              const todayVisitsCount = uniqueVisitors.size;
              console.log(`Odwiedziny dzisiaj: ${todayVisitsCount} (zalogowani: ${loggedInCount}, goście: ${guestCount})`);

              const todayVisitsEl = document.getElementById("visits-today");
              if (todayVisitsEl) {
                todayVisitsEl.textContent = todayVisitsCount;
              }
            } catch (error) {
              console.error("Error fetching today visits from Firestore:", error);
              const todayVisitsEl = document.getElementById("visits-today");
              if (todayVisitsEl) todayVisitsEl.textContent = "0";
            }

            // Nowe formularze kontaktowe dzisiaj
            try {
              const todayContactsQuery = query(
                collection(db, "contactForms"),
                where("timestamp", ">=", today)
              );
              const todayContactsSnapshot = await getDocs(todayContactsQuery);

              const todayContactsEl = document.getElementById("new-forms-today");
              if (todayContactsEl) todayContactsEl.textContent = todayContactsSnapshot.size;
            } catch (error) {
              console.warn("Could not fetch today contacts from Firestore:", error);
              const todayContactsEl = document.getElementById("new-forms-today");
              if (todayContactsEl) todayContactsEl.textContent = "0";
            }

            // Oczekujące zadania (pending tasks) - używamy messages z statusem in_progress
            try {
              const pendingTasksQuery = query(
                collection(db, "messages"),
                where("recipientId", "==", "admin"),
                where("status", "==", "in_progress")
              );
              const pendingTasksSnapshot = await getDocs(pendingTasksQuery);

              const pendingTasksEl = document.getElementById("pending-issues");
              if (pendingTasksEl) pendingTasksEl.textContent = pendingTasksSnapshot.size;
            } catch (error) {
              console.warn("Could not fetch pending tasks from Firestore:", error);
              const pendingTasksEl = document.getElementById("pending-issues");
              if (pendingTasksEl) pendingTasksEl.textContent = "0";
            }

            // Wizyty w tym tygodniu - unikalni użytkownicy aktywni od początku tygodnia (poniedziałek)
            try {
              const weekVisitsQuery = query(
                collection(db, "visits"),
                where("timestamp", ">=", weekStartTimestamp)
              );
              const weekVisitsSnapshot = await getDocs(weekVisitsQuery);
              
              // Zlicz unikalnych użytkowników (userId dla zalogowanych, visitorId dla niezalogowanych)
              const uniqueVisitors = new Set();
              weekVisitsSnapshot.forEach((doc) => {
                const visitData = doc.data();
                // Dla zalogowanych: userId jest ustawiony, visitorId jest null
                // Dla niezalogowanych: userId jest null, visitorId jest ustawiony
                const identifier = visitData.userId ?? visitData.visitorId;
                if (identifier) {
                  uniqueVisitors.add(identifier);
                }
              });
              
              const weekVisitsCount = uniqueVisitors.size;

              const weekVisitsEl = document.getElementById("visits-week");
              if (weekVisitsEl) weekVisitsEl.textContent = weekVisitsCount;
            } catch (error) {
              console.warn("Could not fetch week visits from Firestore:", error);
              const weekVisitsEl = document.getElementById("visits-week");
              if (weekVisitsEl) weekVisitsEl.textContent = "0";
            }

            // Wizyty w tym miesiącu - unikalni użytkownicy aktywni w ciągu miesiąca
            try {
              const monthVisitsQuery = query(
                collection(db, "visits"),
                where("timestamp", ">=", monthAgoTimestamp)
              );
              const monthVisitsSnapshot = await getDocs(monthVisitsQuery);
              
              // Zlicz unikalnych użytkowników (userId dla zalogowanych, visitorId dla niezalogowanych)
              const uniqueVisitors = new Set();
              monthVisitsSnapshot.forEach((doc) => {
                const visitData = doc.data();
                // Dla zalogowanych: userId jest ustawiony, visitorId jest null
                // Dla niezalogowanych: userId jest null, visitorId jest ustawiony
                const identifier = visitData.userId ?? visitData.visitorId;
                if (identifier) {
                  uniqueVisitors.add(identifier);
                }
              });
              
              const monthVisitsCount = uniqueVisitors.size;

              const monthVisitsEl = document.getElementById("visits-month");
              if (monthVisitsEl) monthVisitsEl.textContent = monthVisitsCount;
            } catch (error) {
              console.warn("Could not fetch month visits from Firestore:", error);
              const monthVisitsEl = document.getElementById("visits-month");
              if (monthVisitsEl) monthVisitsEl.textContent = "0";
            }

            // Wizyty w tym roku - unikalni użytkownicy aktywni w ciągu roku
            try {
              const yearVisitsQuery = query(
                collection(db, "visits"),
                where("timestamp", ">=", yearAgoTimestamp)
              );
              const yearVisitsSnapshot = await getDocs(yearVisitsQuery);
              
              // Zlicz unikalnych użytkowników (userId dla zalogowanych, visitorId dla niezalogowanych)
              const uniqueVisitors = new Set();
              yearVisitsSnapshot.forEach((doc) => {
                const visitData = doc.data();
                // Dla zalogowanych: userId jest ustawiony, visitorId jest null
                // Dla niezalogowanych: userId jest null, visitorId jest ustawiony
                const identifier = visitData.userId ?? visitData.visitorId;
                if (identifier) {
                  uniqueVisitors.add(identifier);
                }
              });
              
              const yearVisitsCount = uniqueVisitors.size;

              const yearVisitsEl = document.getElementById("visits-year");
              if (yearVisitsEl) yearVisitsEl.textContent = yearVisitsCount;
            } catch (error) {
              console.warn("Could not fetch year visits from Firestore:", error);
              const yearVisitsEl = document.getElementById("visits-year");
              if (yearVisitsEl) yearVisitsEl.textContent = "0";
            }

            // Wizyty ogółem - wszyscy unikalni użytkownicy (zalogowani i niezalogowani)
            try {
              const visitsRef = collection(db, "visits");
              const visitsSnapshot = await getDocs(visitsRef);
              
              // Zlicz unikalnych użytkowników (userId dla zalogowanych, visitorId dla niezalogowanych)
              const uniqueVisitors = new Set();
              visitsSnapshot.forEach((doc) => {
                const visitData = doc.data();
                // Dla zalogowanych: userId jest ustawiony, visitorId jest null
                // Dla niezalogowanych: userId jest null, visitorId jest ustawiony
                const identifier = visitData.userId ?? visitData.visitorId;
                if (identifier) {
                  uniqueVisitors.add(identifier);
                }
              });
              
              const totalVisitsCount = uniqueVisitors.size;

              const totalVisitsEl = document.getElementById("visits-total");
              if (totalVisitsEl) totalVisitsEl.textContent = totalVisitsCount;
            } catch (error) {
              console.warn("Could not fetch total visits from Firestore:", error);
              const totalVisitsEl = document.getElementById("visits-total");
              if (totalVisitsEl) totalVisitsEl.textContent = "0";
            }

          } catch (error) {
            console.error("Error loading activity stats:", error);
          }
        }

        // Funkcje zdarzeń
        let eventsData = [];

        async function loadRecentEvents() {
          try {
            // Symulacja zdarzeń - w rzeczywistości pobierać z Firebase
            eventsData = [];

            renderRecentEvents();
          const lastEventsUpdateEl = document.getElementById("last-events-update");
          if (lastEventsUpdateEl) lastEventsUpdateEl.textContent = new Date().toLocaleString("pl-PL");
          } catch (error) {
          console.error("Error loading events:", error);
          }
        }

        async function renderRecentEvents() {
        const eventsContainer = document.getElementById("events-log-container");
        if (!eventsContainer) return;
          const recentEvents = eventsData.slice(0, 10); // Pokaż 10 najnowszych

        const eventsHtmlPromises = recentEvents
          .map(async (event) => {
            const eventTimestamp = event.timestamp?.toDate ? event.timestamp.toDate() : new Date(event.timestamp);
            const timeAgo = getTimeAgo(eventTimestamp);
            // Pobierz nick użytkownika docelowego jeśli to USER_BLOCKED lub USER_UNBLOCKED
            if ((event.action === "USER_BLOCKED" || event.action === "USER_UNBLOCKED") && (event.targetUserId || (event.details && event.details.targetUser))) {
              const targetUserId = event.targetUserId || (event.details && event.details.targetUser);
              if (targetUserId) {
                event.targetUserNickname = await getUserNicknameByIdAsync(targetUserId);
              }
            }
            const activityLog = await renderActivityLog(event);
            const userDisplayName = getUserDisplayName(event);
            return `
              <div class="p-4 bg-zinc-800 rounded-lg cursor-pointer hover:bg-zinc-700 transition" onclick="showEventDetails('${event.id}')">
                <div class="flex justify-between items-start mb-2">
                  <div class="font-semibold text-white">${userDisplayName}</div>
                  <div class="text-xs text-zinc-500">${timeAgo}</div>
                </div>
                <div class="text-sm text-zinc-300">${activityLog.description}</div>
                <div class="text-xs text-zinc-500 mt-1">${activityLog.content}</div>
              </div>
            `;
          });
        const eventsHtml = (await Promise.all(eventsHtmlPromises)).join("");

        eventsContainer.innerHTML =
          eventsHtml ||
          '<div class="text-center text-zinc-500 py-4">Brak zdarzeń</div>';
        }

        function getTimeAgo(date) {
          // Obsługa różnych formatów daty
          let dateObj;
          if (date?.toDate) {
            // Firestore Timestamp
            dateObj = date.toDate();
          } else if (date instanceof Date) {
            dateObj = date;
          } else if (typeof date === 'string') {
            dateObj = new Date(date);
          } else {
            return "Data niedostępna";
          }

          const now = new Date();
          const diffMs = now - dateObj;
          const diffMins = Math.floor(diffMs / (1000 * 60));
          const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
          const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

          if (diffMins < 1) return "Przed chwilą";
          if (diffMins < 60) return `${diffMins} min temu`;
          if (diffHours < 24) return `${diffHours} godz. temu`;
          return `${diffDays} dni temu`;
        }

        // Modal ze szczegółami zdarzenia
        async function showEventDetails(eventId) {
        const event = eventsData.find((e) => e.id === eventId);
          if (!event) return;

        // Pobierz nick użytkownika docelowego jeśli to USER_BLOCKED lub USER_UNBLOCKED
        if ((event.action === "USER_BLOCKED" || event.action === "USER_UNBLOCKED") && (event.targetUserId || (event.details && event.details.targetUser))) {
          const targetUserId = event.targetUserId || (event.details && event.details.targetUser);
          if (targetUserId) {
            event.targetUserNickname = await getUserNicknameByIdAsync(targetUserId);
          }
        }
        const activityLog = await renderActivityLog(event);
        const userDisplayName = await getUserDisplayNameAsync(event);

          // Utwórz modal
          const modalHtml = `
            <div id="event-modal" class="fixed inset-0 z-50 flex items-center justify-center p-4 bg-black/80 backdrop-blur-sm" onclick="if(event.target.id === 'event-modal') closeEventModal()">
              <div class="bg-zinc-900 p-6 rounded-2xl border border-zinc-700 max-w-2xl w-full max-h-[80vh] overflow-y-auto" onclick="event.stopPropagation()">
                <div class="flex justify-between items-center mb-6">
                  <h2 class="text-2xl font-bold coyote-text">Szczegóły Zdarzenia</h2>
                  <button onclick="closeEventModal()" class="text-zinc-400 hover:text-white transition-colors">
                    <i class="fa-solid fa-times text-xl"></i>
                  </button>
                </div>

                <div class="space-y-4">
                  <div>
                    <label class="text-sm text-zinc-400">Użytkownik:</label>
                    <div class="text-white font-semibold">${userDisplayName}</div>
                  </div>

                  <div>
                    <label class="text-sm text-zinc-400">Rodzaj zdarzenia:</label>
                    <div class="text-white">${getActionLabel(event.action || event.type || "UNKNOWN")}</div>
                  </div>

                  <div>
                    <label class="text-sm text-zinc-400">Nagłówek:</label>
                    <div class="text-white">${activityLog.description}</div>
                  </div>

                  <div>
                    <label class="text-sm text-zinc-400">Szczegóły:</label>
                    <div class="text-white">${activityLog.details}</div>
                  </div>

                  <div>
                    <label class="text-sm text-zinc-400">Data i czas:</label>
                    <div class="text-white">${event.timestamp?.toDate?.()?.toLocaleString("pl-PL") || (event.timestamp ? new Date(event.timestamp).toLocaleString("pl-PL") : "Data niedostępna")}</div>
                  </div>
                  
                  ${event.userId && event.userId !== "system" ? `
                  <div>
                    <label class="text-sm text-zinc-400">ID użytkownika:</label>
                    <div class="text-white text-sm">${event.userId}</div>
                  </div>
                  ` : ""}
                  
                  ${event.action ? `
                  <div>
                    <label class="text-sm text-zinc-400">Akcja (kod):</label>
                    <div class="text-white text-sm font-mono">${event.action}</div>
                  </div>
                  ` : ""}
                </div>
              </div>
            </div>
          `;

        document.body.insertAdjacentHTML("beforeend", modalHtml);
        
        // Dodaj obsługę klawisza ESC
        const handleEscape = (e) => {
          if (e.key === 'Escape') {
            closeEventModal();
            document.removeEventListener('keydown', handleEscape);
          }
        };
        document.addEventListener('keydown', handleEscape);
        }

        window.closeEventModal = () => {
        const modal = document.getElementById("event-modal");
          if (modal) {
            modal.remove();
            // Usuń listener ESC jeśli jeszcze istnieje
            document.removeEventListener('keydown', (e) => {
              if (e.key === 'Escape') closeEventModal();
            });
          }
        };

        // Funkcja sprawdzania głównych usług serwera
        async function checkMainServicesStatus() {
          try {
            // Sprawdź Firestore
          const firestoreStatus = document.getElementById("firestore-status");
          if (!firestoreStatus) return;

          const firestoreIcon = firestoreStatus.querySelector("i");
          const firestoreText =
            firestoreStatus.querySelector("span:last-child");

          // Pokaż ładowanie dla Firestore
          if (firestoreIcon) firestoreIcon.className = "fa-solid fa-spinner fa-spin text-lg text-zinc-400";
          if (firestoreText) {
            firestoreText.className = "text-zinc-400 font-semibold text-sm";
            firestoreText.textContent = "Sprawdzanie...";
          }

            // Sprawdź Auth
          const authStatus = document.getElementById("auth-status");
          if (!authStatus) return;

          const authIcon = authStatus.querySelector("i");
          const authText = authStatus.querySelector("span:last-child");

          // Pokaż ładowanie dla Auth
          if (authIcon) authIcon.className = "fa-solid fa-spinner fa-spin text-lg text-zinc-400";
          if (authText) {
            authText.className = "text-zinc-400 font-semibold text-sm";
            authText.textContent = "Sprawdzanie...";
          }

            // Sprawdź domenę
          const domainStatus = document.getElementById("domain-status");
          if (!domainStatus) return;

          const domainIcon = domainStatus.querySelector("i");
          const domainText = domainStatus.querySelector("span:last-child");

          // Pokaż ładowanie dla domeny
          if (domainIcon) domainIcon.className = "fa-solid fa-spinner fa-spin text-lg text-zinc-400";
          if (domainText) {
            domainText.className = "text-zinc-400 font-semibold text-sm";
            domainText.textContent = "Sprawdzanie...";
          }

            let allServicesOnline = true;

            // Sprawdź Firestore
            try {
              // Sprawdź połączenie przez próbę odczytu z istniejącej kolekcji (limit 1 dla szybkości)
              const testRef = collection(db, "activityLogs");
              await getDocs(query(testRef, limit(1)));
              
              // Jeśli dotarliśmy tutaj, Firestore jest dostępne
              const firestoreOnline = true;

              // Sprawdź czy już istnieje zdarzenie service_online (jeśli nie, utwórz)
              const lastOnlineEvent = await getLastEventForService('Baza danych', 'service_online');
              if (!lastOnlineEvent) {
                logSystemEvent('service_online', null, 'Baza danych', 'Baza danych Firestore przywrócona', 'success');
              }

              firestoreIcon.className = "fa-solid fa-check-circle text-lg text-green-400";
              firestoreText.className = "text-green-400 font-semibold text-sm";
              firestoreText.textContent = "Online";
            } catch (error) {
              console.error("Firestore error:", error);
              const firestoreOnline = false;

              // Sprawdź czy już istnieje zdarzenie service_offline (jeśli nie, utwórz)
              const lastOfflineEvent = await getLastEventForService('Baza danych', 'service_offline');
              if (!lastOfflineEvent) {
                logSystemEvent('service_offline', null, 'Baza danych', 'Baza danych Firestore niedostępna: ' + error.message, 'error');
              }

              firestoreIcon.className = "fa-solid fa-times-circle text-lg text-red-400";
              firestoreText.className = "text-red-400 font-semibold text-sm";
              firestoreText.textContent = "Offline";
              allServicesOnline = false;
            }

            // Sprawdź Auth - czy ktoś jest zalogowany (oprócz lokalnego administratora)
            try {
              // Sprawdź czy jest jakiś zalogowany użytkownik
              if (auth.currentUser) {
                // Jest zalogowany rzeczywisty użytkownik - Auth działa
                const authOnline = true;

                  // Sprawdź czy już istnieje zdarzenie service_online
                  const lastOnlineEvent = await getLastEventForService('Logowanie', 'service_online');
                  if (!lastOnlineEvent) {
                    logSystemEvent('service_online', null, 'Logowanie', 'System logowania przywrócony', 'success');
                  }

                  authIcon.className = "fa-solid fa-check-circle text-lg text-green-400";
                authText.className = "text-green-400 font-semibold text-sm";
                authText.textContent = "Połączony";
              } else {
                  // Nikt nie jest zalogowany
                  const authOnline = false;

                  // Sprawdź czy już istnieje zdarzenie service_offline
                  const lastOfflineEvent = await getLastEventForService('Logowanie', 'service_offline');
                  if (!lastOfflineEvent) {
                    logSystemEvent('service_offline', null, 'Logowanie', 'Brak zalogowanych użytkowników w systemie', 'warning');
                  }

                  authIcon.className = "fa-solid fa-times-circle text-lg text-orange-400";
                  authText.className = "text-orange-400 font-semibold text-sm";
                  authText.textContent = "Rozłączony";
                  allServicesOnline = false;
              }
            } catch (error) {
              console.error("Auth error:", error);
              const authOnline = false;

              // Sprawdź czy już istnieje zdarzenie service_offline
              const lastOfflineEvent = await getLastEventForService('Logowanie', 'service_offline');
              if (!lastOfflineEvent) {
                logSystemEvent('service_offline', null, 'Logowanie', 'Błąd systemu logowania: ' + error.message, 'error');
              }

              authIcon.className = "fa-solid fa-times-circle text-lg text-red-400";
              authText.className = "text-red-400 font-semibold text-sm";
              authText.textContent = "Błąd";
              allServicesOnline = false;
            }

            // Sprawdź domenę - dostępność głównego pliku index.html
            try {
              const response = await fetch(window.location.origin + '/index.html', {
              method: "HEAD",
                cache: "no-cache"
              });

              if (response.ok) {
                const domainOnline = true;

                // Sprawdź czy już istnieje zdarzenie service_online
                const lastOnlineEvent = await getLastEventForService('Domena', 'service_online');
                if (!lastOnlineEvent) {
                  logSystemEvent('service_online', null, 'Domena', 'Domena główna przywrócona', 'success');
                }

                domainIcon.className = "fa-solid fa-check-circle text-lg text-green-400";
              domainText.className = "text-green-400 font-semibold text-sm";
                domainText.textContent = "Dostępna";
              } else {
                const domainOnline = false;

                // Sprawdź czy już istnieje zdarzenie service_offline
                const lastOfflineEvent = await getLastEventForService('Domena', 'service_offline');
                if (!lastOfflineEvent) {
                  logSystemEvent('service_offline', null, 'Domena', 'Domena główna niedostępna (HTTP ' + response.status + ')', 'error');
                }

                domainIcon.className = "fa-solid fa-times-circle text-lg text-red-400";
                domainText.className = "text-red-400 font-semibold text-sm";
                domainText.textContent = "Niedostępna (" + response.status + ")";
                allServicesOnline = false;
              }
            } catch (error) {
              console.error("Domain error:", error);
              const domainOnline = false;

              // Sprawdź czy już istnieje zdarzenie service_offline
              const lastOfflineEvent = await getLastEventForService('Domena', 'service_offline');
              if (!lastOfflineEvent) {
                logSystemEvent('service_offline', null, 'Domena', 'Błąd dostępu do domeny głównej: ' + error.message, 'error');
              }

              domainIcon.className = "fa-solid fa-times-circle text-lg text-red-400";
              domainText.className = "text-red-400 font-semibold text-sm";
              domainText.textContent = "Błąd";
              allServicesOnline = false;
            }

            // Aktualizuj kolor zakładki status
          const statusTabText = document.getElementById("status-tab-text");
            if (allServicesOnline) {
              statusTabText.className = "text-green-400";
            } else {
              statusTabText.className = "text-red-400";
            }

            // Aktualizuj czas ostatniego sprawdzenia
          const lastStatusCheckEl = document.getElementById("last-status-check");
          if (lastStatusCheckEl) lastStatusCheckEl.textContent = new Date().toLocaleString("pl-PL");

            // Sprawdź również status subdomen
            await checkSitesStatus();

            showNotification("Status wszystkich usług został zaktualizowany", "success");
          } catch (error) {
            console.error("Error checking main services:", error);
            showNotification("Błąd sprawdzania statusu usług", "error");
          }
        }


        async function clearAllEvents() {
          if (!confirm('Czy na pewno chcesz usunąć WSZYSTKIE zdarzenia? Tej operacji nie można cofnąć.')) {
            return;
          }

          try {
            // Pobierz wszystkie zdarzenia systemowe i usuń je
            const eventsRef = collection(db, 'system_events');
            const querySnapshot = await getDocs(eventsRef);

            if (querySnapshot.empty) {
              showNotification("Brak zdarzeń do usunięcia", "info");
              return;
            }

            // Usuń wszystkie dokumenty wsadowo
            const batch = writeBatch(db);
            querySnapshot.docs.forEach((document) => {
              batch.delete(document.ref);
            });
            await batch.commit();

            showNotification(`Usunięto ${querySnapshot.docs.length} zdarzeń`, "success");
          } catch (error) {
            console.error('Error clearing events:', error);
            showNotification("Błąd podczas usuwania zdarzeń", "error");
          }

          // Odśwież tabelę
          loadEventsLog();
        }

        window.checkSitesStatus = checkSitesStatus;
        window.checkMainServicesStatus = checkMainServicesStatus;
        window.refreshEvents = loadRecentEvents;
        window.loadEventsLog = loadEventsLog;
        window.deleteEvent = deleteEvent;
        window.clearAllEvents = clearAllEvents;

        // Sprawdź dostępność API przy starcie
        async function checkApiAvailability() {
          try {
            // Sprawdź dostępność Firestore
            const testRef = collection(db, 'system_events');
            await getDocs(query(testRef, limit(1)));
            return true;
          } catch (error) {
            console.warn('Firestore niedostępne:', error.message);
            return false;
          }
        }

        // Inicjalizacja - załaduj logi zdarzeń jeśli jesteśmy w zakładce status
        if (document.querySelector('#tab-status.active')) {
          setTimeout(async () => {
            const apiAvailable = await checkApiAvailability();
            if (!apiAvailable) {
              console.warn('API niedostępne - niektóre funkcje mogą nie działać');
              const container = document.getElementById('events-log-container');
              if (container) {
                container.innerHTML = '<div class="text-center text-orange-400 py-4"><i class="fa-solid fa-exclamation-triangle mr-2"></i>API serwera niedostępne - sprawdź konfigurację</div>';
              }
            } else {
              loadEventsLog();
            }
          }, 100);
        }
        window.openEventsPanel = () => {
          // TODO: Implement full events panel with filtering
        alert("Panel wszystkich zdarzeń będzie dostępny wkrótce");
        };
        window.showEventDetails = showEventDetails;

      // Integracja z activityLogs - Firestore listener
      function setupActivityLogsListener() {
        if (activityLogsListener) {
          clearInterval(activityLogsListener); // Odłącz poprzedni interval
        }

        // Zamiast real-time listener, użyj pollingu co 30 sekund z bezpośrednim odczytem z Firestore
        activityLogsListener = setInterval(async () => {
          try {
            // Pobierz activity logs bezpośrednio z Firestore
            const activityLogsRef = collection(db, 'activityLogs');
            const q = query(activityLogsRef, orderBy('timestamp', 'desc'), limit(10));
            const querySnapshot = await getDocs(q);

            const logs = [];
            querySnapshot.forEach((doc) => {
              logs.push({
                id: doc.id,
                ...doc.data(),
                timestamp: doc.data().timestamp?.toDate?.()?.toISOString() || doc.data().timestamp
              });
            });

            eventsData = logs;
            renderRecentEvents();
            const lastEventsUpdateEl = document.getElementById("last-events-update");
            if (lastEventsUpdateEl) lastEventsUpdateEl.textContent = new Date().toLocaleString("pl-PL");
          } catch (error) {
            console.error("Activity logs polling error:", error);
            showNotification("Błąd ładowania logów aktywności.", "error");
          }
        }, 30000); // Co 30 sekund

        // Pierwsze wywołanie natychmiastowe z bezpośrednim odczytem z Firestore
        setTimeout(async () => {
          try {
            // Pobierz activity logs bezpośrednio z Firestore
            const activityLogsRef = collection(db, 'activityLogs');
            const q = query(activityLogsRef, orderBy('timestamp', 'desc'), limit(10));
            const querySnapshot = await getDocs(q);

            const logs = [];
            querySnapshot.forEach((doc) => {
              logs.push({
                id: doc.id,
                ...doc.data(),
                timestamp: doc.data().timestamp?.toDate?.()?.toISOString() || doc.data().timestamp
              });
            });

            eventsData = logs;
            renderRecentEvents();
            const lastEventsUpdateEl = document.getElementById("last-events-update");
            if (lastEventsUpdateEl) lastEventsUpdateEl.textContent = new Date().toLocaleString("pl-PL");
          } catch (error) {
            console.error("Initial activity logs load error:", error);
          }
        }, 1000);
      }

      function setupPendingTasksListener() {
        if (pendingTasksListener) {
          clearInterval(pendingTasksListener); // Odłącz poprzedni interval
        }

        // Zamiast real-time listener, użyj pollingu co 60 sekund
        pendingTasksListener = setInterval(async () => {
          try {
            await loadPendingTasksCount(); // Użyj istniejącej funkcji
          } catch (error) {
            console.error("Pending tasks polling error:", error);
          }
        }, 60000); // Co 60 sekund

        // Pierwsze wywołanie natychmiastowe
        setTimeout(async () => {
          try {
            await loadPendingTasksCount();
          } catch (error) {
            console.error("Initial pending tasks load error:", error);
          }
        }, 2000);
      }

      // Funkcja renderowania pojedynczego logu aktywności
      // Mapowanie akcji na czytelne polskie nazwy
      function getActionLabel(action) {
        const actionLabels = {
          "ADMIN_LOGIN_SUCCESS": "Zalogowanie administratora",
          "ADMIN_LOGIN_FAILED": "Nieudane logowanie administratora",
          "USER_UNBLOCKED": "Odblokowanie użytkownika",
          "USER_BLOCKED": "Zablokowanie użytkownika",
          "USER_DELETED": "Usunięcie użytkownika",
          "USER_CREATED": "Utworzenie użytkownika",
          "PASSWORD_RESET_REQUEST": "Żądanie resetu hasła",
          "ROLE_CHANGE": "Zmiana roli użytkownika",
          "PROFILE_EDITED": "Edycja profilu",
          "MESSAGE_SENT": "Wysłanie wiadomości do administracji",
          "LIKE_BLOG": "Polubienie posta",
          "CONTACT_FORM": "Wypełnienie formularza kontaktowego",
          "USER_REGISTER": "Rejestracja użytkownika",
          "PRODUCT_VIEW": "Przeglądanie produktu",
          "PRODUCT_CREATED": "Wystawienie oferty w sklepie",
          "REVIEW_CREATED": "Wystawienie opinii",
          "service_online": "Usługa włączona",
          "service_offline": "Usługa wyłączona",
          "site_online": "Strona włączona",
          "site_offline": "Strona wyłączona"
        };
        return actionLabels[action] || action || "Nieznana akcja";
      }


      // Synchroniczna wersja dla renderowania (używa tylko dostępnych danych)
      function getUserDisplayName(event) {
        if (event.userEmail) {
          return event.userEmail;
        }
        if (event.userId === "system") {
          return "System";
        }
        if (event.userId === "anonymous") {
          return "Użytkownik niezalogowany";
        }
        if (event.userId) {
          // Jeśli userId jest emailem, użyj go
          if (event.userId.includes("@")) {
            return event.userId;
          }
          // Sprawdź czy w details jest email lub login (priorytet dla adminEmail)
          if (event.details && typeof event.details === 'object') {
            if (event.details.adminEmail) return event.details.adminEmail;
            if (event.details.email) return event.details.email;
            if (event.details.login) return event.details.login;
            if (event.details.userEmail) return event.details.userEmail;
          }
          // Jeśli nie ma emaila, pokaż jako niezalogowany
          return "Użytkownik niezalogowany";
        }
        return "Użytkownik niezalogowany";
      }

      // Asynchroniczna wersja do pobierania nazwy użytkownika z Firestore
      async function getUserDisplayNameAsync(event) {
        if (event.userEmail) {
          return event.userEmail;
        }
        if (event.userId === "system" || event.userId === "anonymous") {
          return event.userId === "system" ? "System" : "Użytkownik niezalogowany";
        }
        if (event.userId) {
          // Jeśli userId jest emailem, użyj go
          if (event.userId.includes("@")) {
          return event.userId;
        }
          // Sprawdź czy w details jest email (priorytet dla adminEmail)
          if (event.details && typeof event.details === 'object') {
            if (event.details.adminEmail) return event.details.adminEmail;
            if (event.details.email) return event.details.email;
            if (event.details.login) return event.details.login;
            if (event.details.userEmail) return event.details.userEmail;
          }
          // Spróbuj pobrać z Firestore
          try {
            const userDoc = await getDoc(doc(db, "userProfiles", event.userId));
            if (userDoc.exists()) {
              const userData = userDoc.data();
              return userData.email || userData.displayName || userData.name || "Użytkownik niezalogowany";
            }
          } catch (e) {
            console.warn("Could not fetch user name:", e);
          }
          return "Użytkownik niezalogowany";
        }
        return "Użytkownik niezalogowany";
      }

      // Funkcja pomocnicza do pobierania nicku użytkownika na podstawie ID
      async function getUserNicknameByIdAsync(userId) {
        if (!userId || userId === "system" || userId === "anonymous") {
          return null;
        }
        try {
          const userDoc = await getDoc(doc(db, "userProfiles", userId));
          if (userDoc.exists()) {
            const userData = userDoc.data();
            // Zwróć displayName (nick) użytkownika, jeśli nie ma to email
            if (userData.displayName) {
              return userData.displayName;
            }
            if (userData.email) {
              return userData.email;
            }
          }
        } catch (e) {
          console.warn("Could not fetch user nickname for userId:", userId, e);
        }
        return null;
      }

      async function renderActivityLog(event) {
        let description = "";
        let content = "";
        let details = "";

        // Użyj właściwych pól z bazy danych
        const action = event.action || event.type || "UNKNOWN";
        // Użyj userDisplayName jeśli jest dostępne (z getUserDisplayNameAsync), w przeciwnym razie użyj synchronicznej wersji
        const userDisplayName = event.userDisplayName || getUserDisplayName(event);
        const actionLabel = getActionLabel(action);
        const eventDetails = event.details || {};
        const detailsText = typeof eventDetails === 'string' ? eventDetails : JSON.stringify(eventDetails);

        switch (action) {
          case "MESSAGE_SENT":
            description = `${userDisplayName} wysłał wiadomość`;
            content = eventDetails.content || eventDetails.message || "Treść niedostępna";
            details = `Użytkownik ${userDisplayName} wysłał wiadomość${eventDetails.recipient ? ` do ${eventDetails.recipient}` : ""}${content !== "Treść niedostępna" ? ` o treści: "${content}"` : ""}`;
            break;
          case "LIKE_BLOG":
            description = `${userDisplayName} polubił post`;
            content = eventDetails.title || eventDetails.postTitle || "Tytuł niedostępny";
            details = `Użytkownik ${userDisplayName} polubił post na blogu: "${content}"`;
            break;
          case "CONTACT_FORM":
            description = `${userDisplayName} wypełnił formularz kontaktowy`;
            content = eventDetails.subject || eventDetails.topic || "Zapytanie";
            details = `Użytkownik ${userDisplayName} wypełnił formularz kontaktowy z tematem: "${content}"`;
            break;
          case "USER_REGISTER":
            description = `${userDisplayName} zarejestrował się`;
            content = "Nowe konto";
            details = `Użytkownik ${userDisplayName} pomyślnie zarejestrował nowe konto w systemie`;
            break;
          case "PRODUCT_VIEW":
            description = `${userDisplayName} przeglądał produkt`;
            content = eventDetails.productName || "Produkt";
            details = `Użytkownik ${userDisplayName} przeglądał produkt: "${content}"`;
            break;
          case "ADMIN_LOGIN_SUCCESS":
            description = `${userDisplayName} zalogował się jako administrator`;
            content = "Logowanie administratora";
            details = `Administrator ${userDisplayName} pomyślnie zalogował się do panelu administracyjnego`;
            break;
          case "ADMIN_LOGIN_FAILED":
            description = `Nieudana próba logowania administratora`;
            content = "Błąd logowania";
            details = `Nieudana próba logowania${eventDetails.email ? ` dla użytkownika ${eventDetails.email}` : ""}${eventDetails.reason ? `. Powód: ${eventDetails.reason}` : ""}`;
            break;
          case "USER_BLOCKED":
            // Użyj targetUserId jeśli dostępne, w przeciwnym razie eventDetails.targetUser
            const blockedUserId = event.targetUserId || eventDetails.targetUser || "Użytkownik";
            // Pobierz nick użytkownika zamiast ID
            const blockedUserNickname = event.targetUserNickname || await getUserNicknameByIdAsync(blockedUserId);
            const blockedUserDisplay = blockedUserNickname || blockedUserId;
            description = `${userDisplayName} zablokował użytkownika ${blockedUserDisplay}`;
            content = blockedUserDisplay;
            let blockDetails = `Administrator ${userDisplayName} zablokował użytkownika ${blockedUserDisplay}`;
            if (eventDetails.blockReason) {
              blockDetails += `. Powód: ${eventDetails.blockReason}`;
            }
            if (eventDetails.duration) {
              const durationText = eventDetails.duration === "permanent" ? "na zawsze" : eventDetails.duration;
              blockDetails += `. Czas trwania: ${durationText}`;
            }
            if (eventDetails.blockedUntil && !eventDetails.isPermanent) {
              const blockedUntilDate = eventDetails.blockedUntil.toDate ? eventDetails.blockedUntil.toDate() : new Date(eventDetails.blockedUntil);
              blockDetails += `. Blokada do: ${blockedUntilDate.toLocaleString("pl-PL")}`;
            }
            details = blockDetails;
            break;
          case "USER_UNBLOCKED":
            // Użyj targetUserId jeśli dostępne, w przeciwnym razie eventDetails.targetUser
            const unblockedUserId = event.targetUserId || eventDetails.targetUser || "Użytkownik";
            // Pobierz nick użytkownika zamiast ID
            const unblockedUserNickname = event.targetUserNickname || await getUserNicknameByIdAsync(unblockedUserId);
            const unblockedUserDisplay = unblockedUserNickname || unblockedUserId;
            description = eventDetails.automatic ? `System automatycznie odblokował użytkownika ${unblockedUserDisplay}` : `${userDisplayName} odblokował użytkownika ${unblockedUserDisplay}`;
            content = unblockedUserDisplay;
            let unblockDetails = eventDetails.automatic 
              ? `System automatycznie odblokował użytkownika ${unblockedUserDisplay}${eventDetails.reason ? `. ${eventDetails.reason}` : ""}`
              : `Administrator ${userDisplayName} odblokował użytkownika ${unblockedUserDisplay}`;
            details = unblockDetails;
            break;
          case "USER_DELETED":
            description = `${userDisplayName} usunął użytkownika`;
            content = eventDetails.targetUser || "Użytkownik";
            details = `Administrator ${userDisplayName} usunął użytkownika: ${content}`;
            break;
          case "PASSWORD_RESET_REQUEST":
            description = `${userDisplayName} żąda resetu hasła`;
            content = "Reset hasła";
            details = `Użytkownik ${userDisplayName} złożył żądanie resetu hasła`;
            break;
          case "ROLE_CHANGE":
            description = `${userDisplayName} zmienił rolę użytkownika`;
            content = eventDetails.targetUser || "Użytkownik";
            const oldRole = eventDetails.oldRole || "nieznana";
            const newRole = eventDetails.newRole || "nieznana";
            details = `Administrator ${userDisplayName} zmienił rolę użytkownika ${content} z "${oldRole}" na "${newRole}"`;
            break;
          case "PROFILE_EDITED":
            description = `${userDisplayName} edytował profil`;
            content = eventDetails.targetUser || userDisplayName;
            details = `Profil użytkownika ${content} został zedytowany${eventDetails.changes ? `. Zmiany: ${typeof eventDetails.changes === 'string' ? eventDetails.changes : JSON.stringify(eventDetails.changes)}` : ""}`;
            break;
          case "PRODUCT_CREATED":
            description = `${userDisplayName} wystawił ofertę w sklepie`;
            content = eventDetails.productName || "Produkt";
            details = `Użytkownik ${userDisplayName} wystawił nową ofertę: "${content}"`;
            break;
          case "REVIEW_CREATED":
            description = `${userDisplayName} wystawił opinię`;
            content = eventDetails.productName || eventDetails.target || "Produkt";
            details = `Użytkownik ${userDisplayName} wystawił opinię dla: ${content}`;
            break;
          case "USER_CREATED":
            description = `Utworzono nowe konto użytkownika`;
            content = eventDetails.email || eventDetails.userId || "Użytkownik";
            details = `Nowe konto zostało utworzone dla: ${content}`;
            break;
          case "service_online":
            const serviceName = typeof eventDetails === 'object' ? (eventDetails.service || 'Nieznana') : 'Nieznana';
            const serviceDetails = typeof eventDetails === 'string' ? eventDetails : (eventDetails.details || `Usługa ${serviceName} została przywrócona`);
            description = `Usługa "${serviceName}" została włączona`;
            content = serviceDetails;
            details = serviceDetails;
            break;
          case "service_offline":
            const serviceNameOff = typeof eventDetails === 'object' ? (eventDetails.service || 'Nieznana') : 'Nieznana';
            const serviceDetailsOff = typeof eventDetails === 'string' ? eventDetails : (eventDetails.details || `Usługa ${serviceNameOff} stała się niedostępna`);
            description = `Usługa "${serviceNameOff}" została wyłączona`;
            content = serviceDetailsOff;
            details = serviceDetailsOff;
            break;
          case "site_online":
            const siteName = typeof eventDetails === 'object' ? (eventDetails.site || 'Nieznana') : 'Nieznana';
            const siteDetails = typeof eventDetails === 'string' ? eventDetails : (eventDetails.details || `Strona ${siteName} wróciła do działania`);
            description = `Strona "${siteName}" wróciła do działania`;
            content = siteDetails;
            details = siteDetails;
            break;
          case "site_offline":
            const siteNameOff = typeof eventDetails === 'object' ? (eventDetails.site || 'Nieznana') : 'Nieznana';
            const siteDetailsOff = typeof eventDetails === 'string' ? eventDetails : (eventDetails.details || `Strona ${siteNameOff} stała się niedostępna`);
            description = `Strona "${siteNameOff}" stała się niedostępna`;
            content = siteDetailsOff;
            details = siteDetailsOff;
            break;
          default:
            description = `${userDisplayName} wykonał akcję: ${actionLabel}`;
            content = actionLabel;
            if (detailsText && detailsText !== "{}" && detailsText !== "") {
              details = `Użytkownik ${userDisplayName} wykonał akcję "${actionLabel}". Szczegóły: ${detailsText}`;
            } else {
              details = `Użytkownik ${userDisplayName} wykonał akcję "${actionLabel}"`;
            }
        }

        return { description, content, details };
      }

      // Funkcje liczników formularzy i niezakończonych spraw
      async function loadContactFormsCount() {
        try {
          // Pobierz liczbę formularzy kontaktowych z dzisiaj bezpośrednio z Firestore
          const today = new Date();
          today.setHours(0, 0, 0, 0);
          const tomorrow = new Date(today);
          tomorrow.setDate(tomorrow.getDate() + 1);

          const messagesRef = collection(db, 'messages');
          const q = query(
            messagesRef,
            where('recipientId', '==', 'admin'),
            where('timestamp', '>=', today),
            where('timestamp', '<', tomorrow)
          );
          const querySnapshot = await getDocs(q);

          const count = querySnapshot.size;
          const todayContactsEl = document.getElementById("new-forms-today");
          if (!todayContactsEl) return;
          todayContactsEl.textContent = count;
        } catch (error) {
          console.error("Error loading contact forms count:", error);
          const todayContactsEl = document.getElementById("new-forms-today");
          if (!todayContactsEl) return;
          todayContactsEl.textContent = "0";
        }
      }

      async function loadPendingTasksCount() {
        try {
          // Pobierz liczbę oczekujących zadań bezpośrednio z Firestore
          const messagesRef = collection(db, 'messages');
          const q = query(
            messagesRef,
            where('recipientId', '==', 'admin'),
            where('status', '==', 'in_progress')
          );
          const querySnapshot = await getDocs(q);

          const count = querySnapshot.size;
          const pendingTasksEl = document.getElementById("pending-issues");
          if (!pendingTasksEl) return;
          pendingTasksEl.textContent = count;
        } catch (error) {
          console.error("Error loading pending tasks count:", error);
          const pendingTasksEl = document.getElementById("pending-issues");
          if (!pendingTasksEl) return;
          pendingTasksEl.textContent = "0";
        }
      }

      // Placeholder dla Google Analytics - przygotowanie do integracji
      // UWAGA: Nie resetujemy wartości odwiedzin tutaj, ponieważ są one już pobierane z Firestore
      // w funkcji loadActivityStats(). Ta funkcja jest tylko placeholderem dla przyszłej integracji z GA.
      async function fetchGAStatistics() {
        try {
          // TODO: Integracja z Google Analytics Data API
          // Wymaga Service Account i odpowiednich uprawnień
          // W przyszłości można tutaj dodać dodatkowe statystyki z GA, które nie nadpisują
          // wartości odwiedzin pobranych z Firestore

          const today = new Date().toISOString().split("T")[0];
          const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)
            .toISOString()
            .split("T")[0];
          const monthAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)
            .toISOString()
            .split("T")[0];
          const yearAgo = new Date(Date.now() - 365 * 24 * 60 * 60 * 1000)
            .toISOString()
            .split("T")[0];

          // Placeholder - w rzeczywistości pobierać z GA API
          // NIE resetujemy wartości odwiedzin - są one już pobierane z Firestore w loadActivityStats()
          console.log("GA Statistics fetched (placeholder implementation)");
        } catch (error) {
          console.error("Error fetching GA statistics:", error);
          // Nie resetujemy wartości odwiedzin w przypadku błędu
        }
      }

      window.editProduct = (productId) => {
        const product = productsList.find((p) => p.id === productId);
        if (!product) return;

        document.getElementById("product-id").value = product.id;
        document.getElementById("product-title").value = product.title || "";
        document.getElementById("product-price").value = product.price || "";
        document.getElementById("product-description").innerHTML =
          product.description || "";

        // Scroll do formularza
        document
          .querySelector("#tab-products")
          .scrollIntoView({ behavior: "smooth" });
      };

      window.deleteProduct = async (productId) => {
        if (!confirm("Czy na pewno chcesz usunąć ten produkt?")) return;

        try {
          await deleteDoc(doc(db, "products", productId));
          showNotification("Produkt został usunięty.");
          loadProducts();
        } catch (error) {
          console.error("Error deleting product:", error);
          showNotification("Błąd usuwania produktu.", "error");
        }
      };

      window.sendMessage = () => {
        // Placeholder - implementacja wysyłania wiadomości
        showNotification(
          "Funkcja wysyłania wiadomości będzie dostępna wkrótce.",
        );
      };

      window.addTopic = () => {
        // Placeholder - implementacja dodawania tematu
        showNotification("Funkcja dodawania tematu będzie dostępna wkrótce.");
      };

      // Obsługa formularza produktu
      document
        .getElementById("product-form")
        .addEventListener("submit", async (e) => {
          e.preventDefault();

          const productId = document.getElementById("product-id").value;
          const title = document.getElementById("product-title").value.trim();
          const price = document.getElementById("product-price").value.trim();
          const description = document.getElementById(
            "product-description",
          ).innerHTML;

          if (!title || !price) {
            showNotification("Wypełnij wszystkie wymagane pola.", "error");
            return;
          }

          try {
            const productData = {
              title,
              price,
              description,
              date: Date.now(),
              order: productsList.length,
            };

            if (productId) {
              // Aktualizacja istniejącego produktu
              await updateDoc(doc(db, "products", productId), productData);
              showNotification("Produkt został zaktualizowany.");
            } else {
              // Dodanie nowego produktu
              await addDoc(collection(db, "products"), productData);
              showNotification("Produkt został dodany.");
              // Zaloguj utworzenie produktu
              if (currentUser) {
                await logActivity(currentUser.uid, "PRODUCT_CREATED", {
                  productName: title,
                  productId: productData.id || "nowy",
                });
              }
            }

            // Wyczyść formularz
            document.getElementById("product-form").reset();
            document.getElementById("product-description").innerHTML = "";
            document.getElementById("product-id").value = "";

            loadProducts();
          } catch (error) {
            console.error("Error saving product:", error);
            showNotification("Błąd zapisywania produktu.", "error");
          }
        });

      window.clearProductForm = () => {
        document.getElementById("product-form").reset();
        document.getElementById("product-description").innerHTML = "";
        document.getElementById("product-id").value = "";
      };

      // Funkcje zarządzania szkoleniami
      async function loadTrainings() {
        try {
          const q = query(collection(db, "trainings"), orderBy("order", "asc"));
          const snapshot = await getDocs(q);
          trainingsList = snapshot.docs.map((doc) => ({
            id: doc.id,
            ...doc.data(),
          }));

          renderTrainingsList();
          document.getElementById("trainings-loading").classList.add("hidden");
          if (trainingsList.length === 0) {
            document.getElementById("trainings-empty").classList.remove("hidden");
          } else {
            document.getElementById("trainings-empty").classList.add("hidden");
          }
        } catch (error) {
          console.error("Error loading trainings:", error);
          showNotification("Błąd ładowania szkoleń.", "error");
          document.getElementById("trainings-loading").classList.add("hidden");
        }
      }

      function renderTrainingsList() {
        const trainingsHtml = trainingsList
          .map(
            (training) => `
                <div class="flex justify-between items-center p-3 bg-zinc-800 rounded-lg">
                    <div class="flex-1">
                        <div class="font-semibold">${training.title}</div>
                        <div class="text-sm text-zinc-400">${training.price} zł</div>
                        <div class="text-xs text-zinc-500 mt-1">
                          ${training.available === true ? '<span class="text-green-400">Dostępne dla wszystkich</span>' : '<span class="text-yellow-400">Ograniczony dostęp</span>'}
                        </div>
                    </div>
                    <div class="flex space-x-2">
                        <button onclick="editTraining('${training.id}')" class="text-blue-400 hover:text-blue-300 px-2 py-1 border border-blue-400 rounded text-xs">Edytuj</button>
                        <button onclick="moveTrainingUp('${training.id}')" class="text-zinc-400 hover:text-zinc-300 px-2 py-1 border border-zinc-400 rounded text-xs" ${trainingsList.findIndex(t => t.id === training.id) === 0 ? 'disabled' : ''}>↑</button>
                        <button onclick="moveTrainingDown('${training.id}')" class="text-zinc-400 hover:text-zinc-300 px-2 py-1 border border-zinc-400 rounded text-xs" ${trainingsList.findIndex(t => t.id === training.id) === trainingsList.length - 1 ? 'disabled' : ''}>↓</button>
                        <button onclick="deleteTraining('${training.id}')" class="text-red-400 hover:text-red-300 px-2 py-1 border border-red-400 rounded text-xs">Usuń</button>
                    </div>
                </div>
            `,
          )
          .join("");

        document.getElementById("trainings-list").innerHTML =
          trainingsHtml ||
          '<div class="text-center text-zinc-500 py-4">Brak szkoleń</div>';
      }

      window.editTraining = async (trainingId) => {
        const training = trainingsList.find((t) => t.id === trainingId);
        if (!training) return;

        currentTrainingId = trainingId;
        document.getElementById("training-id").value = training.id;
        document.getElementById("training-title").value = training.title || "";
        document.getElementById("training-price").value = training.price || "";
        document.getElementById("training-img").value = training.img || "";
        document.getElementById("training-available-all").checked = training.available === true;
        document.getElementById("training-description").innerHTML = training.desc || "";

        // Pokaż sekcję zarządzania dostępem
        document.getElementById("training-access-section").classList.remove("hidden");
        
        // Załaduj listę użytkowników do selecta
        await loadTrainingUsersSelect();
        
        // Załaduj listę użytkowników z dostępem
        await loadTrainingAccessList(trainingId);

        // Scroll do formularza
        document
          .querySelector("#tab-szkolenia")
          .scrollIntoView({ behavior: "smooth" });
      };

      window.deleteTraining = async (trainingId) => {
        if (!confirm("Czy na pewno chcesz usunąć to szkolenie?")) return;

        try {
          // Usuń również dostęp użytkowników
          const accessRef = collection(db, "trainingAccess");
          const accessQuery = query(accessRef, where("trainingId", "==", trainingId));
          const accessSnapshot = await getDocs(accessQuery);
          const deletePromises = accessSnapshot.docs.map(doc => deleteDoc(doc.ref));
          await Promise.all(deletePromises);

          await deleteDoc(doc(db, "trainings", trainingId));
          showNotification("Szkolenie zostało usunięte.");
          loadTrainings();
        } catch (error) {
          console.error("Error deleting training:", error);
          showNotification("Błąd usuwania szkolenia.", "error");
        }
      };

      window.moveTrainingUp = async (trainingId) => {
        const index = trainingsList.findIndex(t => t.id === trainingId);
        if (index <= 0) return;

        try {
          const currentTraining = trainingsList[index];
          const previousTraining = trainingsList[index - 1];
          
          const currentOrder = currentTraining.order;
          const previousOrder = previousTraining.order;

          await updateDoc(doc(db, "trainings", currentTraining.id), { order: previousOrder });
          await updateDoc(doc(db, "trainings", previousTraining.id), { order: currentOrder });

          loadTrainings();
        } catch (error) {
          console.error("Error moving training up:", error);
          showNotification("Błąd zmiany pozycji szkolenia.", "error");
        }
      };

      window.moveTrainingDown = async (trainingId) => {
        const index = trainingsList.findIndex(t => t.id === trainingId);
        if (index >= trainingsList.length - 1) return;

        try {
          const currentTraining = trainingsList[index];
          const nextTraining = trainingsList[index + 1];
          
          const currentOrder = currentTraining.order;
          const nextOrder = nextTraining.order;

          await updateDoc(doc(db, "trainings", currentTraining.id), { order: nextOrder });
          await updateDoc(doc(db, "trainings", nextTraining.id), { order: currentOrder });

          loadTrainings();
        } catch (error) {
          console.error("Error moving training down:", error);
          showNotification("Błąd zmiany pozycji szkolenia.", "error");
        }
      };

      window.addNewTraining = () => {
        clearTrainingForm();
        document.getElementById("training-access-section").classList.add("hidden");
        currentTrainingId = null;
      };

      window.clearTrainingForm = () => {
        document.getElementById("training-form").reset();
        document.getElementById("training-description").innerHTML = "";
        document.getElementById("training-id").value = "";
        document.getElementById("training-access-section").classList.add("hidden");
        currentTrainingId = null;
      };

      window.refreshTrainings = async () => {
        const refreshBtn = document.getElementById("refresh-trainings-btn");
        const refreshIcon = document.getElementById("refresh-trainings-icon");
        if (refreshBtn && refreshIcon) {
          refreshIcon.classList.add("fa-spin");
          try {
            await loadTrainings();
          } finally {
            refreshIcon.classList.remove("fa-spin");
          }
        }
      };

      async function loadTrainingUsersSelect() {
        const select = document.getElementById("training-user-select");
        if (!select) return;

        try {
          const snapshot = await getDocs(collection(db, "userProfiles"));
          const users = [];
          snapshot.forEach((doc) => {
            const userData = doc.data();
            users.push({
              id: doc.id,
              name: userData.displayName || userData.email || "Użytkownik",
              email: userData.email || "",
            });
          });

          select.innerHTML = '<option value="">Wybierz użytkownika...</option>' +
            users.map(user => 
              `<option value="${user.id}">${user.name} (${user.email})</option>`
            ).join("");
        } catch (error) {
          console.error("Error loading users for training access:", error);
        }
      }

      async function loadTrainingAccessList(trainingId) {
        const accessList = document.getElementById("training-access-list");
        if (!accessList || !trainingId) return;

        try {
          const accessRef = collection(db, "trainingAccess");
          const accessQuery = query(accessRef, where("trainingId", "==", trainingId));
          const accessSnapshot = await getDocs(accessQuery);
          
          const accessUsers = [];
          for (const accessDoc of accessSnapshot.docs) {
            const accessData = accessDoc.data();
            const userDoc = await getDoc(doc(db, "userProfiles", accessData.userId));
            if (userDoc.exists()) {
              const userData = userDoc.data();
              accessUsers.push({
                id: accessData.userId,
                name: userData.displayName || userData.email || "Użytkownik",
                email: userData.email || "",
                accessId: accessDoc.id,
              });
            }
          }

          if (accessUsers.length === 0) {
            accessList.innerHTML = '<div class="text-sm text-zinc-500">Brak użytkowników z dostępem</div>';
          } else {
            accessList.innerHTML = accessUsers.map(user => `
              <div class="flex justify-between items-center p-2 bg-zinc-800 rounded">
                <div>
                  <div class="text-sm font-medium">${user.name}</div>
                  <div class="text-xs text-zinc-400">${user.email}</div>
                </div>
                <button
                  onclick="removeTrainingAccess('${user.accessId}', '${user.name}')"
                  class="text-red-400 hover:text-red-300 text-xs px-2 py-1 border border-red-400 rounded"
                >
                  Usuń
                </button>
              </div>
            `).join("");
          }
        } catch (error) {
          console.error("Error loading training access list:", error);
          accessList.innerHTML = '<div class="text-sm text-red-400">Błąd ładowania listy dostępu</div>';
        }
      }

      window.addTrainingAccess = async () => {
        const userId = document.getElementById("training-user-select").value;
        if (!userId || !currentTrainingId) {
          showNotification("Wybierz użytkownika i szkolenie.", "error");
          return;
        }

        try {
          // Sprawdź czy użytkownik już ma dostęp
          const accessRef = collection(db, "trainingAccess");
          const accessQuery = query(
            accessRef,
            where("trainingId", "==", currentTrainingId),
            where("userId", "==", userId)
          );
          const existingAccess = await getDocs(accessQuery);

          if (!existingAccess.empty) {
            showNotification("Ten użytkownik już ma dostęp do tego szkolenia.", "error");
            return;
          }

          await addDoc(accessRef, {
            trainingId: currentTrainingId,
            userId: userId,
            grantedAt: new Date(),
            grantedBy: currentUser.uid,
          });

          showNotification("Dostęp został dodany.");
          document.getElementById("training-user-select").value = "";
          await loadTrainingAccessList(currentTrainingId);
        } catch (error) {
          console.error("Error adding training access:", error);
          showNotification("Błąd dodawania dostępu.", "error");
        }
      };

      window.removeTrainingAccess = async (accessId, userName) => {
        if (!confirm(`Czy na pewno chcesz usunąć dostęp dla ${userName}?`)) return;

        try {
          await deleteDoc(doc(db, "trainingAccess", accessId));
          showNotification("Dostęp został usunięty.");
          await loadTrainingAccessList(currentTrainingId);
        } catch (error) {
          console.error("Error removing training access:", error);
          showNotification("Błąd usuwania dostępu.", "error");
        }
      };

      // Obsługa formularza szkolenia
      document
        .getElementById("training-form")
        .addEventListener("submit", async (e) => {
          e.preventDefault();

          const trainingId = document.getElementById("training-id").value;
          const title = document.getElementById("training-title").value.trim();
          const price = document.getElementById("training-price").value.trim();
          const img = document.getElementById("training-img").value.trim();
          const desc = document.getElementById("training-description").innerHTML;
          const available = document.getElementById("training-available-all").checked;

          if (!title || !price || !img) {
            showNotification("Wypełnij wszystkie wymagane pola.", "error");
            return;
          }

          try {
            const trainingData = {
              title,
              price,
              img,
              desc,
              available: available ? true : false,
              date: Date.now(),
              order: trainingId ? trainingsList.find(t => t.id === trainingId)?.order || trainingsList.length : trainingsList.length,
            };

            if (trainingId) {
              // Aktualizacja istniejącego szkolenia
              await updateDoc(doc(db, "trainings", trainingId), trainingData);
              showNotification("Szkolenie zostało zaktualizowane.");
            } else {
              // Dodanie nowego szkolenia
              const newTrainingRef = await addDoc(collection(db, "trainings"), trainingData);
              currentTrainingId = newTrainingRef.id;
              showNotification("Szkolenie zostało dodane.");
              // Pokaż sekcję zarządzania dostępem
              document.getElementById("training-access-section").classList.remove("hidden");
              await loadTrainingUsersSelect();
            }

            // Wyczyść formularz tylko jeśli nie edytujemy
            if (!trainingId) {
              clearTrainingForm();
            } else {
              document.getElementById("training-id").value = trainingId;
            }

            loadTrainings();
          } catch (error) {
            console.error("Error saving training:", error);
            showNotification("Błąd zapisywania szkolenia.", "error");
          }
        });

      // Obsługa formularza edycji użytkownika
      document
        .getElementById("user-edit-form")
        .addEventListener("submit", async (e) => {
          e.preventDefault();

          const userId = document.getElementById("edit-user-id").value;
          if (!userId) return;

          const saveBtn = e.target.querySelector('button[type="submit"]');
          saveBtn.disabled = true;
          saveBtn.innerHTML =
            '<i class="fa-solid fa-spinner fa-spin mr-2"></i>Zapisywanie...';

          try {
            // Zaszyfruj wrażliwe dane przed zapisaniem
            const updatedProfile = {
              displayName: document
                .getElementById("edit-display-name")
                .value.trim(),
              firstName: document
                .getElementById("edit-first-name")
                .value.trim(),
              lastName: document.getElementById("edit-last-name").value.trim(),
              phone: btoa(document.getElementById("edit-phone").value.trim()),
              address: {
                street: btoa(
                  document.getElementById("edit-street").value.trim(),
                ),
                buildingNumber: btoa(
                  document.getElementById("edit-building-number").value.trim(),
                ),
                postalCode: btoa(
                  document.getElementById("edit-postal-code").value.trim(),
                ),
                city: btoa(document.getElementById("edit-city").value.trim()),
              },
              parcelLocker: btoa(
                document.getElementById("edit-parcel-locker").value.trim(),
              ),
              newsletter: document.getElementById("edit-newsletter").checked,
              role: document.getElementById("edit-role").value,
              status: document.getElementById("edit-status").value,
              updatedAt: new Date(),
              updatedBy: currentUser.uid,
            };

            await updateDoc(doc(db, "userProfiles", userId), updatedProfile);

            // Zaloguj edycję profilu
            await logActivity(userId, "PROFILE_EDITED", {
              editedBy: currentUser.uid,
              changes: Object.keys(updatedProfile),
            });

            showNotification("Dane użytkownika zostały zaktualizowane.");
            closeUserEdit();
            loadUsers(); // Odśwież listę użytkowników
          } catch (error) {
            console.error("Error updating user:", error);
            showNotification(
              "Błąd podczas aktualizacji danych użytkownika.",
              "error",
            );
          } finally {
            saveBtn.disabled = false;
            saveBtn.innerHTML =
              '<i class="fa-solid fa-save mr-2"></i>Zapisz zmiany';
          }
        });

      // Obsługa formularza blokowania użytkownika
      document
        .getElementById("user-block-form")
        .addEventListener("submit", async (e) => {
          e.preventDefault();

          const userId = document.getElementById("block-user-id").value;
          if (!userId) return;

          const duration = document.getElementById("block-duration").value;
          const blockReason = document.getElementById("block-reason").value.trim();
          
          // Walidacja powodu blokady
          if (!blockReason || blockReason.length < 10) {
            showNotification("Powód blokady jest wymagany i musi zawierać minimum 10 znaków.", "error");
            const blockBtn = e.target.querySelector('button[type="submit"]');
            if (blockBtn) {
              blockBtn.disabled = false;
              blockBtn.innerHTML = '<i class="fa-solid fa-ban mr-2"></i>Zablokuj użytkownika';
            }
            return;
          }

          const blockBtn = e.target.querySelector('button[type="submit"]');
          blockBtn.disabled = true;
          blockBtn.innerHTML =
            '<i class="fa-solid fa-spinner fa-spin mr-2"></i>Blokowanie...';

          try {
            // Oblicz datę zakończenia blokady
            let blockedUntil = null;
            const now = new Date();

            switch (duration) {
              case "15min":
                blockedUntil = new Date(now.getTime() + 15 * 60 * 1000);
                break;
              case "1hour":
                blockedUntil = new Date(now.getTime() + 60 * 60 * 1000);
                break;
              case "6hours":
                blockedUntil = new Date(now.getTime() + 6 * 60 * 60 * 1000);
                break;
              case "24hours":
                blockedUntil = new Date(now.getTime() + 24 * 60 * 60 * 1000);
                break;
              case "7days":
                blockedUntil = new Date(
                  now.getTime() + 7 * 24 * 60 * 60 * 1000,
                );
                break;
              case "30days":
                blockedUntil = new Date(
                  now.getTime() + 30 * 24 * 60 * 60 * 1000,
                );
                break;
              case "permanent":
                blockedUntil = null; // Blokada permanentna
                break;
            }

            const blockData = {
              status: "blocked",
              blockedAt: now,
              blockedUntil: blockedUntil,
              blockedBy: currentUser.uid,
              blockDuration: duration,
              isPermanentBlock: duration === "permanent",
              blockReason: blockReason,
            };

            await updateDoc(doc(db, "userProfiles", userId), blockData);

            // Zaloguj blokadę użytkownika - userId to ID administratora, targetUserId to ID zablokowanego użytkownika
            // Pobierz email administratora dla logowania
            let adminEmail = currentUser.email || null;
            if (!adminEmail && currentUser.uid) {
              try {
                const adminDoc = await getDoc(doc(db, "userProfiles", currentUser.uid));
                if (adminDoc.exists()) {
                  const adminData = adminDoc.data();
                  adminEmail = adminData.email || null;
                }
              } catch (e) {
                console.warn("Nie udało się pobrać emaila administratora:", e);
              }
            }
            
            await logActivity(currentUser.uid, "USER_BLOCKED", {
              duration: duration,
              blockedUntil: blockedUntil,
              isPermanent: duration === "permanent",
              blockedBy: currentUser.uid,
              blockReason: blockReason,
              targetUser: userId, // ID zablokowanego użytkownika
              adminEmail: adminEmail, // Email administratora dla wyświetlania
            }, userId);

            showNotification(
              `Użytkownik został zablokowany${blockedUntil ? " do " + blockedUntil.toLocaleString("pl-PL") : " na zawsze"}.`,
            );
            
            // Wyczyść formularz
            document.getElementById("block-reason").value = "";
            closeUserBlock();
            loadUsers();
          } catch (error) {
            console.error("Error blocking user:", error);
            showNotification("Błąd podczas blokowania użytkownika.", "error");
          } finally {
            blockBtn.disabled = false;
            blockBtn.innerHTML =
              '<i class="fa-solid fa-ban mr-2"></i>Zablokuj użytkownika';
          }
        });

      // Obsługa formularza usuwania użytkownika
      document
        .getElementById("user-delete-form")
        .addEventListener("submit", async (e) => {
          e.preventDefault();

          const userId = document.getElementById("delete-user-id").value;
          if (!userId) return;

          const contentAction = document.querySelector(
            'input[name="delete-content-action"]:checked',
          ).value;

          const deleteBtn = e.target.querySelector('button[type="submit"]');
          deleteBtn.disabled = true;
          deleteBtn.innerHTML =
            '<i class="fa-solid fa-spinner fa-spin mr-2"></i>Usuwanie...';

          try {
            if (contentAction === "remove") {
              // Usuń całą zawartość użytkownika - tutaj należałoby dodać logikę usuwania
              // produktów, wiadomości, komentarzy itp. z innych kolekcji
              // Na razie tylko oznaczamy, że zawartość została usunięta
              console.log("Usuwanie zawartości użytkownika:", userId);
            }

            // Usuń profil użytkownika
            await deleteDoc(doc(db, "userProfiles", userId));

            // Zaloguj usunięcie użytkownika PRZED faktycznym usunięciem
            await logActivity(userId, "USER_DELETED", {
              contentAction: contentAction,
              deletedBy: currentUser.uid,
              userEmail: currentDeletingUser.email,
              userDisplayName: currentDeletingUser.displayName,
            });

            // Usuń z listy mailingowej jeśli był zapisany
            try {
              await deleteDoc(
                doc(db, "mailingList", currentDeletingUser.email),
              );
            } catch (error) {
              // Ignoruj błąd jeśli użytkownik nie był na liście mailingowej
            }

            showNotification(
              `Użytkownik został całkowicie usunięty z systemu${contentAction === "keep" ? " (zawartość zachowana)" : " (zawartość usunięta)"}.`,
            );
            closeUserDelete();
            loadUsers();
          } catch (error) {
            console.error("Error deleting user:", error);
            showNotification("Błąd podczas usuwania użytkownika.", "error");
          } finally {
            deleteBtn.disabled = false;
            deleteBtn.innerHTML =
              '<i class="fa-solid fa-trash mr-2"></i>Usuń użytkownika';
          }
        });

        // Event listener dla formularza szybkich odpowiedzi
        document.getElementById('quick-reply-form').addEventListener('submit', async (e) => {
          e.preventDefault();

          const replyId = document.getElementById('quick-reply-id').value;
          const title = document.getElementById('quick-reply-title').value.trim();
          const content = document.getElementById('quick-reply-content').value.trim();

          if (!title || !content) {
            showNotification('Tytuł i treść odpowiedzi są wymagane', 'error');
            return;
          }

          const submitBtn = e.target.querySelector('button[type="submit"]');
          const originalText = submitBtn.innerHTML;
          submitBtn.disabled = true;
          submitBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin mr-2"></i>Zapisywanie...';

          try {
            const replyData = { title, content };
            let response;

            if (replyId) {
              // Aktualizacja istniejącego szablonu w Firestore
              const replyRef = doc(db, 'quickReplies', replyId);
              await updateDoc(replyRef, replyData);
            } else {
              // Tworzenie nowego szablonu w Firestore
              const quickRepliesRef = collection(db, 'quickReplies');
              await addDoc(quickRepliesRef, {
                ...replyData,
                createdAt: new Date()
              });
            }

            if (data.success) {
              showNotification(replyId ? 'Szablon został zaktualizowany' : 'Szablon został utworzony', 'success');
              closeQuickReplyModal();
              loadQuickReplies();
            } else {
              throw new Error(data.error || 'Failed to save quick reply');
            }
          } catch (error) {
            console.error('Error saving quick reply:', error);
            showNotification('Błąd podczas zapisywania szablonu', 'error');
          } finally {
            submitBtn.disabled = false;
            submitBtn.innerHTML = originalText;
          }
        });

        // Event listener dla formularza kategorii
        document.getElementById('category-form').addEventListener('submit', async (e) => {
          e.preventDefault();

          const submitBtn = e.target.querySelector('button[type="submit"]');
          const originalText = submitBtn.innerHTML;
          submitBtn.disabled = true;
          submitBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin mr-2"></i>Zapisywanie...';

          try {
            await saveCategory(e.target);
          } catch (error) {
            console.error('Error saving category:', error);
            showNotification('Błąd podczas zapisywania kategorii', 'error');
          } finally {
            submitBtn.disabled = false;
            submitBtn.innerHTML = originalText;
          }
        });

        // Event listener dla wyboru koloru
        document.getElementById('category-color').addEventListener('input', (e) => {
          document.getElementById('category-color-text').value = e.target.value;
        });

        // Event listener dla zmiany koloru w polu tekstowym
        document.getElementById('category-color-text').addEventListener('input', (e) => {
          const color = e.target.value;
          if (/^#[0-9A-F]{6}$/i.test(color)) {
            document.getElementById('category-color').value = color;
          }
        });

        // Event listener dla wyboru ikony
        document.getElementById('icon-picker').addEventListener('click', (e) => {
          if (e.target.closest('.icon-option')) {
            const icon = e.target.closest('.icon-option').dataset.icon;
            document.getElementById('category-icon').value = icon;
            updateIconSelection(icon);
          }
        });

      // Automatyczne odświeżanie co 1 godzinę (aby nie tracić limitów Firebase)
      setInterval(
        async () => {
          if (currentUser) {
            // Tylko dla administratorów Firebase
          try {
            await checkSitesStatus();
              // Activity logs są automatycznie aktualizowane przez listener
              console.log(
                "Dashboard auto-refreshed at",
                new Date().toLocaleString("pl-PL"),
              );
          } catch (error) {
              console.error("Auto-refresh error:", error);
            }
          }
        },
        60 * 60 * 1000,
      ); // 1 godzina

      // ===== FUNKCJE DO MODERACJI OPINII =====

      // Ładowanie opinii do moderacji
      async function loadReviews() {
        try {
          document.getElementById("reviews-loading").classList.remove("hidden");
          document.getElementById("reviews-empty").classList.add("hidden");

          const reviewsQuery = query(
            collection(db, "userReviews"),
            orderBy("timestamp", "desc"),
          );

          const reviewsSnapshot = await getDocs(reviewsQuery);
          const reviews = reviewsSnapshot.docs.map((doc) => ({
            id: doc.id,
            ...doc.data(),
          }));

          displayReviewsForModeration(reviews);
        } catch (error) {
          console.error("Błąd ładowania opinii:", error);
          showNotification("Błąd ładowania opinii", "error");
        } finally {
          document.getElementById("reviews-loading").classList.add("hidden");
        }
      }

      // Wyświetlanie opinii do moderacji
      function displayReviewsForModeration(reviews) {
        const reviewsList = document.getElementById("reviews-list");
        const reviewsEmpty = document.getElementById("reviews-empty");

        if (reviews.length === 0) {
          reviewsEmpty.classList.remove("hidden");
          reviewsList.innerHTML = "";
          return;
        }

        reviewsEmpty.classList.add("hidden");

        reviewsList.innerHTML = reviews
          .map(
            (review) => `
          <div class="admin-card" data-review-id="${review.id}">
            <div class="flex justify-between items-start mb-4">
              <div>
                <div class="font-bold text-lg">${review.raterName} → ${review.ratedName}</div>
                <div class="text-sm text-zinc-400">${formatDate(review.timestamp)}</div>
              </div>
              <div class="flex items-center space-x-2">
                <span class="status-badge status-${review.status || "pending"}">
                  ${getStatusText(review.status || "pending")}
                </span>
                <div class="flex space-x-1">
                  ${generateStars(review.rating)}
                </div>
              </div>
            </div>

            <div class="bg-zinc-800 p-4 rounded-lg mb-4">
              <p class="text-zinc-300">${review.comment}</p>
            </div>

            ${
              review.status === "pending"
                ? `
              <div class="flex space-x-2">
                <button onclick="approveReview('${review.id}')" class="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 transition">
                  <i class="fa-solid fa-check mr-2"></i>
                  Zatwierdź
                </button>
                <button onclick="rejectReview('${review.id}')" class="bg-red-600 text-white px-4 py-2 rounded hover:bg-red-700 transition">
                  <i class="fa-solid fa-times mr-2"></i>
                  Odrzuć
                </button>
              </div>
            `
                : review.status === "approved"
                  ? `
              <div class="flex space-x-2">
                <button onclick="rejectReview('${review.id}')" class="bg-red-600 text-white px-4 py-2 rounded hover:bg-red-700 transition">
                  <i class="fa-solid fa-times mr-2"></i>
                  Odrzuć
                </button>
              </div>
            `
                  : `
              <div class="flex space-x-2">
                <button onclick="approveReview('${review.id}')" class="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 transition">
                  <i class="fa-solid fa-check mr-2"></i>
                  Zatwierdź
                </button>
              </div>
            `
            }
          </div>
        `,
          )
          .join("");

        // Obsługa filtra
        document
          .getElementById("reviews-filter")
          .addEventListener("change", (e) => {
            const filter = e.target.value;
            filterReviews(reviews, filter);
          });
      }

      // Filtrowanie opinii
      function filterReviews(reviews, status) {
        let filteredReviews = reviews;

        if (status !== "all") {
          filteredReviews = reviews.filter(
            (review) => (review.status || "pending") === status,
          );
        }

        displayReviewsForModeration(filteredReviews);
      }

      // Generowanie gwiazdek dla opinii
      function generateStars(rating) {
        let stars = "";
        for (let i = 1; i <= 5; i++) {
          stars += `<i class="fa-solid fa-star ${i <= rating ? "text-yellow-400" : "text-zinc-600"}"></i>`;
        }
        return stars;
      }

      // Pobieranie tekstu statusu
      function getStatusText(status) {
        switch (status) {
          case "pending":
            return "Oczekuje";
          case "approved":
            return "Zatwierdzona";
          case "rejected":
            return "Odrzucona";
          default:
            return "Nieznany";
        }
      }

      // Zatwierdzanie opinii
      async function approveReview(reviewId) {
        try {
          await updateDoc(doc(db, "userReviews", reviewId), {
            status: "approved",
          });

          showNotification("Opinia została zatwierdzona", "success");
          loadReviews(); // Odśwież listę
        } catch (error) {
          console.error("Błąd zatwierdzania opinii:", error);
          showNotification("Błąd zatwierdzania opinii", "error");
        }
      }

      // Odrzucanie opinii
      async function rejectReview(reviewId) {
        try {
          await updateDoc(doc(db, "userReviews", reviewId), {
            status: "rejected",
          });

          showNotification("Opinia została odrzucona", "success");
          loadReviews(); // Odśwież listę
        } catch (error) {
          console.error("Błąd odrzucania opinii:", error);
          showNotification("Błąd odrzucania opinii", "error");
        }
      }

      // ===== KONIEC FUNKCJI MODERACJI OPINII =====


      // ZJEDNOCZONY SYSTEM AUTORYZACJI (Hybrid Auth)
      let localAdminLoggedIn = false; // Globalna flaga dla lokalnego administratora

      // Inicjalizacja event listenerów po załadowaniu DOM
      document.addEventListener('DOMContentLoaded', function() {
        // Event listener dla pola wiadomości - wykrywanie pisania
        const messageInput = document.getElementById("message-input");
        if (messageInput) {
          messageInput.addEventListener("input", function() {
            isTypingInMessage = this.value.length > 0;
          });

          messageInput.addEventListener("blur", function() {
            // Po krótkim opóźnieniu oznacz jako niepisanie (żeby dać czas na wysłanie)
            setTimeout(() => {
              isTypingInMessage = false;
            }, 1000);
          });
        }

        // Inicjalizacja dla zakładki messages
        if (currentTab === 'messages') {
          loadMessages();
          startAutoRefresh();
          setupTypingListeners();
        }

        // Event listener dla dropdown filtra messages
        const messagesFilter = document.getElementById('messages-filter');
        if (messagesFilter && !messagesFilter.hasFilterListener) {
          console.log('Adding filter dropdown event listener');
          messagesFilter.hasFilterListener = true;
          messagesFilter.addEventListener('change', () => {
            console.log('Filter dropdown changed to:', messagesFilter.value);
            currentFilters.category = messagesFilter.value;
            loadMessagesWithFilters();
          });
        }
      });

      // ==================== NOWE FUNKCJE DLA SYSTEMU WIADOMOŚCI ====================

      // Funkcja ładowania statusu wiadomości
      async function loadMessagesStatus() {
        try {
          // Pobierz wszystkie wiadomości admina z Firestore
          const messagesRef = collection(db, 'messages');
          const q = query(messagesRef, where('recipientId', '==', 'admin'));
          const querySnapshot = await getDocs(q);

          // Oblicz statystyki
          let total = 0;
          let unread = 0;
          let pending = 0;
          let inProgress = 0;
          let completed = 0;

          querySnapshot.forEach((doc) => {
            const message = doc.data();
            total++;

            if (!message.isRead) unread++;
            if (message.status === 'pending') pending++;
            if (message.status === 'in_progress') inProgress++;
            if (message.status === 'completed') completed++;
          });

          const stats = {
            total: total,
            unread: unread,
            pending: pending,
            in_progress: inProgress,
            completed: completed
          };

          // Logika dźwięku powiadomienia dla nowych wiadomości
          const newUnreadCount = stats.unread || 0;
          if (lastUnreadCount !== null && newUnreadCount > lastUnreadCount) {
            // Odtwórz dźwięk tylko dla nowych wiadomości przychodzących
            notificationSound.play().catch(e => console.log("Sound play deferred until user interaction"));
          }
          lastUnreadCount = newUnreadCount;

          updateMessagesStatusDisplay(stats);
        } catch (error) {
          console.error('Error loading messages status:', error);
        }
      }

      // Funkcja aktualizacji wyświetlania statusu
      async function updateMessagesStatusDisplay(stats) {
        // Update unread and total counts in header
        const unreadCountEl = document.getElementById('unread-count');
        if (unreadCountEl) {
          unreadCountEl.textContent = stats.unread || 0;
        }

        const totalCountEl = document.getElementById('total-count');
        if (totalCountEl) {
          totalCountEl.textContent = stats.total || 0;
        }

        // Load categories and create buttons
        const categoryButtonsEl = document.getElementById('category-buttons');
        if (!categoryButtonsEl) return;

        try {
          // Fetch categories from Firestore
          const categoriesRef = collection(db, "messageCategories");
          const categoriesSnapshot = await getDocs(categoriesRef);
          
          const categories = [];
          categoriesSnapshot.forEach((doc) => {
            const catData = { id: doc.id, ...doc.data() };
            if (catData.is_active !== false) { // Filtruj aktywne kategorie
              categories.push(catData);
            }
          });

            let categoryButtons = '';

            // Dodaj przycisk "Wszystkie"
            const isAllActive = !currentFilters.category || currentFilters.category === 'all' || ['unread', 'completed'].includes(currentFilters.category);
            categoryButtons += `
              <button onclick="filterMessages('all')"
                      class="px-3 py-2 rounded-lg transition-all duration-200 font-medium liquid-glass-button flex items-center gap-2"
                      style="color: #6B7280; ${isAllActive ? `background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px); border: 1px solid #6B728060;` : `background: rgba(255, 255, 255, 0.05); backdrop-filter: blur(5px); border: 1px solid rgba(255, 255, 255, 0.1);`}">
                <i class="fa-solid fa-list text-xs"></i>
                Wszystkie
              </button>
            `;

            categories.forEach(cat => {
              const isActive = currentFilters.category === cat.name.toLowerCase().replace(/\s+/g, '');
              const categoryIcon = cat.icon || 'fa-circle';
              // Użyj koloru zdefiniowanego przez użytkownika, lub domyślnego z bazy danych
              const categoryColor = userFilterColors[cat.name.toLowerCase().replace(/\s+/g, '')] || cat.color || '#6B7280';
              categoryButtons += `
                <button onclick="filterMessages('${cat.name.toLowerCase().replace(/\s+/g, '')}')"
                        class="px-3 py-2 rounded-lg transition-all duration-200 font-medium liquid-glass-button flex items-center gap-2"
                        style="color: ${categoryColor}; ${isActive ? `background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px); border: 1px solid ${categoryColor}60;` : `background: rgba(255, 255, 255, 0.05); backdrop-filter: blur(5px); border: 1px solid rgba(255, 255, 255, 0.1);`}">
                  <i class="fa-solid ${categoryIcon} text-xs"></i>
                  ${cat.name}
                </button>
              `;
            });

            categoryButtonsEl.innerHTML = categoryButtons;
        } catch (error) {
          console.error('Error loading categories for buttons:', error);
          categoryButtonsEl.innerHTML = '';
        }
      }

      // Funkcja ładowania wiadomości z filtrami
      async function loadMessagesWithFilters() {
        const messagesContainer = document.getElementById('messages-container');
        if (!messagesContainer) return;

        messagesContainer.innerHTML = `
          <div class="text-center text-zinc-500 py-12">
            <i class="fa-solid fa-spinner fa-spin text-3xl mb-4 text-zinc-600"></i>
            <h3 class="text-lg font-semibold mb-2">Ładowanie wiadomości...</h3>
            <p class="text-sm">Proszę czekać</p>
          </div>
        `;

        try {
          // Aktualizuj currentFilters.search z wartości pola wyszukiwania
          const searchInput = document.getElementById('messages-search');
          if (searchInput) {
            currentFilters.search = searchInput.value || '';
          }

          // Buduj query Firestore z filtrami
          let messagesQuery = collection(db, 'messages');

          // Zawsze filtruj po recipientId = 'admin'
          messagesQuery = query(messagesQuery, where('recipientId', '==', 'admin'));

          // Dodaj filtry
          if (currentFilters.category === 'unread') {
            messagesQuery = query(messagesQuery, where('isRead', '==', false));
          } else if (currentFilters.category === 'read') {
            messagesQuery = query(messagesQuery, where('isRead', '==', true));
          } else if (currentFilters.category === 'completed') {
            messagesQuery = query(messagesQuery, where('status', '==', 'completed'));
          } else if (currentFilters.category === 'in_progress') {
            messagesQuery = query(messagesQuery, where('status', '==', 'in_progress'));
          } else if (currentFilters.category && !['unread', 'read', 'completed', 'in_progress', 'all'].includes(currentFilters.category)) {
            // To jest filtr kategorii - znajdź ID kategorii po nazwie
            try {
              console.log('Filtering by category:', currentFilters.category);
              const categoriesRef = collection(db, 'messageCategories');
              const categoriesQuery = query(categoriesRef);
              const categoriesSnapshot = await getDocs(categoriesQuery);

              let categoryId = null;
              categoriesSnapshot.forEach((doc) => {
                const category = doc.data();
                if (category.name.toLowerCase().replace(/\s+/g, '') === currentFilters.category) {
                  categoryId = doc.id;
                }
              });

              if (categoryId) {
                messagesQuery = query(messagesQuery, where('categoryId', '==', categoryId));
                console.log('Added categoryId to query:', categoryId);
              } else {
                console.warn('Category not found for:', currentFilters.category);
              }
            } catch (error) {
              console.error('Error loading categories for filtering:', error);
            }
          }

          // Sortuj po timestamp malejąco (najnowsze najpierw)
          messagesQuery = query(messagesQuery, orderBy('timestamp', 'desc'), limit(100));

          const querySnapshot = await getDocs(messagesQuery);
          const messages = [];

          querySnapshot.forEach((doc) => {
            messages.push({
              id: doc.id,
              ...doc.data(),
              timestamp: doc.data().timestamp?.toDate?.()?.getTime() || doc.data().timestamp
            });
          });

          await displayMessages(messages);

        } catch (error) {
          console.error('Error loading messages with filters:', error);
          messagesContainer.innerHTML = `
            <div class="text-center text-red-400 py-12">
              <i class="fa-solid fa-exclamation-triangle text-4xl mb-4"></i>
              <h3 class="text-lg font-semibold mb-2">Błąd ładowania wiadomości</h3>
              <p class="text-sm">${error.message}</p>
            </div>
          `;
        }
      }

      // Funkcja wyświetlania wiadomości
      async function displayMessages(messages) {
        const messagesContainer = document.getElementById('messages-container');
        if (!messagesContainer) return;

        if (messages.length === 0) {
          messagesContainer.innerHTML = `
            <div class="text-center text-zinc-500 py-12">
              <i class="fa-solid fa-inbox text-4xl mb-4 text-zinc-600"></i>
              <h3 class="text-lg font-semibold mb-2">Brak wiadomości</h3>
              <p class="text-sm">Nie znaleziono wiadomości spełniających kryteria</p>
            </div>
          `;
          return;
        }

        // Pobierz nazwy użytkowników z kolekcji userProfiles dla wszystkich unikalnych senderId
        const uniqueSenderIds = [...new Set(messages.map(msg => msg.senderId).filter(id => id && id !== 'admin'))];
        const userNamesMap = {};
        
        if (uniqueSenderIds.length > 0) {
          try {
            const userPromises = uniqueSenderIds.map(async (userId) => {
              try {
                const userDoc = await getDoc(doc(db, "userProfiles", userId));
                if (userDoc.exists()) {
                  const userData = userDoc.data();
                  // Priorytet: displayName (nick), potem email
                  userNamesMap[userId] = userData.displayName || userData.email || null;
                }
              } catch (e) {
                console.warn(`Could not fetch user name for ${userId}:`, e);
              }
            });
            await Promise.all(userPromises);
          } catch (error) {
            console.error('Error fetching user names:', error);
          }
        }

        // Grupuj wiadomości w konwersacje
        const conversations = {};

        messages.forEach(msg => {
          if (!msg) return; // Pomiń null/undefined wiadomości

          const participants = [msg.senderId, msg.recipientId].filter(id => id).sort();
          const conversationKey = participants.join('_');

          if (!conversations[conversationKey]) {
            // Użyj nazwy z wiadomości, jeśli jest, w przeciwnym razie pobierz z userNamesMap
            const senderName = msg.senderName || userNamesMap[msg.senderId] || 'Nieznany';
            
            conversations[conversationKey] = {
              participants: participants,
              senderName: senderName,
              senderEmail: msg.senderEmail || '',
              senderId: msg.senderId || 'unknown',
              lastMessage: msg,
              messages: [],
              unreadCount: 0,
              totalMessages: 0,
              categoryName: msg.category_name || 'Inne',
              categoryColor: msg.category_color || '#6B7280'
            };
          }

          conversations[conversationKey].messages.push(msg);
          conversations[conversationKey].totalMessages++;

          if (msg.isRead === false) {
            conversations[conversationKey].unreadCount++;
          }
        });

        // Filtruj konwersacje po tekście wyszukiwania (nazwa użytkownika, email lub treść wiadomości)
        const searchTerm = (currentFilters.search || '').toLowerCase().trim();
        let filteredConversations = Object.values(conversations);
        
        if (searchTerm) {
          filteredConversations = filteredConversations.filter(conversation => {
            // Szukaj po nazwie użytkownika (nick)
            const senderName = (conversation.senderName || '').toLowerCase();
            // Szukaj po emailu
            const senderEmail = (conversation.senderEmail || '').toLowerCase();
            // Szukaj po treści wiadomości
            const messageContent = (conversation.lastMessage?.content || '').toLowerCase();
            const messageTopic = (conversation.lastMessage?.topic || '').toLowerCase();
            
            return senderName.includes(searchTerm) || 
                   senderEmail.includes(searchTerm) || 
                   messageContent.includes(searchTerm) ||
                   messageTopic.includes(searchTerm);
          });
        }

        // Konwertuj na tablicę i posortuj
        const conversationsArray = filteredConversations.sort((a, b) => {
          // Najpierw nieprzeczytane
          if (a.unreadCount > 0 && b.unreadCount === 0) return -1;
          if (a.unreadCount === 0 && b.unreadCount > 0) return 1;
          // Potem po dacie ostatniej wiadomości
          return b.lastMessage.timestamp - a.lastMessage.timestamp;
        });

        // Wyświetl wiadomości
        const messagesHtml = conversationsArray.map(conversation => {
          const lastMsg = conversation.lastMessage;
          const date = new Date(lastMsg.timestamp).toLocaleString("pl-PL", {
            day: '2-digit',
            month: '2-digit',
            hour: '2-digit',
            minute: '2-digit'
          });

          const hasUnread = conversation.unreadCount > 0;
          const statusText = lastMsg.status === 'completed' ? 'Zakończona' : 'Aktywna';

          // Hierarchia wyświetlania: zawsze nickname/displayName, email tylko jeśli brak nazwy
          const displayName = conversation.senderName || conversation.senderEmail;
          const displaySubtext = conversation.senderName ? conversation.senderEmail : '';

          // Ikona kategorii
          const categoryIcon = conversation.categoryName === 'Zamówienia' ? 'fa-shopping-cart' :
                               conversation.categoryName === 'Oferty' ? 'fa-tag' : 'fa-circle';

          return `
            <div class="message-item bg-zinc-800/50 rounded-lg p-4 cursor-pointer hover:bg-zinc-800/70 transition-all duration-200 border ${hasUnread ? 'border-l-4 border-l-coyote glowing-border' : 'border-zinc-700'}"
                 data-user-id="${conversation.senderId}"
                 data-user-name="${conversation.senderName}"
                 data-user-email="${conversation.senderEmail}">
              <div class="flex items-start justify-between mb-3">
                <div class="flex items-center space-x-3">
                  <div class="w-10 h-10 bg-coyote rounded-full flex items-center justify-center">
                    <i class="fa-solid fa-user text-black text-sm"></i>
                  </div>
                  <div class="flex items-center space-x-2">
                    <div>
                      <h4 class="font-semibold text-white flex items-center gap-2">
                        <i class="fa-solid ${categoryIcon} text-xs" style="color: ${conversation.categoryColor}"></i>
                        ${displayName}
                      </h4>
                      ${displaySubtext ? `<p class="text-sm text-zinc-400">${displaySubtext}</p>` : ''}
                    </div>
                  </div>
                </div>
                <div class="text-right">
                  <div class="text-xs text-zinc-500 mb-2">${date}</div>
                  <div class="flex flex-col items-end space-y-1">
                    <span class="${lastMsg.status === 'completed' ? 'text-green-400' : 'text-orange-400'} text-xs font-medium">
                      ${statusText}
                    </span>
                    <span class="px-2 py-1 rounded text-xs font-medium"
                          style="background-color: ${conversation.categoryColor}20; color: ${conversation.categoryColor}; border: 1px solid ${conversation.categoryColor}40;">
                      ${conversation.categoryName}
                    </span>
                  </div>
                </div>
              </div>

              <div class="mb-3">
                <p class="text-zinc-300 text-sm leading-relaxed">
                  ${lastMsg.topic ? `<strong>${lastMsg.topic}:</strong> ` : ''}
                  ${lastMsg.content.length > 150 ? lastMsg.content.substring(0, 150) + '...' : lastMsg.content}
                </p>
              </div>

              <div class="flex items-center justify-between text-xs text-zinc-500">
                <span>${conversation.totalMessages} wiadomości</span>
              </div>
            </div>
          `;
        }).join('');

        messagesContainer.innerHTML = messagesHtml;

        // Dodaj event listenery do wszystkich elementów wiadomości
        const messageItems = messagesContainer.querySelectorAll('.message-item');
        messageItems.forEach(item => {
          item.addEventListener('click', function() {
            const userId = this.getAttribute('data-user-id');
            const userName = this.getAttribute('data-user-name');
            const userEmail = this.getAttribute('data-user-email');
            if (userId && userName && userEmail) {
              openMessageChat(userId, userName, userEmail);
            }
          });
        });
      }

      // Funkcja otwierania czatu z wiadomością
      async function openMessageChat(userId, userName, userEmail) {
        currentConversationUser = { id: userId, name: userName, email: userEmail };

        // Pokaż modal
        document.getElementById('chat-modal').classList.remove('hidden');

        // Ustaw informacje użytkownika
        const chatNameEl2 = document.getElementById('chat-user-name');
        if (chatNameEl2) chatNameEl2.textContent = userName;
        const chatEmailEl2 = document.getElementById('chat-user-email');
        if (chatEmailEl2) chatEmailEl2.textContent = userEmail;

        // Załaduj kategorie do select
        const categorySelect = document.getElementById('chat-category-select');
        categorySelect.innerHTML = '<option value="">Ładowanie...</option>';

        try {
          const categoriesRef = collection(db, "messageCategories");
          const categoriesSnapshot = await getDocs(categoriesRef);
          
          const categories = [];
          categoriesSnapshot.forEach((doc) => {
            categories.push({
              id: doc.id,
              ...doc.data()
            });
          });
          
          categorySelect.innerHTML = categories.map(cat =>
            `<option value="${cat.id}">${cat.name}</option>`
          ).join('');

          // Ustaw aktualną kategorię rozmowy
          try {
            const messagesRef = collection(db, "privateMessages");
            const messagesQuery = query(
              messagesRef,
              where("senderId", "==", userId),
              where("recipientId", "==", "admin"),
              orderBy("timestamp", "desc"),
              limit(1)
            );
            const messagesSnapshot = await getDocs(messagesQuery);
            if (!messagesSnapshot.empty) {
              const latestMessage = { id: messagesSnapshot.docs[0].id, ...messagesSnapshot.docs[0].data() };
              if (latestMessage.category_id) {
                categorySelect.value = latestMessage.category_id;
              }
            }
          } catch (error) {
            console.error('Error setting current category:', error);
          }
        } catch (error) {
          console.error('Error loading categories for chat:', error);
          categorySelect.innerHTML = '<option value="">Błąd ładowania</option>';
        }

        // Obsługa klawisza Enter jest już dodana globalnie w init()

        // Załaduj wiadomości konwersacji
        await loadConversationMessages(userId);
      }

      // Funkcja otwierania modalu szybkich odpowiedzi
      async function openQuickRepliesMenu() {
        const modal = document.getElementById('quick-replies-modal');
        const listContainer = document.getElementById('quick-replies-list');

        modal.classList.remove('hidden');
        listContainer.innerHTML = '<div class="text-center text-zinc-500 py-8"><i class="fa-solid fa-spinner fa-spin"></i> Ładowanie...</div>';

        try {
          // TODO: Implementacja przez Firebase Firestore - pobranie quickReplies z kolekcji
          listContainer.innerHTML = '<div class="text-center text-zinc-500 py-8">Funkcja wymaga implementacji przez Firebase</div>';
        } catch (error) {
          console.error('Error loading quick replies:', error);
          listContainer.innerHTML = '<div class="text-center text-red-400 py-8">Błąd ładowania szablonów</div>';
        }
      }

      // Funkcja wyboru szybkiej odpowiedzi
      function selectQuickReply(content) {
        const input = document.getElementById('chat-reply-input');
        if (input) {
          input.value = content.replace(/\\n/g, '\n').replace(/\\'/g, "'");
          input.focus();
        }
        closeQuickRepliesModal();
      }

      // Funkcja zamykania modalu szybkich odpowiedzi
      function closeQuickRepliesModal() {
        document.getElementById('quick-replies-modal').classList.add('hidden');
      }

      // Funkcja zamykania modalu czatu
      function closeChatModal() {
        document.getElementById('chat-modal').classList.add('hidden');
        currentConversationUser = null;
      }

      // Funkcja ładowania wiadomości konwersacji
      async function loadConversationMessages(userId) {
        const messagesContainer = document.getElementById('chat-messages');
        messagesContainer.innerHTML = '<div class="text-center text-zinc-500 py-8"><i class="fa-solid fa-spinner fa-spin"></i> Ładowanie...</div>';

        try {
          // Pobierz wszystkie wiadomości między adminem a użytkownikiem
          const [response1, response2] = await Promise.all([
            fetch(`/api/messages?senderId=${userId}&recipientId=admin&limit=100`),
            fetch(`/api/messages?senderId=admin&recipientId=${userId}&limit=100`)
          ]);

          const [data1, data2] = await Promise.all([
            response1.json(),
            response2.json()
          ]);

          if (!data1.success || !data2.success) {
            throw new Error('Failed to load conversation');
          }

          // Połącz i posortuj wiadomości
          const allMessages = [...data1.data.messages, ...data2.data.messages]
            .sort((a, b) => a.timestamp - b.timestamp);

          if (allMessages.length === 0) {
            messagesContainer.innerHTML = '<div class="text-center text-zinc-500 py-8">Brak wiadomości w tej konwersacji</div>';
            return;
          }

          // Znajdź punkt zmiany statusu z completed na in_progress
          let statusChangeIndex = -1;
          for (let i = 0; i < allMessages.length; i++) {
            if (allMessages[i] && allMessages[i].status === 'in_progress' && i > 0 && allMessages[i-1] && allMessages[i-1].status === 'completed') {
              statusChangeIndex = i;
              break;
            }
          }

          // Wyświetl wiadomości
          const messagesHtml = allMessages.map((msg, index) => {
            if (!msg) return ''; // Pomiń null/undefined wiadomości

            const isFromUser = msg.senderId !== 'admin';
            const isCompletedSession = msg.status === 'completed';
            const time = new Date(msg.timestamp || Date.now()).toLocaleString("pl-PL", {
              hour: '2-digit',
              minute: '2-digit',
              day: '2-digit',
              month: '2-digit'
            });

            // Dodaj separator jeśli to początek nowej części konwersacji
            let separatorHtml = '';
            if (index === statusChangeIndex) {
              const messageDate = new Date(msg.timestamp || Date.now()).toLocaleDateString("pl-PL", {
                day: '2-digit',
                month: '2-digit',
                year: 'numeric'
              });
              separatorHtml = `
                <div class="flex justify-center my-6">
                  <div class="bg-zinc-600 text-zinc-200 px-6 py-3 rounded-full text-sm font-semibold border-2 border-zinc-500">
                    --- NOWE ZGŁOSZENIE ${messageDate} ---
                  </div>
                </div>
              `;
            }

            // Liquid Glass styling: nowe wiadomości = brighter, archived = darker and more transparent
            const messageClasses = isCompletedSession
              ? (isFromUser
                  ? 'bg-zinc-800/40 backdrop-blur-sm border border-zinc-600/30'
                  : 'bg-zinc-800/40 backdrop-blur-sm border border-solid')
              : (isFromUser
                  ? 'bg-zinc-700/80 backdrop-blur-md border border-zinc-600/60'
                  : 'bg-zinc-700/80 backdrop-blur-md border border-solid');

            // Add coyote border for admin messages
            const adminBorderStyle = !isFromUser ? 'border' : '';

            // Funkcja czyszczenia zawartości wiadomości - usuwa nagłówki
            function cleanMessageContent(content) {
              if (!content) return '';

              // Usuń nagłówki jak "Odpowiedź administratora:", "Pytanie o produkt:", itp.
              const headerPatterns = [
                /^Odpowiedź administratora:?\s*/i,
                /^Pytanie o produkt:?\s*/i,
                /^Pytanie o produkty:?\s*/i,
                /^Zapytanie:?\s*/i,
                /^Wiadomość:?\s*/i
              ];

              let cleanedContent = content;
              for (const pattern of headerPatterns) {
                cleanedContent = cleanedContent.replace(pattern, '');
              }

              return cleanedContent.trim();
            }

            const cleanedContent = cleanMessageContent(msg.content || '');

            return separatorHtml + `
              <div class="flex ${isFromUser ? 'justify-start' : 'justify-end'} mb-4">
                <div class="max-w-[70%] ${messageClasses} ${adminBorderStyle} rounded-lg p-3" ${!isFromUser ? 'style="border: 1px solid var(--coyote);"' : ''}>
                  <div class="text-sm text-zinc-100 whitespace-pre-wrap">${cleanedContent}</div>
                  <div class="text-xs text-zinc-400 mt-2">${time}</div>
                </div>
              </div>
            `;
          }).join('');

          messagesContainer.innerHTML = messagesHtml;

          // Przewiń na dół
          setTimeout(() => {
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
          }, 100);

          // Oznacz wiadomości jako przeczytane
          for (const msg of allMessages) {
            if (msg.senderId === userId && !msg.isRead) {
              await fetch(`/api/messages/${msg.id}/read`, { method: 'PUT' });
            }
          }

          // Odśwież status
          loadMessagesStatus();

          // Aktualizuj przycisk zakończ/rozpocznij
          updateCompleteButton();

        } catch (error) {
          console.error('Error loading conversation:', error);
          messagesContainer.innerHTML = '<div class="text-center text-red-400 py-8">Błąd ładowania konwersacji</div>';
        }
      }

      // Funkcja wysyłania odpowiedzi
      async function sendChatReply() {
        if (!currentConversationUser) return;

        const input = document.getElementById('chat-reply-input');
        const content = input.value.trim();

        if (!content) {
          showNotification("Wpisz wiadomość przed wysłaniem", "warning");
          return;
        }

        try {
          // Wyślij odpowiedź przez API /api/messages (wspólna "Pomoc STRZELCA.PL")
          let categoryId = null;
          try {
            const latest = await fetch(`/api/messages?senderId=${currentConversationUser.id}&recipientId=admin&limit=1`, {
              method: 'GET',
              credentials: 'include',
              cache: 'no-store',
            }).then(r => r.json());
            categoryId = latest?.success && latest?.data?.messages?.[0]?.categoryId ? latest.data.messages[0].categoryId : null;
          } catch {}

          const payload = {
            recipientId: currentConversationUser.id,
            content: content,
            status: 'in_progress',
          };
          if (categoryId) payload.categoryId = categoryId;

          const res = await fetch('/api/messages', {
            method: 'POST',
            headers: { 
              'Content-Type': 'application/json',
              'X-Admin-Panel': 'true' // Oznacz, że wiadomość jest z panelu administracyjnego
            },
            credentials: 'include',
            body: JSON.stringify(payload),
          });
          const data = await res.json().catch(() => null);
          if (!res.ok || !data?.success) {
            throw new Error(data?.error || `HTTP ${res.status}`);
          }

          input.value = '';
          await loadConversationMessages(currentConversationUser.id);
          loadMessagesWithFilters();
          loadMessagesStatus();
          showNotification("Wiadomość została wysłana", "success");

        } catch (error) {
          console.error('Error sending reply:', error);
          showNotification("Błąd wysyłania wiadomości", "error");
        }
      }

      // Funkcja zakończenia konwersacji
      async function toggleConversationStatus() {
        if (!currentConversationUser) return;

        const btn = document.getElementById('complete-start-btn');
        const isCurrentlyCompleted = btn.innerHTML.includes('ROZPOCZNIJ');

        if (isCurrentlyCompleted) {
          // Restart the conversation (from completed to in_progress)
          try {
            // Znajdź najnowszą wiadomość w konwersacji i przywróć do in_progress
            const response = await fetch(`/api/messages?senderId=${currentConversationUser.id}&recipientId=admin&status=completed&limit=1`);
            const data = await response.json();

            if (data.success && data.data.messages.length > 0) {
              const latestMessage = data.data.messages[0];
              await fetch(`/api/messages/${latestMessage.id}/status`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ status: 'in_progress' })
              });
            }

            // Odśwież chat
            loadConversationMessages(currentConversationUser.id);
            loadMessagesWithFilters();
            loadMessagesStatus();

            showNotification("Konwersacja została wznowiona", "success");

          } catch (error) {
            console.error('Error restarting conversation:', error);
          }
        } else {
          // Complete the conversation (from in_progress to completed)
          if (!confirm('Czy na pewno chcesz zakończyć tę konwersację?')) return;

          try {
            // Znajdź najnowszą wiadomość w konwersacji i oznacz jako completed
            const response = await fetch(`/api/messages?senderId=${currentConversationUser.id}&recipientId=admin&status=in_progress&limit=1`);
            const data = await response.json();

            if (data.success && data.data.messages.length > 0) {
              const latestMessage = data.data.messages[0];
              await fetch(`/api/messages/${latestMessage.id}/status`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ status: 'completed' })
              });
            }

            // Zamknij modal
            closeChatModal();

            // Odśwież wszystko
            loadMessagesWithFilters();
            loadMessagesStatus();

            showNotification("Konwersacja została zakończona", "success");

          } catch (error) {
            console.error('Error completing conversation:', error);
            showNotification("Błąd podczas kończenia konwersacji", "error");
          }
        }
      }

      // Funkcja aktualizacji przycisku na podstawie statusu konwersacji
      function updateCompleteButton() {
        if (!currentConversationUser) return;

        const btn = document.getElementById('complete-start-btn');
        if (!btn) return;

        // Sprawdź czy konwersacja jest zakończona
        fetch(`/api/messages?senderId=${currentConversationUser.id}&recipientId=admin&status=completed&limit=1`)
          .then(response => response.json())
          .then(data => {
            if (data.success && data.data.messages.length > 0) {
              // Konwersacja zakończona - pokaż przycisk ROZPOCZNIJ
              btn.innerHTML = '<i class="fa-solid fa-times mr-2 text-red-400"></i>ROZPOCZNIJ';
            } else {
              // Konwersacja aktywna - pokaż przycisk ZAKOŃCZ
              btn.innerHTML = '<i class="fa-solid fa-check mr-2 text-green-400"></i>ZAKOŃCZ';
            }
          })
          .catch(error => {
            console.error('Error checking conversation status:', error);
          });
      }

      async function refreshMessages() {
        console.log('🔄 Manual refresh triggered');

        // Dodaj animację obracania
        const refreshIcon = document.getElementById('refresh-icon');
        if (refreshIcon) {
          refreshIcon.classList.add('fa-spin');
        }

        try {
          await loadMessages();
          loadMessagesStatus(); // Odśwież też status
        } finally {
          // Zatrzymaj animację po 1 sekundzie
          setTimeout(() => {
            if (refreshIcon) {
              refreshIcon.classList.remove('fa-spin');
            }
          }, 1000);
        }
      }

      // Funkcja aktualizacji podświetlenia przycisków kategorii
      async function updateCategoryButtonsHighlight() {
        const categoryButtonsEl = document.getElementById('category-buttons');
        if (!categoryButtonsEl) return;

        try {
          // Pobierz kategorie jeśli nie są jeszcze załadowane
          if (!window.cachedCategories) {
            const categoriesRef = collection(db, "messageCategories");
            const categoriesSnapshot = await getDocs(categoriesRef);
            
            window.cachedCategories = [];
            categoriesSnapshot.forEach((doc) => {
              const catData = { id: doc.id, ...doc.data() };
              if (catData.is_active !== false) {
                window.cachedCategories.push(catData);
              }
            });
          }

          const categories = window.cachedCategories || [];

          let categoryButtons = '';

          // Dodaj przycisk "Wszystkie"
          const isAllActive = !currentFilters.category || currentFilters.category === 'all' || ['unread', 'completed'].includes(currentFilters.category);
          categoryButtons += `
            <button onclick="filterMessages('all')"
                    class="px-3 py-2 rounded-lg transition-all duration-200 font-medium liquid-glass-button flex items-center gap-2"
                    style="color: #6B7280; ${isAllActive ? `background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px); border: 1px solid #6B728060;` : `background: rgba(255, 255, 255, 0.05); backdrop-filter: blur(5px); border: 1px solid rgba(255, 255, 255, 0.1);`}">
              <i class="fa-solid fa-list text-xs"></i>
              Wszystkie
            </button>
          `;

          categories.forEach(cat => {
            const isActive = currentFilters.category === cat.name.toLowerCase().replace(/\s+/g, '');
            const categoryIcon = cat.icon || 'fa-circle';
            const categoryColor = userFilterColors[cat.name.toLowerCase().replace(/\s+/g, '')] || cat.color || '#6B7280';
            categoryButtons += `
              <button onclick="filterMessages('${cat.name.toLowerCase().replace(/\s+/g, '')}')"
                      class="px-3 py-2 rounded-lg transition-all duration-200 font-medium liquid-glass-button flex items-center gap-2"
                      style="color: ${categoryColor}; ${isActive ? `background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px); border: 1px solid ${categoryColor}60;` : `background: rgba(255, 255, 255, 0.05); backdrop-filter: blur(5px); border: 1px solid rgba(255, 255, 255, 0.1);`}">
                <i class="fa-solid ${categoryIcon} text-xs"></i>
                ${cat.name}
              </button>
            `;
          });

          categoryButtonsEl.innerHTML = categoryButtons;
        } catch (error) {
          console.error('Error updating category buttons highlight:', error);
        }
      }

      // Funkcja filtrowania wiadomości po statusie
      function filterMessages(filterType) {
        console.log('filterMessages called with:', filterType);

        // Jeśli kliknięto w już aktywną kategorię, wróć do widoku wszystkich
        if (currentFilters.category === filterType && filterType !== 'all') {
          console.log('Clicked active category, resetting to all');
          filterType = 'all';
        }

        // Aktualizuj currentFilters
        currentFilters.category = filterType;
        currentFilters.search = document.getElementById('messages-search')?.value || '';
        console.log('Updated currentFilters:', currentFilters);

        // Zaktualizuj dropdown filtra
        const filterSelect = document.getElementById('messages-filter');
        if (filterSelect) {
          switch(filterType) {
            case 'unread':
              filterSelect.value = 'unread';
              break;
            case 'read':
              filterSelect.value = 'read';
              break;
            case 'completed':
              filterSelect.value = 'completed';
              break;
            case 'in_progress':
              filterSelect.value = 'in_progress';
              break;
            case 'all':
              filterSelect.value = 'all';
              break;
            default:
              // Dla kategorii wiadomości, ustaw na 'all' ponieważ select nie ma opcji kategorii
              filterSelect.value = 'all';
              break;
          }
        }

        // Przeładuj wiadomości
        loadMessagesWithFilters();
        // Przeładuj przyciski kategorii żeby zaktualizować podświetlenie
        updateCategoryButtonsHighlight();
      }

      // Funkcja przełączania dropdowna filtrów
      function toggleFilterDropdown() {
        console.log('toggleFilterDropdown called');
        const dropdown = document.getElementById('filter-dropdown');
        if (dropdown) {
          const isHidden = dropdown.classList.contains('hidden');
          dropdown.classList.toggle('hidden');
          console.log('Dropdown visibility toggled, was hidden:', isHidden, 'now hidden:', dropdown.classList.contains('hidden'));
        } else {
          console.warn('filter-dropdown element not found');
        }
      }

      // Funkcja zamykania dropdown gdy klikniemy gdzie indziej
      document.addEventListener('click', function(event) {
        const dropdown = document.getElementById('filter-dropdown');
        const filterBtn = event.target.closest('[onclick*="toggleFilterDropdown"]');

        if (dropdown && !dropdown.classList.contains('hidden') && !filterBtn && !dropdown.contains(event.target)) {
          console.log('Closing dropdown by outside click');
          dropdown.classList.add('hidden');
        }
      });

      // Udostępnij funkcje globalnie
      window.toggleFilterDropdown = toggleFilterDropdown;

      // Funkcja czyszczenia filtrów
      function clearFilters() {
        currentFilters = { search: '', category: 'all', status: 'all' };
        document.getElementById('messages-search').value = '';
        const filterSelect = document.getElementById('messages-filter');
        if (filterSelect) filterSelect.value = 'all';
        loadMessagesWithFilters();
        // Odśwież liczniki statusów
        loadMessagesStatus();
      }

      // Funkcja czyszczenia wyszukiwania wiadomości
      function clearMessagesSearch() {
        console.log('clearMessagesSearch called');
        const searchInput = document.getElementById('messages-search');
        if (searchInput) {
          searchInput.value = '';
          searchInput.focus();
        }
        currentFilters.search = '';
        loadMessagesWithFilters();
        // Ukryj przycisk clear
        const clearBtn = document.getElementById('clear-search-btn');
        if (clearBtn) {
          clearBtn.classList.add('opacity-0');
          clearBtn.classList.remove('opacity-100');
          console.log('Clear button hidden');
        }
      }

      // Zmienna do śledzenia czy użytkownik pisze
      let isUserTyping = false;
      let typingTimeout = null;
      let messagesAutoRefresh = null; // Deklaracja zmiennej dla auto-odświeżania wiadomości

      // Funkcja automatycznego odświeżania
      function startAutoRefresh() {
        if (messagesAutoRefresh) {
          clearInterval(messagesAutoRefresh);
        }

        messagesAutoRefresh = setInterval(() => {
          if (currentTab === 'messages' && !isUserTyping) {
            loadMessages(); // Odśwież wszystkie wiadomości
          }
        }, 60000); // Co 60 sekund
      }

      // Funkcja zatrzymania auto-odświeżania
      function stopAutoRefresh() {
        if (messagesAutoRefresh) {
          clearInterval(messagesAutoRefresh);
          messagesAutoRefresh = null;
        }
      }

      // Funkcje obsługi pisania
      function handleTypingStart() {
        isUserTyping = true;
        // Zatrzymaj timeout jeśli istnieje
        if (typingTimeout) {
          clearTimeout(typingTimeout);
        }
      }

      function handleTypingEnd() {
        // Ustaw timeout na 3 sekundy po zakończeniu pisania
        typingTimeout = setTimeout(() => {
          isUserTyping = false;
        }, 3000);
      }

      // Dodaj event listenery do pól tekstowych
      function setupTypingListeners() {
        const searchInput = document.getElementById('messages-search');
        const chatInput = document.getElementById('chat-reply-input');

        if (searchInput) {
          searchInput.addEventListener('input', handleTypingStart);
          searchInput.addEventListener('blur', handleTypingEnd);
          searchInput.addEventListener('input', function() {
            const clearBtn = document.getElementById('clear-search-btn');
            if (clearBtn) {
              if (this.value.length > 0) {
                clearBtn.classList.remove('opacity-0');
                clearBtn.classList.add('opacity-100');
              } else {
                clearBtn.classList.add('opacity-0');
                clearBtn.classList.remove('opacity-100');
              }
            }
          });
        }

        if (chatInput) {
          chatInput.addEventListener('input', handleTypingStart);
          chatInput.addEventListener('blur', handleTypingEnd);
        }
      }

      // Funkcje zarządzania kategoriami
      async function openCategoriesSettings() {
        document.getElementById('categories-modal').classList.remove('hidden');
        await loadCategoriesForSettings();
      }

      function closeCategoriesModal() {
        document.getElementById('categories-modal').classList.add('hidden');
      }

      async function loadCategoriesForSettings() {
        const container = document.getElementById('categories-list');
        container.innerHTML = '<div class="text-center text-zinc-500 py-8"><i class="fa-solid fa-spinner fa-spin"></i> Ładowanie...</div>';

        try {
          const categoriesRef = collection(db, "messageCategories");
          const categoriesSnapshot = await getDocs(categoriesRef);
          
          const categories = [];
          categoriesSnapshot.forEach((doc) => {
            categories.push({
              id: doc.id,
              ...doc.data()
            });
          });

          const categoriesHtml = categories.map(category => `
              <div class="flex items-center justify-between p-4 bg-zinc-800 rounded-lg">
                <div class="flex items-center space-x-3">
                  <div class="w-8 h-8 rounded" style="background-color: ${category.color}"></div>
                  <div>
                    <div class="font-semibold text-white">${category.name}</div>
                    <div class="text-sm text-zinc-400">${category.icon}</div>
                  </div>
                </div>
                <div class="flex items-center space-x-2">
                  <button onclick="editCategory('${category.id}')" class="text-zinc-400 hover:text-white">
                    <i class="fa-solid fa-edit"></i>
                  </button>
                  <button onclick="deleteCategory('${category.id}')" class="text-zinc-400 hover:text-red-400">
                    <i class="fa-solid fa-trash"></i>
                  </button>
                </div>
              </div>
            `).join('');

          container.innerHTML = categoriesHtml;
        } catch (error) {
          console.error('Error loading categories for settings:', error);
          container.innerHTML = '<div class="text-center text-red-400 py-8">Błąd ładowania kategorii</div>';
        }
      }

      // Funkcje edycji kategorii (placeholder - do implementacji)
      function addNewCategory() {
        showNotification("Funkcjonalność dodawania kategorii zostanie dodana wkrótce", "info");
      }

      function editCategory(id) {
        showNotification("Funkcjonalność edycji kategorii zostanie dodana wkrótce", "info");
      }

      async function deleteCategory(id) {
        if (!confirm('Czy na pewno chcesz usunąć tę kategorię?')) return;

        try {
          const response = await fetch(`/api/messages/categories/${id}`, {
            method: 'DELETE'
          });

          const data = await response.json();

          if (data.success) {
            await loadCategoriesForSettings();
            await loadCategories();
            showNotification("Kategoria została usunięta", "success");
          } else {
            throw new Error(data.error);
          }
        } catch (error) {
          console.error('Error deleting category:', error);
          showNotification("Błąd podczas usuwania kategorii", "error");
        }
      }

      // Funkcja przełączania do zakładki Users i wyszukiwania użytkownika
      function switchToUsersTab(userId) {
        if (!userId) {
          showNotification("Brak ID użytkownika", "warning");
          return;
        }

        // Przełącz na zakładkę Users
        switchTab('users');

        // Po krótkim opóźnieniu otwórz szczegóły użytkownika
        setTimeout(() => {
          if (window.viewUserDetails) {
            window.viewUserDetails(userId);
          }
        }, 500);
      }

      // Funkcja wyświetlania profilu użytkownika (placeholder)
      function viewUserProfile(userId) {
        showNotification(`Funkcjonalność profilu użytkownika zostanie dodana wkrótce (ID: ${userId})`, "info");
      }

      // Utility function - debounce
      function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      }

      // Funkcje pomocnicze dla logowania administratora (global scope)


      // Globalne funkcje pomocnicze dla lokalnych administratorów


      // Wyłączone: osobne logowanie administratora
      // Panel korzysta z wspólnego logowania (`konto.strzelca.pl/logowanie.html`) + SSO cookie.
      document.addEventListener('DOMContentLoaded', function() {
        // no-op
      });

      // Inicjalizacja event listenera dla zmiany kategorii czatu
      document.addEventListener('DOMContentLoaded', function() {
        const categorySelect = document.getElementById('chat-category-select');
        if (categorySelect && !categorySelect.hasCategoryListener) {
          categorySelect.hasCategoryListener = true;
          categorySelect.addEventListener('change', async function() {
            const selectedCategoryId = this.value;
            if (!selectedCategoryId) {
              console.log('No category selected, skipping update');
              return;
            }

            if (!currentConversationUser || !currentConversationUser.id) {
              console.error('No current conversation user available');
              showNotification("Błąd: Brak aktywnej rozmowy", "error");
              return;
            }

            try {
              // Zaktualizuj kategorię rozmowy bezpośrednio w Firestore
              const conversationRef = doc(db, 'conversations', currentConversationUser.id);
              await updateDoc(conversationRef, {
                categoryId: selectedCategoryId,
                updatedAt: new Date()
              });

              console.log('Kategoria zmieniona pomyślnie w Firestore');
              // Zaktualizuj wartość selecta żeby pokazywał nową kategorię
              this.value = selectedCategoryId;

              showNotification("Kategoria rozmowy została zaktualizowana", "success");

              // Odśwież dane po krótkim opóźnieniu, żeby dać czas na zapisanie zmian
              setTimeout(() => {
                loadMessagesWithFilters();
                updateCategoryButtonsHighlight();
                // Odśwież kolory w modalu czatu jeśli potrzebne
                updateChatModalCategoryColors(selectedCategoryId);
              }, 500);
            } catch (error) {
              console.error('Error updating category:', error);
              showNotification("Błąd podczas aktualizacji kategorii", "error");
            }
          });
        }
      });

      // Funkcja do aktualizacji kolorów w modalu czatu
      function updateChatModalCategoryColors(categoryId) {
        if (!categoryId) return;

        // Znajdź kategorię po ID żeby uzyskać kolor
        try {
          const categoriesRef = collection(db, "messageCategories");
          getDocs(categoriesRef).then((snapshot) => {
            const categories = [];
            snapshot.forEach((doc) => {
              categories.push({ id: doc.id, ...doc.data() });
            });
            const category = categories.find(cat => cat.id == categoryId);
            if (category) {
              const categoryColor = userFilterColors[category.name.toLowerCase().replace(/\s+/g, '')] || category.color || '#6B7280';

              // Zaktualizuj style w modalu czatu jeśli potrzebne
              const chatModal = document.getElementById('chat-modal');
              if (chatModal) {
                // Możesz dodać specjalne style dla aktywnej kategorii w modalu
                console.log('Category color updated in chat modal:', categoryColor);
              }
            }
          });
        } catch (error) {
          console.error('Error updating chat modal colors:', error);
        }
      }

    </script>

    <!-- Global loading overlay -->
    <div id="dashboard-loading-overlay" class="dashboard-loading-overlay">
      <div class="loading-content">
        <div class="loading-spinner-large">
          <i class="fa-solid fa-sync-alt"></i>
        </div>
        <p class="loading-text">Odświeżanie dashboardu...</p>
      </div>
    </div>
    <script
      type="module"
      src="https://strzelca.pl/auth-widget.mjs?v=2026-02-06-1"
    ></script>
    <script
      type="module"
      src="https://strzelca.pl/messages-widget.mjs?v=2026-02-05-14"
    ></script>
  </body>
</html>
</html>